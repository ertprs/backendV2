import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
  Sql,
  Decimal,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }
export { Decimal }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw, Sql }

/**
 * Prisma Client JS version: 2.11.0-dev.30
 * Query Engine version: 58369335532e47bdcec77a2f1e7c1fb83a463918
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;

declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Centrodecustos
 * const centrodecustos = await prisma.centrodecustos.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;

  /**
   * `prisma.centrodecustos`: Exposes CRUD operations for the **centrodecustos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Centrodecustos
    * const centrodecustos = await prisma.centrodecustos.findMany()
    * ```
    */
  get centrodecustos(): centrodecustosDelegate;

  /**
   * `prisma.empresas`: Exposes CRUD operations for the **empresas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresas.findMany()
    * ```
    */
  get empresas(): empresasDelegate;

  /**
   * `prisma.operadoras`: Exposes CRUD operations for the **operadoras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operadoras
    * const operadoras = await prisma.operadoras.findMany()
    * ```
    */
  get operadoras(): operadorasDelegate;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): usuariosDelegate;

  /**
   * `prisma.dados`: Exposes CRUD operations for the **dados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dados
    * const dados = await prisma.dados.findMany()
    * ```
    */
  get dados(): dadosDelegate;

  /**
   * `prisma.passagens`: Exposes CRUD operations for the **passagens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passagens
    * const passagens = await prisma.passagens.findMany()
    * ```
    */
  get passagens(): passagensDelegate;

  /**
   * `prisma.escalas`: Exposes CRUD operations for the **escalas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escalas
    * const escalas = await prisma.escalas.findMany()
    * ```
    */
  get escalas(): escalasDelegate;

  /**
   * `prisma.meurh`: Exposes CRUD operations for the **meurh** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meurhs
    * const meurhs = await prisma.meurh.findMany()
    * ```
    */
  get meurh(): meurhDelegate;

  /**
   * `prisma.ocorrencias`: Exposes CRUD operations for the **ocorrencias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ocorrencias
    * const ocorrencias = await prisma.ocorrencias.findMany()
    * ```
    */
  get ocorrencias(): ocorrenciasDelegate;

  /**
   * `prisma.tiposocorrencias`: Exposes CRUD operations for the **tiposocorrencias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tiposocorrencias
    * const tiposocorrencias = await prisma.tiposocorrencias.findMany()
    * ```
    */
  get tiposocorrencias(): tiposocorrenciasDelegate;

  /**
   * `prisma.escalascompetencia`: Exposes CRUD operations for the **escalascompetencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escalascompetencias
    * const escalascompetencias = await prisma.escalascompetencia.findMany()
    * ```
    */
  get escalascompetencia(): escalascompetenciaDelegate;

  /**
   * `prisma.meurhhistorico`: Exposes CRUD operations for the **meurhhistorico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meurhhistoricos
    * const meurhhistoricos = await prisma.meurhhistorico.findMany()
    * ```
    */
  get meurhhistorico(): meurhhistoricoDelegate;

  /**
   * `prisma.suporte`: Exposes CRUD operations for the **suporte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suportes
    * const suportes = await prisma.suporte.findMany()
    * ```
    */
  get suporte(): suporteDelegate;

  /**
   * `prisma.suportehistorico`: Exposes CRUD operations for the **suportehistorico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suportehistoricos
    * const suportehistoricos = await prisma.suportehistorico.findMany()
    * ```
    */
  get suportehistorico(): suportehistoricoDelegate;

  /**
   * `prisma.meurhrespostas`: Exposes CRUD operations for the **meurhrespostas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meurhrespostas
    * const meurhrespostas = await prisma.meurhrespostas.findMany()
    * ```
    */
  get meurhrespostas(): meurhrespostasDelegate;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): notificationDelegate;

  /**
   * `prisma.pedidos`: Exposes CRUD operations for the **pedidos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedidos.findMany()
    * ```
    */
  get pedidos(): pedidosDelegate;

  /**
   * `prisma.detalhepedidos`: Exposes CRUD operations for the **detalhepedidos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalhepedidos
    * const detalhepedidos = await prisma.detalhepedidos.findMany()
    * ```
    */
  get detalhepedidos(): detalhepedidosDelegate;

  /**
   * `prisma.detalhepedidos_old`: Exposes CRUD operations for the **detalhepedidos_old** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalhepedidos_olds
    * const detalhepedidos_olds = await prisma.detalhepedidos_old.findMany()
    * ```
    */
  get detalhepedidos_old(): detalhepedidos_oldDelegate;

  /**
   * `prisma.economia`: Exposes CRUD operations for the **economia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Economias
    * const economias = await prisma.economia.findMany()
    * ```
    */
  get economia(): economiaDelegate;

  /**
   * `prisma.solicitacoes`: Exposes CRUD operations for the **solicitacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Solicitacoes
    * const solicitacoes = await prisma.solicitacoes.findMany()
    * ```
    */
  get solicitacoes(): solicitacoesDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const CentrodecustosDistinctFieldEnum: {
  Id: 'Id',
  NmCentroDeCusto: 'NmCentroDeCusto',
  IdEmpresa: 'IdEmpresa',
  Situacao: 'Situacao'
};

export declare type CentrodecustosDistinctFieldEnum = (typeof CentrodecustosDistinctFieldEnum)[keyof typeof CentrodecustosDistinctFieldEnum]


export declare const EmpresasDistinctFieldEnum: {
  Id: 'Id',
  CNPJ: 'CNPJ',
  NmEmpresa: 'NmEmpresa',
  NmFantasia: 'NmFantasia',
  Endereco: 'Endereco',
  CEP: 'CEP',
  Situacao: 'Situacao',
  Tipo: 'Tipo'
};

export declare type EmpresasDistinctFieldEnum = (typeof EmpresasDistinctFieldEnum)[keyof typeof EmpresasDistinctFieldEnum]


export declare const OperadorasDistinctFieldEnum: {
  Id: 'Id',
  NmOperadora: 'NmOperadora',
  IdEmpresa: 'IdEmpresa',
  UF: 'UF'
};

export declare type OperadorasDistinctFieldEnum = (typeof OperadorasDistinctFieldEnum)[keyof typeof OperadorasDistinctFieldEnum]


export declare const UsuariosDistinctFieldEnum: {
  Id: 'Id',
  CPF: 'CPF',
  Nome: 'Nome',
  Senha: 'Senha',
  Email: 'Email',
  Lvl: 'Lvl'
};

export declare type UsuariosDistinctFieldEnum = (typeof UsuariosDistinctFieldEnum)[keyof typeof UsuariosDistinctFieldEnum]


export declare const DadosDistinctFieldEnum: {
  Id: 'Id',
  NmColaborador: 'NmColaborador',
  CPF: 'CPF',
  IdEmpresa: 'IdEmpresa',
  DtNascimento: 'DtNascimento',
  IdCentroDeCusto: 'IdCentroDeCusto',
  Matricula: 'Matricula',
  IdEscala: 'IdEscala',
  Situacao: 'Situacao'
};

export declare type DadosDistinctFieldEnum = (typeof DadosDistinctFieldEnum)[keyof typeof DadosDistinctFieldEnum]


export declare const PassagensDistinctFieldEnum: {
  Id: 'Id',
  CPF: 'CPF',
  NrCartao: 'NrCartao',
  Valor: 'Valor',
  IdOperadora: 'IdOperadora',
  QtdDia: 'QtdDia',
  Situacao: 'Situacao'
};

export declare type PassagensDistinctFieldEnum = (typeof PassagensDistinctFieldEnum)[keyof typeof PassagensDistinctFieldEnum]


export declare const EscalasDistinctFieldEnum: {
  Id: 'Id',
  IdEmpresa: 'IdEmpresa',
  NmEscala: 'NmEscala',
  Folgas: 'Folgas'
};

export declare type EscalasDistinctFieldEnum = (typeof EscalasDistinctFieldEnum)[keyof typeof EscalasDistinctFieldEnum]


export declare const MeurhDistinctFieldEnum: {
  Id: 'Id',
  Protocolo: 'Protocolo',
  CPF: 'CPF',
  DtTicketAbertura: 'DtTicketAbertura',
  DtTicketFechamento: 'DtTicketFechamento',
  Assunto: 'Assunto',
  Msg: 'Msg',
  Status: 'Status'
};

export declare type MeurhDistinctFieldEnum = (typeof MeurhDistinctFieldEnum)[keyof typeof MeurhDistinctFieldEnum]


export declare const OcorrenciasDistinctFieldEnum: {
  Id: 'Id',
  CPF: 'CPF',
  IdTipoOcorrencia: 'IdTipoOcorrencia',
  DtOcorrencia: 'DtOcorrencia'
};

export declare type OcorrenciasDistinctFieldEnum = (typeof OcorrenciasDistinctFieldEnum)[keyof typeof OcorrenciasDistinctFieldEnum]


export declare const TiposocorrenciasDistinctFieldEnum: {
  Id: 'Id',
  NmOcorrencia: 'NmOcorrencia',
  DescBeneficio: 'DescBeneficio',
  IdEmpresa: 'IdEmpresa',
  Descricao: 'Descricao'
};

export declare type TiposocorrenciasDistinctFieldEnum = (typeof TiposocorrenciasDistinctFieldEnum)[keyof typeof TiposocorrenciasDistinctFieldEnum]


export declare const EscalascompetenciaDistinctFieldEnum: {
  Id: 'Id',
  IdEscalas: 'IdEscalas',
  Competencia: 'Competencia',
  QtdUteis: 'QtdUteis',
  QtdFolgas: 'QtdFolgas'
};

export declare type EscalascompetenciaDistinctFieldEnum = (typeof EscalascompetenciaDistinctFieldEnum)[keyof typeof EscalascompetenciaDistinctFieldEnum]


export declare const MeurhhistoricoDistinctFieldEnum: {
  Id: 'Id',
  IdMeuRh: 'IdMeuRh',
  StatusAtual: 'StatusAtual',
  StatusNovo: 'StatusNovo',
  DtAlteracao: 'DtAlteracao'
};

export declare type MeurhhistoricoDistinctFieldEnum = (typeof MeurhhistoricoDistinctFieldEnum)[keyof typeof MeurhhistoricoDistinctFieldEnum]


export declare const SuporteDistinctFieldEnum: {
  Id: 'Id',
  Protocolo: 'Protocolo',
  CPF: 'CPF',
  DtTicketAbertura: 'DtTicketAbertura',
  DtTicketFechamento: 'DtTicketFechamento',
  Assunto: 'Assunto',
  Msg: 'Msg',
  Avaliacao: 'Avaliacao',
  Status: 'Status'
};

export declare type SuporteDistinctFieldEnum = (typeof SuporteDistinctFieldEnum)[keyof typeof SuporteDistinctFieldEnum]


export declare const SuportehistoricoDistinctFieldEnum: {
  Id: 'Id',
  IdSuporte: 'IdSuporte',
  StatusAtual: 'StatusAtual',
  StatusNovo: 'StatusNovo',
  DtAlteracao: 'DtAlteracao',
  Msg: 'Msg'
};

export declare type SuportehistoricoDistinctFieldEnum = (typeof SuportehistoricoDistinctFieldEnum)[keyof typeof SuportehistoricoDistinctFieldEnum]


export declare const MeurhrespostasDistinctFieldEnum: {
  Id: 'Id',
  IdMeuRh: 'IdMeuRh',
  DtResposta: 'DtResposta',
  CPF: 'CPF',
  Msg: 'Msg'
};

export declare type MeurhrespostasDistinctFieldEnum = (typeof MeurhrespostasDistinctFieldEnum)[keyof typeof MeurhrespostasDistinctFieldEnum]


export declare const NotificationDistinctFieldEnum: {
  Id: 'Id',
  CPF: 'CPF',
  Msg: 'Msg',
  lido: 'lido',
  created_at: 'created_at'
};

export declare type NotificationDistinctFieldEnum = (typeof NotificationDistinctFieldEnum)[keyof typeof NotificationDistinctFieldEnum]


export declare const PedidosDistinctFieldEnum: {
  Id: 'Id',
  IdEmpresa: 'IdEmpresa',
  Competencia: 'Competencia',
  DtInicialFolgas: 'DtInicialFolgas',
  DtFinalFolgas: 'DtFinalFolgas',
  DtInicialFaltas: 'DtInicialFaltas',
  DtFinalFaltas: 'DtFinalFaltas',
  Status: 'Status'
};

export declare type PedidosDistinctFieldEnum = (typeof PedidosDistinctFieldEnum)[keyof typeof PedidosDistinctFieldEnum]


export declare const DetalhepedidosDistinctFieldEnum: {
  Id: 'Id',
  IdPedido: 'IdPedido',
  NmColaborador: 'NmColaborador',
  CPF: 'CPF',
  NrCartao: 'NrCartao',
  IdOperadora: 'IdOperadora',
  NmOperadora: 'NmOperadora',
  ValorDia: 'ValorDia',
  NmEscala: 'NmEscala',
  QtdOcorrencias: 'QtdOcorrencias',
  QtdFolgas: 'QtdFolgas',
  QtdDias: 'QtdDias',
  QtdDiasUteis: 'QtdDiasUteis',
  Valor: 'Valor',
  Valor_Total: 'Valor_Total',
  MemoriaCalculo: 'MemoriaCalculo'
};

export declare type DetalhepedidosDistinctFieldEnum = (typeof DetalhepedidosDistinctFieldEnum)[keyof typeof DetalhepedidosDistinctFieldEnum]


export declare const Detalhepedidos_oldDistinctFieldEnum: {
  Id: 'Id',
  IdPedido: 'IdPedido',
  NmColaborador: 'NmColaborador',
  CPF: 'CPF',
  NrCartao: 'NrCartao',
  IdOperadora: 'IdOperadora',
  NmOperadora: 'NmOperadora',
  ValorDia: 'ValorDia',
  QtdFolgas: 'QtdFolgas',
  QtdDiasUteis: 'QtdDiasUteis',
  Valor: 'Valor',
  IdEscalas: 'IdEscalas',
  QtdVale: 'QtdVale',
  MemoriaCalculo: 'MemoriaCalculo'
};

export declare type Detalhepedidos_oldDistinctFieldEnum = (typeof Detalhepedidos_oldDistinctFieldEnum)[keyof typeof Detalhepedidos_oldDistinctFieldEnum]


export declare const EconomiaDistinctFieldEnum: {
  Id: 'Id',
  IdEmpresa: 'IdEmpresa',
  Competencia: 'Competencia',
  Valor: 'Valor'
};

export declare type EconomiaDistinctFieldEnum = (typeof EconomiaDistinctFieldEnum)[keyof typeof EconomiaDistinctFieldEnum]


export declare const SolicitacoesDistinctFieldEnum: {
  Id: 'Id',
  Protocolo: 'Protocolo',
  CPF: 'CPF',
  TipoSolicitacao: 'TipoSolicitacao',
  OrigemSolicitacao: 'OrigemSolicitacao',
  NrCartao: 'NrCartao',
  DtSolicitacao: 'DtSolicitacao',
  DtFinalizacao: 'DtFinalizacao',
  Status: 'Status'
};

export declare type SolicitacoesDistinctFieldEnum = (typeof SolicitacoesDistinctFieldEnum)[keyof typeof SolicitacoesDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]



/**
 * Model centrodecustos
 */

export type centrodecustos = {
  Id: number
  NmCentroDeCusto: string | null
  IdEmpresa: number | null
  Situacao: string | null
}


export type AggregateCentrodecustos = {
  count: number
  avg: CentrodecustosAvgAggregateOutputType | null
  sum: CentrodecustosSumAggregateOutputType | null
  min: CentrodecustosMinAggregateOutputType | null
  max: CentrodecustosMaxAggregateOutputType | null
}

export type CentrodecustosAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type CentrodecustosSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type CentrodecustosMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type CentrodecustosMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}


export type CentrodecustosAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type CentrodecustosSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type CentrodecustosMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type CentrodecustosMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type AggregateCentrodecustosArgs = {
  where?: centrodecustosWhereInput
  orderBy?: XOR<Enumerable<centrodecustosOrderByInput>, centrodecustosOrderByInput>
  cursor?: centrodecustosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CentrodecustosDistinctFieldEnum>
  count?: true
  avg?: CentrodecustosAvgAggregateInputType
  sum?: CentrodecustosSumAggregateInputType
  min?: CentrodecustosMinAggregateInputType
  max?: CentrodecustosMaxAggregateInputType
}

export type GetCentrodecustosAggregateType<T extends AggregateCentrodecustosArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetCentrodecustosAggregateScalarType<T[P]>
}

export type GetCentrodecustosAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof CentrodecustosAvgAggregateOutputType ? CentrodecustosAvgAggregateOutputType[P] : never
}
    
    

export type centrodecustosSelect = {
  Id?: boolean
  NmCentroDeCusto?: boolean
  IdEmpresa?: boolean
  Situacao?: boolean
  empresas?: boolean | empresasArgs
  dados?: boolean | FindManydadosArgs
}

export type centrodecustosInclude = {
  empresas?: boolean | empresasArgs
  dados?: boolean | FindManydadosArgs
}

export type centrodecustosGetPayload<
  S extends boolean | null | undefined | centrodecustosArgs,
  U = keyof S
> = S extends true
  ? centrodecustos
  : S extends undefined
  ? never
  : S extends centrodecustosArgs | FindManycentrodecustosArgs
  ? 'include' extends U
    ? centrodecustos  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'dados'
      ? Array<dadosGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof centrodecustos ? centrodecustos[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'dados'
      ? Array<dadosGetPayload<S['select'][P]>> : never
    }
  : centrodecustos
: centrodecustos


export interface centrodecustosDelegate {
  /**
   * Find zero or one Centrodecustos that matches the filter.
   * @param {FindOnecentrodecustosArgs} args - Arguments to find a Centrodecustos
   * @example
   * // Get one Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecentrodecustosArgs>(
    args: Subset<T, FindOnecentrodecustosArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos | null>, Prisma__centrodecustosClient<centrodecustosGetPayload<T> | null>>
  /**
   * Find the first Centrodecustos that matches the filter.
   * @param {FindFirstcentrodecustosArgs} args - Arguments to find a Centrodecustos
   * @example
   * // Get one Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstcentrodecustosArgs>(
    args?: Subset<T, FindFirstcentrodecustosArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos | null>, Prisma__centrodecustosClient<centrodecustosGetPayload<T> | null>>
  /**
   * Find zero or more Centrodecustos that matches the filter.
   * @param {FindManycentrodecustosArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.findMany()
   * 
   * // Get first 10 Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const centrodecustosWithIdOnly = await prisma.centrodecustos.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManycentrodecustosArgs>(
    args?: Subset<T, FindManycentrodecustosArgs>
  ): CheckSelect<T, Promise<Array<centrodecustos>>, Promise<Array<centrodecustosGetPayload<T>>>>
  /**
   * Create a Centrodecustos.
   * @param {centrodecustosCreateArgs} args - Arguments to create a Centrodecustos.
   * @example
   * // Create one Centrodecustos
   * const Centrodecustos = await prisma.centrodecustos.create({
   *   data: {
   *     // ... data to create a Centrodecustos
   *   }
   * })
   * 
  **/
  create<T extends centrodecustosCreateArgs>(
    args: Subset<T, centrodecustosCreateArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos>, Prisma__centrodecustosClient<centrodecustosGetPayload<T>>>
  /**
   * Delete a Centrodecustos.
   * @param {centrodecustosDeleteArgs} args - Arguments to delete one Centrodecustos.
   * @example
   * // Delete one Centrodecustos
   * const Centrodecustos = await prisma.centrodecustos.delete({
   *   where: {
   *     // ... filter to delete one Centrodecustos
   *   }
   * })
   * 
  **/
  delete<T extends centrodecustosDeleteArgs>(
    args: Subset<T, centrodecustosDeleteArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos>, Prisma__centrodecustosClient<centrodecustosGetPayload<T>>>
  /**
   * Update one Centrodecustos.
   * @param {centrodecustosUpdateArgs} args - Arguments to update one Centrodecustos.
   * @example
   * // Update one Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends centrodecustosUpdateArgs>(
    args: Subset<T, centrodecustosUpdateArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos>, Prisma__centrodecustosClient<centrodecustosGetPayload<T>>>
  /**
   * Delete zero or more Centrodecustos.
   * @param {centrodecustosDeleteManyArgs} args - Arguments to filter Centrodecustos to delete.
   * @example
   * // Delete a few Centrodecustos
   * const { count } = await prisma.centrodecustos.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends centrodecustosDeleteManyArgs>(
    args: Subset<T, centrodecustosDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Centrodecustos.
   * @param {centrodecustosUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends centrodecustosUpdateManyArgs>(
    args: Subset<T, centrodecustosUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Centrodecustos.
   * @param {centrodecustosUpsertArgs} args - Arguments to update or create a Centrodecustos.
   * @example
   * // Update or create a Centrodecustos
   * const centrodecustos = await prisma.centrodecustos.upsert({
   *   create: {
   *     // ... data to create a Centrodecustos
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Centrodecustos we want to update
   *   }
   * })
  **/
  upsert<T extends centrodecustosUpsertArgs>(
    args: Subset<T, centrodecustosUpsertArgs>
  ): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos>, Prisma__centrodecustosClient<centrodecustosGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManycentrodecustosArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateCentrodecustosArgs>(args: Subset<T, AggregateCentrodecustosArgs>): Promise<GetCentrodecustosAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for centrodecustos.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__centrodecustosClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  dados<T extends FindManydadosArgs = {}>(args?: Subset<T, FindManydadosArgs>): CheckSelect<T, Promise<Array<dados>>, Promise<Array<dadosGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * centrodecustos findOne
 */
export type FindOnecentrodecustosArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * Filter, which centrodecustos to fetch.
  **/
  where: centrodecustosWhereUniqueInput
}


/**
 * centrodecustos findFirst
 */
export type FindFirstcentrodecustosArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * Filter, which centrodecustos to fetch.
  **/
  where?: centrodecustosWhereInput
  orderBy?: XOR<Enumerable<centrodecustosOrderByInput>, centrodecustosOrderByInput>
  cursor?: centrodecustosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CentrodecustosDistinctFieldEnum>
}


/**
 * centrodecustos findMany
 */
export type FindManycentrodecustosArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * Filter, which centrodecustos to fetch.
  **/
  where?: centrodecustosWhereInput
  /**
   * Determine the order of the centrodecustos to fetch.
  **/
  orderBy?: XOR<Enumerable<centrodecustosOrderByInput>, centrodecustosOrderByInput>
  /**
   * Sets the position for listing centrodecustos.
  **/
  cursor?: centrodecustosWhereUniqueInput
  /**
   * The number of centrodecustos to fetch. If negative number, it will take centrodecustos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` centrodecustos.
  **/
  skip?: number
  distinct?: Enumerable<CentrodecustosDistinctFieldEnum>
}


/**
 * centrodecustos create
 */
export type centrodecustosCreateArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * The data needed to create a centrodecustos.
  **/
  data: centrodecustosCreateInput
}


/**
 * centrodecustos update
 */
export type centrodecustosUpdateArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * The data needed to update a centrodecustos.
  **/
  data: centrodecustosUpdateInput
  /**
   * Choose, which centrodecustos to update.
  **/
  where: centrodecustosWhereUniqueInput
}


/**
 * centrodecustos updateMany
 */
export type centrodecustosUpdateManyArgs = {
  data: centrodecustosUpdateManyMutationInput
  where?: centrodecustosWhereInput
}


/**
 * centrodecustos upsert
 */
export type centrodecustosUpsertArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * The filter to search for the centrodecustos to update in case it exists.
  **/
  where: centrodecustosWhereUniqueInput
  /**
   * In case the centrodecustos found by the `where` argument doesn't exist, create a new centrodecustos with this data.
  **/
  create: centrodecustosCreateInput
  /**
   * In case the centrodecustos was found with the provided `where` argument, update it with this data.
  **/
  update: centrodecustosUpdateInput
}


/**
 * centrodecustos delete
 */
export type centrodecustosDeleteArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
  /**
   * Filter which centrodecustos to delete.
  **/
  where: centrodecustosWhereUniqueInput
}


/**
 * centrodecustos deleteMany
 */
export type centrodecustosDeleteManyArgs = {
  where?: centrodecustosWhereInput
}


/**
 * centrodecustos without action
 */
export type centrodecustosArgs = {
  /**
   * Select specific fields to fetch from the centrodecustos
  **/
  select?: XOR<centrodecustosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<centrodecustosInclude, null>
}



/**
 * Model empresas
 */

export type empresas = {
  Id: number
  CNPJ: string | null
  NmEmpresa: string | null
  NmFantasia: string | null
  Endereco: string | null
  CEP: string | null
  Situacao: string | null
  Tipo: string | null
}


export type AggregateEmpresas = {
  count: number
  avg: EmpresasAvgAggregateOutputType | null
  sum: EmpresasSumAggregateOutputType | null
  min: EmpresasMinAggregateOutputType | null
  max: EmpresasMaxAggregateOutputType | null
}

export type EmpresasAvgAggregateOutputType = {
  Id: number
}

export type EmpresasSumAggregateOutputType = {
  Id: number
}

export type EmpresasMinAggregateOutputType = {
  Id: number
}

export type EmpresasMaxAggregateOutputType = {
  Id: number
}


export type EmpresasAvgAggregateInputType = {
  Id?: true
}

export type EmpresasSumAggregateInputType = {
  Id?: true
}

export type EmpresasMinAggregateInputType = {
  Id?: true
}

export type EmpresasMaxAggregateInputType = {
  Id?: true
}

export type AggregateEmpresasArgs = {
  where?: empresasWhereInput
  orderBy?: XOR<Enumerable<empresasOrderByInput>, empresasOrderByInput>
  cursor?: empresasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EmpresasDistinctFieldEnum>
  count?: true
  avg?: EmpresasAvgAggregateInputType
  sum?: EmpresasSumAggregateInputType
  min?: EmpresasMinAggregateInputType
  max?: EmpresasMaxAggregateInputType
}

export type GetEmpresasAggregateType<T extends AggregateEmpresasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEmpresasAggregateScalarType<T[P]>
}

export type GetEmpresasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EmpresasAvgAggregateOutputType ? EmpresasAvgAggregateOutputType[P] : never
}
    
    

export type empresasSelect = {
  Id?: boolean
  CNPJ?: boolean
  NmEmpresa?: boolean
  NmFantasia?: boolean
  Endereco?: boolean
  CEP?: boolean
  Situacao?: boolean
  Tipo?: boolean
  centrodecustos?: boolean | FindManycentrodecustosArgs
  dados?: boolean | FindManydadosArgs
  economia?: boolean | FindManyeconomiaArgs
  escalas?: boolean | FindManyescalasArgs
  operadoras?: boolean | FindManyoperadorasArgs
  pedidos?: boolean | FindManypedidosArgs
  tiposocorrencias?: boolean | FindManytiposocorrenciasArgs
}

export type empresasInclude = {
  centrodecustos?: boolean | FindManycentrodecustosArgs
  dados?: boolean | FindManydadosArgs
  economia?: boolean | FindManyeconomiaArgs
  escalas?: boolean | FindManyescalasArgs
  operadoras?: boolean | FindManyoperadorasArgs
  pedidos?: boolean | FindManypedidosArgs
  tiposocorrencias?: boolean | FindManytiposocorrenciasArgs
}

export type empresasGetPayload<
  S extends boolean | null | undefined | empresasArgs,
  U = keyof S
> = S extends true
  ? empresas
  : S extends undefined
  ? never
  : S extends empresasArgs | FindManyempresasArgs
  ? 'include' extends U
    ? empresas  & {
      [P in TrueKeys<S['include']>]:
      P extends 'centrodecustos'
      ? Array<centrodecustosGetPayload<S['include'][P]>> :
      P extends 'dados'
      ? Array<dadosGetPayload<S['include'][P]>> :
      P extends 'economia'
      ? Array<economiaGetPayload<S['include'][P]>> :
      P extends 'escalas'
      ? Array<escalasGetPayload<S['include'][P]>> :
      P extends 'operadoras'
      ? Array<operadorasGetPayload<S['include'][P]>> :
      P extends 'pedidos'
      ? Array<pedidosGetPayload<S['include'][P]>> :
      P extends 'tiposocorrencias'
      ? Array<tiposocorrenciasGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof empresas ? empresas[P]
: 
      P extends 'centrodecustos'
      ? Array<centrodecustosGetPayload<S['select'][P]>> :
      P extends 'dados'
      ? Array<dadosGetPayload<S['select'][P]>> :
      P extends 'economia'
      ? Array<economiaGetPayload<S['select'][P]>> :
      P extends 'escalas'
      ? Array<escalasGetPayload<S['select'][P]>> :
      P extends 'operadoras'
      ? Array<operadorasGetPayload<S['select'][P]>> :
      P extends 'pedidos'
      ? Array<pedidosGetPayload<S['select'][P]>> :
      P extends 'tiposocorrencias'
      ? Array<tiposocorrenciasGetPayload<S['select'][P]>> : never
    }
  : empresas
: empresas


export interface empresasDelegate {
  /**
   * Find zero or one Empresas that matches the filter.
   * @param {FindOneempresasArgs} args - Arguments to find a Empresas
   * @example
   * // Get one Empresas
   * const empresas = await prisma.empresas.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneempresasArgs>(
    args: Subset<T, FindOneempresasArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>
  /**
   * Find the first Empresas that matches the filter.
   * @param {FindFirstempresasArgs} args - Arguments to find a Empresas
   * @example
   * // Get one Empresas
   * const empresas = await prisma.empresas.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstempresasArgs>(
    args?: Subset<T, FindFirstempresasArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>
  /**
   * Find zero or more Empresas that matches the filter.
   * @param {FindManyempresasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Empresas
   * const empresas = await prisma.empresas.findMany()
   * 
   * // Get first 10 Empresas
   * const empresas = await prisma.empresas.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const empresasWithIdOnly = await prisma.empresas.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyempresasArgs>(
    args?: Subset<T, FindManyempresasArgs>
  ): CheckSelect<T, Promise<Array<empresas>>, Promise<Array<empresasGetPayload<T>>>>
  /**
   * Create a Empresas.
   * @param {empresasCreateArgs} args - Arguments to create a Empresas.
   * @example
   * // Create one Empresas
   * const Empresas = await prisma.empresas.create({
   *   data: {
   *     // ... data to create a Empresas
   *   }
   * })
   * 
  **/
  create<T extends empresasCreateArgs>(
    args: Subset<T, empresasCreateArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas>, Prisma__empresasClient<empresasGetPayload<T>>>
  /**
   * Delete a Empresas.
   * @param {empresasDeleteArgs} args - Arguments to delete one Empresas.
   * @example
   * // Delete one Empresas
   * const Empresas = await prisma.empresas.delete({
   *   where: {
   *     // ... filter to delete one Empresas
   *   }
   * })
   * 
  **/
  delete<T extends empresasDeleteArgs>(
    args: Subset<T, empresasDeleteArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas>, Prisma__empresasClient<empresasGetPayload<T>>>
  /**
   * Update one Empresas.
   * @param {empresasUpdateArgs} args - Arguments to update one Empresas.
   * @example
   * // Update one Empresas
   * const empresas = await prisma.empresas.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends empresasUpdateArgs>(
    args: Subset<T, empresasUpdateArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas>, Prisma__empresasClient<empresasGetPayload<T>>>
  /**
   * Delete zero or more Empresas.
   * @param {empresasDeleteManyArgs} args - Arguments to filter Empresas to delete.
   * @example
   * // Delete a few Empresas
   * const { count } = await prisma.empresas.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends empresasDeleteManyArgs>(
    args: Subset<T, empresasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Empresas.
   * @param {empresasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Empresas
   * const empresas = await prisma.empresas.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends empresasUpdateManyArgs>(
    args: Subset<T, empresasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Empresas.
   * @param {empresasUpsertArgs} args - Arguments to update or create a Empresas.
   * @example
   * // Update or create a Empresas
   * const empresas = await prisma.empresas.upsert({
   *   create: {
   *     // ... data to create a Empresas
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Empresas we want to update
   *   }
   * })
  **/
  upsert<T extends empresasUpsertArgs>(
    args: Subset<T, empresasUpsertArgs>
  ): CheckSelect<T, Prisma__empresasClient<empresas>, Prisma__empresasClient<empresasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyempresasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEmpresasArgs>(args: Subset<T, AggregateEmpresasArgs>): Promise<GetEmpresasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for empresas.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__empresasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  centrodecustos<T extends FindManycentrodecustosArgs = {}>(args?: Subset<T, FindManycentrodecustosArgs>): CheckSelect<T, Promise<Array<centrodecustos>>, Promise<Array<centrodecustosGetPayload<T>>>>;

  dados<T extends FindManydadosArgs = {}>(args?: Subset<T, FindManydadosArgs>): CheckSelect<T, Promise<Array<dados>>, Promise<Array<dadosGetPayload<T>>>>;

  economia<T extends FindManyeconomiaArgs = {}>(args?: Subset<T, FindManyeconomiaArgs>): CheckSelect<T, Promise<Array<economia>>, Promise<Array<economiaGetPayload<T>>>>;

  escalas<T extends FindManyescalasArgs = {}>(args?: Subset<T, FindManyescalasArgs>): CheckSelect<T, Promise<Array<escalas>>, Promise<Array<escalasGetPayload<T>>>>;

  operadoras<T extends FindManyoperadorasArgs = {}>(args?: Subset<T, FindManyoperadorasArgs>): CheckSelect<T, Promise<Array<operadoras>>, Promise<Array<operadorasGetPayload<T>>>>;

  pedidos<T extends FindManypedidosArgs = {}>(args?: Subset<T, FindManypedidosArgs>): CheckSelect<T, Promise<Array<pedidos>>, Promise<Array<pedidosGetPayload<T>>>>;

  tiposocorrencias<T extends FindManytiposocorrenciasArgs = {}>(args?: Subset<T, FindManytiposocorrenciasArgs>): CheckSelect<T, Promise<Array<tiposocorrencias>>, Promise<Array<tiposocorrenciasGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * empresas findOne
 */
export type FindOneempresasArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * Filter, which empresas to fetch.
  **/
  where: empresasWhereUniqueInput
}


/**
 * empresas findFirst
 */
export type FindFirstempresasArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * Filter, which empresas to fetch.
  **/
  where?: empresasWhereInput
  orderBy?: XOR<Enumerable<empresasOrderByInput>, empresasOrderByInput>
  cursor?: empresasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EmpresasDistinctFieldEnum>
}


/**
 * empresas findMany
 */
export type FindManyempresasArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * Filter, which empresas to fetch.
  **/
  where?: empresasWhereInput
  /**
   * Determine the order of the empresas to fetch.
  **/
  orderBy?: XOR<Enumerable<empresasOrderByInput>, empresasOrderByInput>
  /**
   * Sets the position for listing empresas.
  **/
  cursor?: empresasWhereUniqueInput
  /**
   * The number of empresas to fetch. If negative number, it will take empresas before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` empresas.
  **/
  skip?: number
  distinct?: Enumerable<EmpresasDistinctFieldEnum>
}


/**
 * empresas create
 */
export type empresasCreateArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * The data needed to create a empresas.
  **/
  data: empresasCreateInput
}


/**
 * empresas update
 */
export type empresasUpdateArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * The data needed to update a empresas.
  **/
  data: empresasUpdateInput
  /**
   * Choose, which empresas to update.
  **/
  where: empresasWhereUniqueInput
}


/**
 * empresas updateMany
 */
export type empresasUpdateManyArgs = {
  data: empresasUpdateManyMutationInput
  where?: empresasWhereInput
}


/**
 * empresas upsert
 */
export type empresasUpsertArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * The filter to search for the empresas to update in case it exists.
  **/
  where: empresasWhereUniqueInput
  /**
   * In case the empresas found by the `where` argument doesn't exist, create a new empresas with this data.
  **/
  create: empresasCreateInput
  /**
   * In case the empresas was found with the provided `where` argument, update it with this data.
  **/
  update: empresasUpdateInput
}


/**
 * empresas delete
 */
export type empresasDeleteArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
  /**
   * Filter which empresas to delete.
  **/
  where: empresasWhereUniqueInput
}


/**
 * empresas deleteMany
 */
export type empresasDeleteManyArgs = {
  where?: empresasWhereInput
}


/**
 * empresas without action
 */
export type empresasArgs = {
  /**
   * Select specific fields to fetch from the empresas
  **/
  select?: XOR<empresasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<empresasInclude, null>
}



/**
 * Model operadoras
 */

export type operadoras = {
  Id: number
  NmOperadora: string | null
  IdEmpresa: number | null
  UF: string | null
}


export type AggregateOperadoras = {
  count: number
  avg: OperadorasAvgAggregateOutputType | null
  sum: OperadorasSumAggregateOutputType | null
  min: OperadorasMinAggregateOutputType | null
  max: OperadorasMaxAggregateOutputType | null
}

export type OperadorasAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type OperadorasSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type OperadorasMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type OperadorasMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}


export type OperadorasAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type OperadorasSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type OperadorasMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type OperadorasMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type AggregateOperadorasArgs = {
  where?: operadorasWhereInput
  orderBy?: XOR<Enumerable<operadorasOrderByInput>, operadorasOrderByInput>
  cursor?: operadorasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OperadorasDistinctFieldEnum>
  count?: true
  avg?: OperadorasAvgAggregateInputType
  sum?: OperadorasSumAggregateInputType
  min?: OperadorasMinAggregateInputType
  max?: OperadorasMaxAggregateInputType
}

export type GetOperadorasAggregateType<T extends AggregateOperadorasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOperadorasAggregateScalarType<T[P]>
}

export type GetOperadorasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OperadorasAvgAggregateOutputType ? OperadorasAvgAggregateOutputType[P] : never
}
    
    

export type operadorasSelect = {
  Id?: boolean
  NmOperadora?: boolean
  IdEmpresa?: boolean
  UF?: boolean
  empresas?: boolean | empresasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  passagens?: boolean | FindManypassagensArgs
}

export type operadorasInclude = {
  empresas?: boolean | empresasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  passagens?: boolean | FindManypassagensArgs
}

export type operadorasGetPayload<
  S extends boolean | null | undefined | operadorasArgs,
  U = keyof S
> = S extends true
  ? operadoras
  : S extends undefined
  ? never
  : S extends operadorasArgs | FindManyoperadorasArgs
  ? 'include' extends U
    ? operadoras  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['include'][P]>> :
      P extends 'passagens'
      ? Array<passagensGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof operadoras ? operadoras[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['select'][P]>> :
      P extends 'passagens'
      ? Array<passagensGetPayload<S['select'][P]>> : never
    }
  : operadoras
: operadoras


export interface operadorasDelegate {
  /**
   * Find zero or one Operadoras that matches the filter.
   * @param {FindOneoperadorasArgs} args - Arguments to find a Operadoras
   * @example
   * // Get one Operadoras
   * const operadoras = await prisma.operadoras.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneoperadorasArgs>(
    args: Subset<T, FindOneoperadorasArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras | null>, Prisma__operadorasClient<operadorasGetPayload<T> | null>>
  /**
   * Find the first Operadoras that matches the filter.
   * @param {FindFirstoperadorasArgs} args - Arguments to find a Operadoras
   * @example
   * // Get one Operadoras
   * const operadoras = await prisma.operadoras.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstoperadorasArgs>(
    args?: Subset<T, FindFirstoperadorasArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras | null>, Prisma__operadorasClient<operadorasGetPayload<T> | null>>
  /**
   * Find zero or more Operadoras that matches the filter.
   * @param {FindManyoperadorasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Operadoras
   * const operadoras = await prisma.operadoras.findMany()
   * 
   * // Get first 10 Operadoras
   * const operadoras = await prisma.operadoras.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const operadorasWithIdOnly = await prisma.operadoras.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyoperadorasArgs>(
    args?: Subset<T, FindManyoperadorasArgs>
  ): CheckSelect<T, Promise<Array<operadoras>>, Promise<Array<operadorasGetPayload<T>>>>
  /**
   * Create a Operadoras.
   * @param {operadorasCreateArgs} args - Arguments to create a Operadoras.
   * @example
   * // Create one Operadoras
   * const Operadoras = await prisma.operadoras.create({
   *   data: {
   *     // ... data to create a Operadoras
   *   }
   * })
   * 
  **/
  create<T extends operadorasCreateArgs>(
    args: Subset<T, operadorasCreateArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras>, Prisma__operadorasClient<operadorasGetPayload<T>>>
  /**
   * Delete a Operadoras.
   * @param {operadorasDeleteArgs} args - Arguments to delete one Operadoras.
   * @example
   * // Delete one Operadoras
   * const Operadoras = await prisma.operadoras.delete({
   *   where: {
   *     // ... filter to delete one Operadoras
   *   }
   * })
   * 
  **/
  delete<T extends operadorasDeleteArgs>(
    args: Subset<T, operadorasDeleteArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras>, Prisma__operadorasClient<operadorasGetPayload<T>>>
  /**
   * Update one Operadoras.
   * @param {operadorasUpdateArgs} args - Arguments to update one Operadoras.
   * @example
   * // Update one Operadoras
   * const operadoras = await prisma.operadoras.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends operadorasUpdateArgs>(
    args: Subset<T, operadorasUpdateArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras>, Prisma__operadorasClient<operadorasGetPayload<T>>>
  /**
   * Delete zero or more Operadoras.
   * @param {operadorasDeleteManyArgs} args - Arguments to filter Operadoras to delete.
   * @example
   * // Delete a few Operadoras
   * const { count } = await prisma.operadoras.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends operadorasDeleteManyArgs>(
    args: Subset<T, operadorasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Operadoras.
   * @param {operadorasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Operadoras
   * const operadoras = await prisma.operadoras.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends operadorasUpdateManyArgs>(
    args: Subset<T, operadorasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Operadoras.
   * @param {operadorasUpsertArgs} args - Arguments to update or create a Operadoras.
   * @example
   * // Update or create a Operadoras
   * const operadoras = await prisma.operadoras.upsert({
   *   create: {
   *     // ... data to create a Operadoras
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Operadoras we want to update
   *   }
   * })
  **/
  upsert<T extends operadorasUpsertArgs>(
    args: Subset<T, operadorasUpsertArgs>
  ): CheckSelect<T, Prisma__operadorasClient<operadoras>, Prisma__operadorasClient<operadorasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyoperadorasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOperadorasArgs>(args: Subset<T, AggregateOperadorasArgs>): Promise<GetOperadorasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for operadoras.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__operadorasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  detalhepedidos_old<T extends FindManydetalhepedidos_oldArgs = {}>(args?: Subset<T, FindManydetalhepedidos_oldArgs>): CheckSelect<T, Promise<Array<detalhepedidos_old>>, Promise<Array<detalhepedidos_oldGetPayload<T>>>>;

  passagens<T extends FindManypassagensArgs = {}>(args?: Subset<T, FindManypassagensArgs>): CheckSelect<T, Promise<Array<passagens>>, Promise<Array<passagensGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * operadoras findOne
 */
export type FindOneoperadorasArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * Filter, which operadoras to fetch.
  **/
  where: operadorasWhereUniqueInput
}


/**
 * operadoras findFirst
 */
export type FindFirstoperadorasArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * Filter, which operadoras to fetch.
  **/
  where?: operadorasWhereInput
  orderBy?: XOR<Enumerable<operadorasOrderByInput>, operadorasOrderByInput>
  cursor?: operadorasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OperadorasDistinctFieldEnum>
}


/**
 * operadoras findMany
 */
export type FindManyoperadorasArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * Filter, which operadoras to fetch.
  **/
  where?: operadorasWhereInput
  /**
   * Determine the order of the operadoras to fetch.
  **/
  orderBy?: XOR<Enumerable<operadorasOrderByInput>, operadorasOrderByInput>
  /**
   * Sets the position for listing operadoras.
  **/
  cursor?: operadorasWhereUniqueInput
  /**
   * The number of operadoras to fetch. If negative number, it will take operadoras before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` operadoras.
  **/
  skip?: number
  distinct?: Enumerable<OperadorasDistinctFieldEnum>
}


/**
 * operadoras create
 */
export type operadorasCreateArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * The data needed to create a operadoras.
  **/
  data: operadorasCreateInput
}


/**
 * operadoras update
 */
export type operadorasUpdateArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * The data needed to update a operadoras.
  **/
  data: operadorasUpdateInput
  /**
   * Choose, which operadoras to update.
  **/
  where: operadorasWhereUniqueInput
}


/**
 * operadoras updateMany
 */
export type operadorasUpdateManyArgs = {
  data: operadorasUpdateManyMutationInput
  where?: operadorasWhereInput
}


/**
 * operadoras upsert
 */
export type operadorasUpsertArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * The filter to search for the operadoras to update in case it exists.
  **/
  where: operadorasWhereUniqueInput
  /**
   * In case the operadoras found by the `where` argument doesn't exist, create a new operadoras with this data.
  **/
  create: operadorasCreateInput
  /**
   * In case the operadoras was found with the provided `where` argument, update it with this data.
  **/
  update: operadorasUpdateInput
}


/**
 * operadoras delete
 */
export type operadorasDeleteArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
  /**
   * Filter which operadoras to delete.
  **/
  where: operadorasWhereUniqueInput
}


/**
 * operadoras deleteMany
 */
export type operadorasDeleteManyArgs = {
  where?: operadorasWhereInput
}


/**
 * operadoras without action
 */
export type operadorasArgs = {
  /**
   * Select specific fields to fetch from the operadoras
  **/
  select?: XOR<operadorasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<operadorasInclude, null>
}



/**
 * Model usuarios
 */

export type usuarios = {
  Id: number
  CPF: string | null
  Nome: string | null
  Senha: string | null
  Email: string | null
  Lvl: string | null
}


export type AggregateUsuarios = {
  count: number
  avg: UsuariosAvgAggregateOutputType | null
  sum: UsuariosSumAggregateOutputType | null
  min: UsuariosMinAggregateOutputType | null
  max: UsuariosMaxAggregateOutputType | null
}

export type UsuariosAvgAggregateOutputType = {
  Id: number
}

export type UsuariosSumAggregateOutputType = {
  Id: number
}

export type UsuariosMinAggregateOutputType = {
  Id: number
}

export type UsuariosMaxAggregateOutputType = {
  Id: number
}


export type UsuariosAvgAggregateInputType = {
  Id?: true
}

export type UsuariosSumAggregateInputType = {
  Id?: true
}

export type UsuariosMinAggregateInputType = {
  Id?: true
}

export type UsuariosMaxAggregateInputType = {
  Id?: true
}

export type AggregateUsuariosArgs = {
  where?: usuariosWhereInput
  orderBy?: XOR<Enumerable<usuariosOrderByInput>, usuariosOrderByInput>
  cursor?: usuariosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UsuariosDistinctFieldEnum>
  count?: true
  avg?: UsuariosAvgAggregateInputType
  sum?: UsuariosSumAggregateInputType
  min?: UsuariosMinAggregateInputType
  max?: UsuariosMaxAggregateInputType
}

export type GetUsuariosAggregateType<T extends AggregateUsuariosArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetUsuariosAggregateScalarType<T[P]>
}

export type GetUsuariosAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof UsuariosAvgAggregateOutputType ? UsuariosAvgAggregateOutputType[P] : never
}
    
    

export type usuariosSelect = {
  Id?: boolean
  CPF?: boolean
  Nome?: boolean
  Senha?: boolean
  Email?: boolean
  Lvl?: boolean
}

export type usuariosGetPayload<
  S extends boolean | null | undefined | usuariosArgs,
  U = keyof S
> = S extends true
  ? usuarios
  : S extends undefined
  ? never
  : S extends usuariosArgs | FindManyusuariosArgs
  ? 'include' extends U
    ? usuarios 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof usuarios ? usuarios[P]
: 
 never
    }
  : usuarios
: usuarios


export interface usuariosDelegate {
  /**
   * Find zero or one Usuarios that matches the filter.
   * @param {FindOneusuariosArgs} args - Arguments to find a Usuarios
   * @example
   * // Get one Usuarios
   * const usuarios = await prisma.usuarios.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneusuariosArgs>(
    args: Subset<T, FindOneusuariosArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios | null>, Prisma__usuariosClient<usuariosGetPayload<T> | null>>
  /**
   * Find the first Usuarios that matches the filter.
   * @param {FindFirstusuariosArgs} args - Arguments to find a Usuarios
   * @example
   * // Get one Usuarios
   * const usuarios = await prisma.usuarios.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstusuariosArgs>(
    args?: Subset<T, FindFirstusuariosArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios | null>, Prisma__usuariosClient<usuariosGetPayload<T> | null>>
  /**
   * Find zero or more Usuarios that matches the filter.
   * @param {FindManyusuariosArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Usuarios
   * const usuarios = await prisma.usuarios.findMany()
   * 
   * // Get first 10 Usuarios
   * const usuarios = await prisma.usuarios.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyusuariosArgs>(
    args?: Subset<T, FindManyusuariosArgs>
  ): CheckSelect<T, Promise<Array<usuarios>>, Promise<Array<usuariosGetPayload<T>>>>
  /**
   * Create a Usuarios.
   * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
   * @example
   * // Create one Usuarios
   * const Usuarios = await prisma.usuarios.create({
   *   data: {
   *     // ... data to create a Usuarios
   *   }
   * })
   * 
  **/
  create<T extends usuariosCreateArgs>(
    args: Subset<T, usuariosCreateArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios>, Prisma__usuariosClient<usuariosGetPayload<T>>>
  /**
   * Delete a Usuarios.
   * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
   * @example
   * // Delete one Usuarios
   * const Usuarios = await prisma.usuarios.delete({
   *   where: {
   *     // ... filter to delete one Usuarios
   *   }
   * })
   * 
  **/
  delete<T extends usuariosDeleteArgs>(
    args: Subset<T, usuariosDeleteArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios>, Prisma__usuariosClient<usuariosGetPayload<T>>>
  /**
   * Update one Usuarios.
   * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
   * @example
   * // Update one Usuarios
   * const usuarios = await prisma.usuarios.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends usuariosUpdateArgs>(
    args: Subset<T, usuariosUpdateArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios>, Prisma__usuariosClient<usuariosGetPayload<T>>>
  /**
   * Delete zero or more Usuarios.
   * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
   * @example
   * // Delete a few Usuarios
   * const { count } = await prisma.usuarios.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends usuariosDeleteManyArgs>(
    args: Subset<T, usuariosDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Usuarios.
   * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Usuarios
   * const usuarios = await prisma.usuarios.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends usuariosUpdateManyArgs>(
    args: Subset<T, usuariosUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Usuarios.
   * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
   * @example
   * // Update or create a Usuarios
   * const usuarios = await prisma.usuarios.upsert({
   *   create: {
   *     // ... data to create a Usuarios
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Usuarios we want to update
   *   }
   * })
  **/
  upsert<T extends usuariosUpsertArgs>(
    args: Subset<T, usuariosUpsertArgs>
  ): CheckSelect<T, Prisma__usuariosClient<usuarios>, Prisma__usuariosClient<usuariosGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyusuariosArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateUsuariosArgs>(args: Subset<T, AggregateUsuariosArgs>): Promise<GetUsuariosAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for usuarios.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__usuariosClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * usuarios findOne
 */
export type FindOneusuariosArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * Filter, which usuarios to fetch.
  **/
  where: usuariosWhereUniqueInput
}


/**
 * usuarios findFirst
 */
export type FindFirstusuariosArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * Filter, which usuarios to fetch.
  **/
  where?: usuariosWhereInput
  orderBy?: XOR<Enumerable<usuariosOrderByInput>, usuariosOrderByInput>
  cursor?: usuariosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UsuariosDistinctFieldEnum>
}


/**
 * usuarios findMany
 */
export type FindManyusuariosArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * Filter, which usuarios to fetch.
  **/
  where?: usuariosWhereInput
  /**
   * Determine the order of the usuarios to fetch.
  **/
  orderBy?: XOR<Enumerable<usuariosOrderByInput>, usuariosOrderByInput>
  /**
   * Sets the position for listing usuarios.
  **/
  cursor?: usuariosWhereUniqueInput
  /**
   * The number of usuarios to fetch. If negative number, it will take usuarios before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` usuarios.
  **/
  skip?: number
  distinct?: Enumerable<UsuariosDistinctFieldEnum>
}


/**
 * usuarios create
 */
export type usuariosCreateArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * The data needed to create a usuarios.
  **/
  data: usuariosCreateInput
}


/**
 * usuarios update
 */
export type usuariosUpdateArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * The data needed to update a usuarios.
  **/
  data: usuariosUpdateInput
  /**
   * Choose, which usuarios to update.
  **/
  where: usuariosWhereUniqueInput
}


/**
 * usuarios updateMany
 */
export type usuariosUpdateManyArgs = {
  data: usuariosUpdateManyMutationInput
  where?: usuariosWhereInput
}


/**
 * usuarios upsert
 */
export type usuariosUpsertArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * The filter to search for the usuarios to update in case it exists.
  **/
  where: usuariosWhereUniqueInput
  /**
   * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
  **/
  create: usuariosCreateInput
  /**
   * In case the usuarios was found with the provided `where` argument, update it with this data.
  **/
  update: usuariosUpdateInput
}


/**
 * usuarios delete
 */
export type usuariosDeleteArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
  /**
   * Filter which usuarios to delete.
  **/
  where: usuariosWhereUniqueInput
}


/**
 * usuarios deleteMany
 */
export type usuariosDeleteManyArgs = {
  where?: usuariosWhereInput
}


/**
 * usuarios without action
 */
export type usuariosArgs = {
  /**
   * Select specific fields to fetch from the usuarios
  **/
  select?: XOR<usuariosSelect, null>
}



/**
 * Model dados
 */

export type dados = {
  Id: number
  NmColaborador: string | null
  CPF: string | null
  IdEmpresa: number | null
  DtNascimento: string | null
  IdCentroDeCusto: number | null
  Matricula: string | null
  IdEscala: number | null
  Situacao: string | null
}


export type AggregateDados = {
  count: number
  avg: DadosAvgAggregateOutputType | null
  sum: DadosSumAggregateOutputType | null
  min: DadosMinAggregateOutputType | null
  max: DadosMaxAggregateOutputType | null
}

export type DadosAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  IdCentroDeCusto: number | null
  IdEscala: number | null
}

export type DadosSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  IdCentroDeCusto: number | null
  IdEscala: number | null
}

export type DadosMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  IdCentroDeCusto: number | null
  IdEscala: number | null
}

export type DadosMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  IdCentroDeCusto: number | null
  IdEscala: number | null
}


export type DadosAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  IdCentroDeCusto?: true
  IdEscala?: true
}

export type DadosSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  IdCentroDeCusto?: true
  IdEscala?: true
}

export type DadosMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  IdCentroDeCusto?: true
  IdEscala?: true
}

export type DadosMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  IdCentroDeCusto?: true
  IdEscala?: true
}

export type AggregateDadosArgs = {
  where?: dadosWhereInput
  orderBy?: XOR<Enumerable<dadosOrderByInput>, dadosOrderByInput>
  cursor?: dadosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DadosDistinctFieldEnum>
  count?: true
  avg?: DadosAvgAggregateInputType
  sum?: DadosSumAggregateInputType
  min?: DadosMinAggregateInputType
  max?: DadosMaxAggregateInputType
}

export type GetDadosAggregateType<T extends AggregateDadosArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDadosAggregateScalarType<T[P]>
}

export type GetDadosAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DadosAvgAggregateOutputType ? DadosAvgAggregateOutputType[P] : never
}
    
    

export type dadosSelect = {
  Id?: boolean
  NmColaborador?: boolean
  CPF?: boolean
  IdEmpresa?: boolean
  DtNascimento?: boolean
  IdCentroDeCusto?: boolean
  Matricula?: boolean
  IdEscala?: boolean
  Situacao?: boolean
  centrodecustos?: boolean | centrodecustosArgs
  empresas?: boolean | empresasArgs
  escalas?: boolean | escalasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  meurh?: boolean | FindManymeurhArgs
  meurhrespostas?: boolean | FindManymeurhrespostasArgs
  solicitacoes?: boolean | FindManysolicitacoesArgs
  suporte?: boolean | FindManysuporteArgs
}

export type dadosInclude = {
  centrodecustos?: boolean | centrodecustosArgs
  empresas?: boolean | empresasArgs
  escalas?: boolean | escalasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  meurh?: boolean | FindManymeurhArgs
  meurhrespostas?: boolean | FindManymeurhrespostasArgs
  solicitacoes?: boolean | FindManysolicitacoesArgs
  suporte?: boolean | FindManysuporteArgs
}

export type dadosGetPayload<
  S extends boolean | null | undefined | dadosArgs,
  U = keyof S
> = S extends true
  ? dados
  : S extends undefined
  ? never
  : S extends dadosArgs | FindManydadosArgs
  ? 'include' extends U
    ? dados  & {
      [P in TrueKeys<S['include']>]:
      P extends 'centrodecustos'
      ? centrodecustosGetPayload<S['include'][P]> | null :
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'escalas'
      ? escalasGetPayload<S['include'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['include'][P]>> :
      P extends 'meurh'
      ? Array<meurhGetPayload<S['include'][P]>> :
      P extends 'meurhrespostas'
      ? Array<meurhrespostasGetPayload<S['include'][P]>> :
      P extends 'solicitacoes'
      ? Array<solicitacoesGetPayload<S['include'][P]>> :
      P extends 'suporte'
      ? Array<suporteGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof dados ? dados[P]
: 
      P extends 'centrodecustos'
      ? centrodecustosGetPayload<S['select'][P]> | null :
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'escalas'
      ? escalasGetPayload<S['select'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['select'][P]>> :
      P extends 'meurh'
      ? Array<meurhGetPayload<S['select'][P]>> :
      P extends 'meurhrespostas'
      ? Array<meurhrespostasGetPayload<S['select'][P]>> :
      P extends 'solicitacoes'
      ? Array<solicitacoesGetPayload<S['select'][P]>> :
      P extends 'suporte'
      ? Array<suporteGetPayload<S['select'][P]>> : never
    }
  : dados
: dados


export interface dadosDelegate {
  /**
   * Find zero or one Dados that matches the filter.
   * @param {FindOnedadosArgs} args - Arguments to find a Dados
   * @example
   * // Get one Dados
   * const dados = await prisma.dados.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedadosArgs>(
    args: Subset<T, FindOnedadosArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>
  /**
   * Find the first Dados that matches the filter.
   * @param {FindFirstdadosArgs} args - Arguments to find a Dados
   * @example
   * // Get one Dados
   * const dados = await prisma.dados.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstdadosArgs>(
    args?: Subset<T, FindFirstdadosArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>
  /**
   * Find zero or more Dados that matches the filter.
   * @param {FindManydadosArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Dados
   * const dados = await prisma.dados.findMany()
   * 
   * // Get first 10 Dados
   * const dados = await prisma.dados.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const dadosWithIdOnly = await prisma.dados.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManydadosArgs>(
    args?: Subset<T, FindManydadosArgs>
  ): CheckSelect<T, Promise<Array<dados>>, Promise<Array<dadosGetPayload<T>>>>
  /**
   * Create a Dados.
   * @param {dadosCreateArgs} args - Arguments to create a Dados.
   * @example
   * // Create one Dados
   * const Dados = await prisma.dados.create({
   *   data: {
   *     // ... data to create a Dados
   *   }
   * })
   * 
  **/
  create<T extends dadosCreateArgs>(
    args: Subset<T, dadosCreateArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados>, Prisma__dadosClient<dadosGetPayload<T>>>
  /**
   * Delete a Dados.
   * @param {dadosDeleteArgs} args - Arguments to delete one Dados.
   * @example
   * // Delete one Dados
   * const Dados = await prisma.dados.delete({
   *   where: {
   *     // ... filter to delete one Dados
   *   }
   * })
   * 
  **/
  delete<T extends dadosDeleteArgs>(
    args: Subset<T, dadosDeleteArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados>, Prisma__dadosClient<dadosGetPayload<T>>>
  /**
   * Update one Dados.
   * @param {dadosUpdateArgs} args - Arguments to update one Dados.
   * @example
   * // Update one Dados
   * const dados = await prisma.dados.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends dadosUpdateArgs>(
    args: Subset<T, dadosUpdateArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados>, Prisma__dadosClient<dadosGetPayload<T>>>
  /**
   * Delete zero or more Dados.
   * @param {dadosDeleteManyArgs} args - Arguments to filter Dados to delete.
   * @example
   * // Delete a few Dados
   * const { count } = await prisma.dados.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends dadosDeleteManyArgs>(
    args: Subset<T, dadosDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Dados.
   * @param {dadosUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Dados
   * const dados = await prisma.dados.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends dadosUpdateManyArgs>(
    args: Subset<T, dadosUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Dados.
   * @param {dadosUpsertArgs} args - Arguments to update or create a Dados.
   * @example
   * // Update or create a Dados
   * const dados = await prisma.dados.upsert({
   *   create: {
   *     // ... data to create a Dados
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Dados we want to update
   *   }
   * })
  **/
  upsert<T extends dadosUpsertArgs>(
    args: Subset<T, dadosUpsertArgs>
  ): CheckSelect<T, Prisma__dadosClient<dados>, Prisma__dadosClient<dadosGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydadosArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDadosArgs>(args: Subset<T, AggregateDadosArgs>): Promise<GetDadosAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for dados.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__dadosClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  centrodecustos<T extends centrodecustosArgs = {}>(args?: Subset<T, centrodecustosArgs>): CheckSelect<T, Prisma__centrodecustosClient<centrodecustos | null>, Prisma__centrodecustosClient<centrodecustosGetPayload<T> | null>>;

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  escalas<T extends escalasArgs = {}>(args?: Subset<T, escalasArgs>): CheckSelect<T, Prisma__escalasClient<escalas | null>, Prisma__escalasClient<escalasGetPayload<T> | null>>;

  detalhepedidos_old<T extends FindManydetalhepedidos_oldArgs = {}>(args?: Subset<T, FindManydetalhepedidos_oldArgs>): CheckSelect<T, Promise<Array<detalhepedidos_old>>, Promise<Array<detalhepedidos_oldGetPayload<T>>>>;

  meurh<T extends FindManymeurhArgs = {}>(args?: Subset<T, FindManymeurhArgs>): CheckSelect<T, Promise<Array<meurh>>, Promise<Array<meurhGetPayload<T>>>>;

  meurhrespostas<T extends FindManymeurhrespostasArgs = {}>(args?: Subset<T, FindManymeurhrespostasArgs>): CheckSelect<T, Promise<Array<meurhrespostas>>, Promise<Array<meurhrespostasGetPayload<T>>>>;

  solicitacoes<T extends FindManysolicitacoesArgs = {}>(args?: Subset<T, FindManysolicitacoesArgs>): CheckSelect<T, Promise<Array<solicitacoes>>, Promise<Array<solicitacoesGetPayload<T>>>>;

  suporte<T extends FindManysuporteArgs = {}>(args?: Subset<T, FindManysuporteArgs>): CheckSelect<T, Promise<Array<suporte>>, Promise<Array<suporteGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * dados findOne
 */
export type FindOnedadosArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * Filter, which dados to fetch.
  **/
  where: dadosWhereUniqueInput
}


/**
 * dados findFirst
 */
export type FindFirstdadosArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * Filter, which dados to fetch.
  **/
  where?: dadosWhereInput
  orderBy?: XOR<Enumerable<dadosOrderByInput>, dadosOrderByInput>
  cursor?: dadosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DadosDistinctFieldEnum>
}


/**
 * dados findMany
 */
export type FindManydadosArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * Filter, which dados to fetch.
  **/
  where?: dadosWhereInput
  /**
   * Determine the order of the dados to fetch.
  **/
  orderBy?: XOR<Enumerable<dadosOrderByInput>, dadosOrderByInput>
  /**
   * Sets the position for listing dados.
  **/
  cursor?: dadosWhereUniqueInput
  /**
   * The number of dados to fetch. If negative number, it will take dados before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` dados.
  **/
  skip?: number
  distinct?: Enumerable<DadosDistinctFieldEnum>
}


/**
 * dados create
 */
export type dadosCreateArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * The data needed to create a dados.
  **/
  data: dadosCreateInput
}


/**
 * dados update
 */
export type dadosUpdateArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * The data needed to update a dados.
  **/
  data: dadosUpdateInput
  /**
   * Choose, which dados to update.
  **/
  where: dadosWhereUniqueInput
}


/**
 * dados updateMany
 */
export type dadosUpdateManyArgs = {
  data: dadosUpdateManyMutationInput
  where?: dadosWhereInput
}


/**
 * dados upsert
 */
export type dadosUpsertArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * The filter to search for the dados to update in case it exists.
  **/
  where: dadosWhereUniqueInput
  /**
   * In case the dados found by the `where` argument doesn't exist, create a new dados with this data.
  **/
  create: dadosCreateInput
  /**
   * In case the dados was found with the provided `where` argument, update it with this data.
  **/
  update: dadosUpdateInput
}


/**
 * dados delete
 */
export type dadosDeleteArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
  /**
   * Filter which dados to delete.
  **/
  where: dadosWhereUniqueInput
}


/**
 * dados deleteMany
 */
export type dadosDeleteManyArgs = {
  where?: dadosWhereInput
}


/**
 * dados without action
 */
export type dadosArgs = {
  /**
   * Select specific fields to fetch from the dados
  **/
  select?: XOR<dadosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<dadosInclude, null>
}



/**
 * Model passagens
 */

export type passagens = {
  Id: number
  CPF: string | null
  NrCartao: string | null
  Valor: number | null
  IdOperadora: number | null
  QtdDia: number | null
  Situacao: string | null
}


export type AggregatePassagens = {
  count: number
  avg: PassagensAvgAggregateOutputType | null
  sum: PassagensSumAggregateOutputType | null
  min: PassagensMinAggregateOutputType | null
  max: PassagensMaxAggregateOutputType | null
}

export type PassagensAvgAggregateOutputType = {
  Id: number
  Valor: number | null
  IdOperadora: number | null
  QtdDia: number | null
}

export type PassagensSumAggregateOutputType = {
  Id: number
  Valor: number | null
  IdOperadora: number | null
  QtdDia: number | null
}

export type PassagensMinAggregateOutputType = {
  Id: number
  Valor: number | null
  IdOperadora: number | null
  QtdDia: number | null
}

export type PassagensMaxAggregateOutputType = {
  Id: number
  Valor: number | null
  IdOperadora: number | null
  QtdDia: number | null
}


export type PassagensAvgAggregateInputType = {
  Id?: true
  Valor?: true
  IdOperadora?: true
  QtdDia?: true
}

export type PassagensSumAggregateInputType = {
  Id?: true
  Valor?: true
  IdOperadora?: true
  QtdDia?: true
}

export type PassagensMinAggregateInputType = {
  Id?: true
  Valor?: true
  IdOperadora?: true
  QtdDia?: true
}

export type PassagensMaxAggregateInputType = {
  Id?: true
  Valor?: true
  IdOperadora?: true
  QtdDia?: true
}

export type AggregatePassagensArgs = {
  where?: passagensWhereInput
  orderBy?: XOR<Enumerable<passagensOrderByInput>, passagensOrderByInput>
  cursor?: passagensWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PassagensDistinctFieldEnum>
  count?: true
  avg?: PassagensAvgAggregateInputType
  sum?: PassagensSumAggregateInputType
  min?: PassagensMinAggregateInputType
  max?: PassagensMaxAggregateInputType
}

export type GetPassagensAggregateType<T extends AggregatePassagensArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetPassagensAggregateScalarType<T[P]>
}

export type GetPassagensAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof PassagensAvgAggregateOutputType ? PassagensAvgAggregateOutputType[P] : never
}
    
    

export type passagensSelect = {
  Id?: boolean
  CPF?: boolean
  NrCartao?: boolean
  Valor?: boolean
  IdOperadora?: boolean
  QtdDia?: boolean
  Situacao?: boolean
  operadoras?: boolean | operadorasArgs
}

export type passagensInclude = {
  operadoras?: boolean | operadorasArgs
}

export type passagensGetPayload<
  S extends boolean | null | undefined | passagensArgs,
  U = keyof S
> = S extends true
  ? passagens
  : S extends undefined
  ? never
  : S extends passagensArgs | FindManypassagensArgs
  ? 'include' extends U
    ? passagens  & {
      [P in TrueKeys<S['include']>]:
      P extends 'operadoras'
      ? operadorasGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof passagens ? passagens[P]
: 
      P extends 'operadoras'
      ? operadorasGetPayload<S['select'][P]> | null : never
    }
  : passagens
: passagens


export interface passagensDelegate {
  /**
   * Find zero or one Passagens that matches the filter.
   * @param {FindOnepassagensArgs} args - Arguments to find a Passagens
   * @example
   * // Get one Passagens
   * const passagens = await prisma.passagens.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnepassagensArgs>(
    args: Subset<T, FindOnepassagensArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens | null>, Prisma__passagensClient<passagensGetPayload<T> | null>>
  /**
   * Find the first Passagens that matches the filter.
   * @param {FindFirstpassagensArgs} args - Arguments to find a Passagens
   * @example
   * // Get one Passagens
   * const passagens = await prisma.passagens.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstpassagensArgs>(
    args?: Subset<T, FindFirstpassagensArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens | null>, Prisma__passagensClient<passagensGetPayload<T> | null>>
  /**
   * Find zero or more Passagens that matches the filter.
   * @param {FindManypassagensArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Passagens
   * const passagens = await prisma.passagens.findMany()
   * 
   * // Get first 10 Passagens
   * const passagens = await prisma.passagens.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const passagensWithIdOnly = await prisma.passagens.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManypassagensArgs>(
    args?: Subset<T, FindManypassagensArgs>
  ): CheckSelect<T, Promise<Array<passagens>>, Promise<Array<passagensGetPayload<T>>>>
  /**
   * Create a Passagens.
   * @param {passagensCreateArgs} args - Arguments to create a Passagens.
   * @example
   * // Create one Passagens
   * const Passagens = await prisma.passagens.create({
   *   data: {
   *     // ... data to create a Passagens
   *   }
   * })
   * 
  **/
  create<T extends passagensCreateArgs>(
    args: Subset<T, passagensCreateArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens>, Prisma__passagensClient<passagensGetPayload<T>>>
  /**
   * Delete a Passagens.
   * @param {passagensDeleteArgs} args - Arguments to delete one Passagens.
   * @example
   * // Delete one Passagens
   * const Passagens = await prisma.passagens.delete({
   *   where: {
   *     // ... filter to delete one Passagens
   *   }
   * })
   * 
  **/
  delete<T extends passagensDeleteArgs>(
    args: Subset<T, passagensDeleteArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens>, Prisma__passagensClient<passagensGetPayload<T>>>
  /**
   * Update one Passagens.
   * @param {passagensUpdateArgs} args - Arguments to update one Passagens.
   * @example
   * // Update one Passagens
   * const passagens = await prisma.passagens.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends passagensUpdateArgs>(
    args: Subset<T, passagensUpdateArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens>, Prisma__passagensClient<passagensGetPayload<T>>>
  /**
   * Delete zero or more Passagens.
   * @param {passagensDeleteManyArgs} args - Arguments to filter Passagens to delete.
   * @example
   * // Delete a few Passagens
   * const { count } = await prisma.passagens.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends passagensDeleteManyArgs>(
    args: Subset<T, passagensDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Passagens.
   * @param {passagensUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Passagens
   * const passagens = await prisma.passagens.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends passagensUpdateManyArgs>(
    args: Subset<T, passagensUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Passagens.
   * @param {passagensUpsertArgs} args - Arguments to update or create a Passagens.
   * @example
   * // Update or create a Passagens
   * const passagens = await prisma.passagens.upsert({
   *   create: {
   *     // ... data to create a Passagens
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Passagens we want to update
   *   }
   * })
  **/
  upsert<T extends passagensUpsertArgs>(
    args: Subset<T, passagensUpsertArgs>
  ): CheckSelect<T, Prisma__passagensClient<passagens>, Prisma__passagensClient<passagensGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManypassagensArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregatePassagensArgs>(args: Subset<T, AggregatePassagensArgs>): Promise<GetPassagensAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for passagens.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__passagensClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  operadoras<T extends operadorasArgs = {}>(args?: Subset<T, operadorasArgs>): CheckSelect<T, Prisma__operadorasClient<operadoras | null>, Prisma__operadorasClient<operadorasGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * passagens findOne
 */
export type FindOnepassagensArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * Filter, which passagens to fetch.
  **/
  where: passagensWhereUniqueInput
}


/**
 * passagens findFirst
 */
export type FindFirstpassagensArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * Filter, which passagens to fetch.
  **/
  where?: passagensWhereInput
  orderBy?: XOR<Enumerable<passagensOrderByInput>, passagensOrderByInput>
  cursor?: passagensWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PassagensDistinctFieldEnum>
}


/**
 * passagens findMany
 */
export type FindManypassagensArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * Filter, which passagens to fetch.
  **/
  where?: passagensWhereInput
  /**
   * Determine the order of the passagens to fetch.
  **/
  orderBy?: XOR<Enumerable<passagensOrderByInput>, passagensOrderByInput>
  /**
   * Sets the position for listing passagens.
  **/
  cursor?: passagensWhereUniqueInput
  /**
   * The number of passagens to fetch. If negative number, it will take passagens before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` passagens.
  **/
  skip?: number
  distinct?: Enumerable<PassagensDistinctFieldEnum>
}


/**
 * passagens create
 */
export type passagensCreateArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * The data needed to create a passagens.
  **/
  data: passagensCreateInput
}


/**
 * passagens update
 */
export type passagensUpdateArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * The data needed to update a passagens.
  **/
  data: passagensUpdateInput
  /**
   * Choose, which passagens to update.
  **/
  where: passagensWhereUniqueInput
}


/**
 * passagens updateMany
 */
export type passagensUpdateManyArgs = {
  data: passagensUpdateManyMutationInput
  where?: passagensWhereInput
}


/**
 * passagens upsert
 */
export type passagensUpsertArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * The filter to search for the passagens to update in case it exists.
  **/
  where: passagensWhereUniqueInput
  /**
   * In case the passagens found by the `where` argument doesn't exist, create a new passagens with this data.
  **/
  create: passagensCreateInput
  /**
   * In case the passagens was found with the provided `where` argument, update it with this data.
  **/
  update: passagensUpdateInput
}


/**
 * passagens delete
 */
export type passagensDeleteArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
  /**
   * Filter which passagens to delete.
  **/
  where: passagensWhereUniqueInput
}


/**
 * passagens deleteMany
 */
export type passagensDeleteManyArgs = {
  where?: passagensWhereInput
}


/**
 * passagens without action
 */
export type passagensArgs = {
  /**
   * Select specific fields to fetch from the passagens
  **/
  select?: XOR<passagensSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<passagensInclude, null>
}



/**
 * Model escalas
 */

export type escalas = {
  Id: number
  IdEmpresa: number | null
  NmEscala: string | null
  Folgas: string | null
}


export type AggregateEscalas = {
  count: number
  avg: EscalasAvgAggregateOutputType | null
  sum: EscalasSumAggregateOutputType | null
  min: EscalasMinAggregateOutputType | null
  max: EscalasMaxAggregateOutputType | null
}

export type EscalasAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type EscalasSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type EscalasMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type EscalasMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}


export type EscalasAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type EscalasSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type EscalasMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type EscalasMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type AggregateEscalasArgs = {
  where?: escalasWhereInput
  orderBy?: XOR<Enumerable<escalasOrderByInput>, escalasOrderByInput>
  cursor?: escalasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EscalasDistinctFieldEnum>
  count?: true
  avg?: EscalasAvgAggregateInputType
  sum?: EscalasSumAggregateInputType
  min?: EscalasMinAggregateInputType
  max?: EscalasMaxAggregateInputType
}

export type GetEscalasAggregateType<T extends AggregateEscalasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEscalasAggregateScalarType<T[P]>
}

export type GetEscalasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EscalasAvgAggregateOutputType ? EscalasAvgAggregateOutputType[P] : never
}
    
    

export type escalasSelect = {
  Id?: boolean
  IdEmpresa?: boolean
  NmEscala?: boolean
  Folgas?: boolean
  empresas?: boolean | empresasArgs
  dados?: boolean | FindManydadosArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  escalascompetencia?: boolean | FindManyescalascompetenciaArgs
}

export type escalasInclude = {
  empresas?: boolean | empresasArgs
  dados?: boolean | FindManydadosArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
  escalascompetencia?: boolean | FindManyescalascompetenciaArgs
}

export type escalasGetPayload<
  S extends boolean | null | undefined | escalasArgs,
  U = keyof S
> = S extends true
  ? escalas
  : S extends undefined
  ? never
  : S extends escalasArgs | FindManyescalasArgs
  ? 'include' extends U
    ? escalas  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'dados'
      ? Array<dadosGetPayload<S['include'][P]>> :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['include'][P]>> :
      P extends 'escalascompetencia'
      ? Array<escalascompetenciaGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof escalas ? escalas[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'dados'
      ? Array<dadosGetPayload<S['select'][P]>> :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['select'][P]>> :
      P extends 'escalascompetencia'
      ? Array<escalascompetenciaGetPayload<S['select'][P]>> : never
    }
  : escalas
: escalas


export interface escalasDelegate {
  /**
   * Find zero or one Escalas that matches the filter.
   * @param {FindOneescalasArgs} args - Arguments to find a Escalas
   * @example
   * // Get one Escalas
   * const escalas = await prisma.escalas.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneescalasArgs>(
    args: Subset<T, FindOneescalasArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas | null>, Prisma__escalasClient<escalasGetPayload<T> | null>>
  /**
   * Find the first Escalas that matches the filter.
   * @param {FindFirstescalasArgs} args - Arguments to find a Escalas
   * @example
   * // Get one Escalas
   * const escalas = await prisma.escalas.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstescalasArgs>(
    args?: Subset<T, FindFirstescalasArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas | null>, Prisma__escalasClient<escalasGetPayload<T> | null>>
  /**
   * Find zero or more Escalas that matches the filter.
   * @param {FindManyescalasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Escalas
   * const escalas = await prisma.escalas.findMany()
   * 
   * // Get first 10 Escalas
   * const escalas = await prisma.escalas.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const escalasWithIdOnly = await prisma.escalas.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyescalasArgs>(
    args?: Subset<T, FindManyescalasArgs>
  ): CheckSelect<T, Promise<Array<escalas>>, Promise<Array<escalasGetPayload<T>>>>
  /**
   * Create a Escalas.
   * @param {escalasCreateArgs} args - Arguments to create a Escalas.
   * @example
   * // Create one Escalas
   * const Escalas = await prisma.escalas.create({
   *   data: {
   *     // ... data to create a Escalas
   *   }
   * })
   * 
  **/
  create<T extends escalasCreateArgs>(
    args: Subset<T, escalasCreateArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas>, Prisma__escalasClient<escalasGetPayload<T>>>
  /**
   * Delete a Escalas.
   * @param {escalasDeleteArgs} args - Arguments to delete one Escalas.
   * @example
   * // Delete one Escalas
   * const Escalas = await prisma.escalas.delete({
   *   where: {
   *     // ... filter to delete one Escalas
   *   }
   * })
   * 
  **/
  delete<T extends escalasDeleteArgs>(
    args: Subset<T, escalasDeleteArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas>, Prisma__escalasClient<escalasGetPayload<T>>>
  /**
   * Update one Escalas.
   * @param {escalasUpdateArgs} args - Arguments to update one Escalas.
   * @example
   * // Update one Escalas
   * const escalas = await prisma.escalas.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends escalasUpdateArgs>(
    args: Subset<T, escalasUpdateArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas>, Prisma__escalasClient<escalasGetPayload<T>>>
  /**
   * Delete zero or more Escalas.
   * @param {escalasDeleteManyArgs} args - Arguments to filter Escalas to delete.
   * @example
   * // Delete a few Escalas
   * const { count } = await prisma.escalas.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends escalasDeleteManyArgs>(
    args: Subset<T, escalasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Escalas.
   * @param {escalasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Escalas
   * const escalas = await prisma.escalas.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends escalasUpdateManyArgs>(
    args: Subset<T, escalasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Escalas.
   * @param {escalasUpsertArgs} args - Arguments to update or create a Escalas.
   * @example
   * // Update or create a Escalas
   * const escalas = await prisma.escalas.upsert({
   *   create: {
   *     // ... data to create a Escalas
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Escalas we want to update
   *   }
   * })
  **/
  upsert<T extends escalasUpsertArgs>(
    args: Subset<T, escalasUpsertArgs>
  ): CheckSelect<T, Prisma__escalasClient<escalas>, Prisma__escalasClient<escalasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyescalasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEscalasArgs>(args: Subset<T, AggregateEscalasArgs>): Promise<GetEscalasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for escalas.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__escalasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  dados<T extends FindManydadosArgs = {}>(args?: Subset<T, FindManydadosArgs>): CheckSelect<T, Promise<Array<dados>>, Promise<Array<dadosGetPayload<T>>>>;

  detalhepedidos_old<T extends FindManydetalhepedidos_oldArgs = {}>(args?: Subset<T, FindManydetalhepedidos_oldArgs>): CheckSelect<T, Promise<Array<detalhepedidos_old>>, Promise<Array<detalhepedidos_oldGetPayload<T>>>>;

  escalascompetencia<T extends FindManyescalascompetenciaArgs = {}>(args?: Subset<T, FindManyescalascompetenciaArgs>): CheckSelect<T, Promise<Array<escalascompetencia>>, Promise<Array<escalascompetenciaGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * escalas findOne
 */
export type FindOneescalasArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * Filter, which escalas to fetch.
  **/
  where: escalasWhereUniqueInput
}


/**
 * escalas findFirst
 */
export type FindFirstescalasArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * Filter, which escalas to fetch.
  **/
  where?: escalasWhereInput
  orderBy?: XOR<Enumerable<escalasOrderByInput>, escalasOrderByInput>
  cursor?: escalasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EscalasDistinctFieldEnum>
}


/**
 * escalas findMany
 */
export type FindManyescalasArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * Filter, which escalas to fetch.
  **/
  where?: escalasWhereInput
  /**
   * Determine the order of the escalas to fetch.
  **/
  orderBy?: XOR<Enumerable<escalasOrderByInput>, escalasOrderByInput>
  /**
   * Sets the position for listing escalas.
  **/
  cursor?: escalasWhereUniqueInput
  /**
   * The number of escalas to fetch. If negative number, it will take escalas before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` escalas.
  **/
  skip?: number
  distinct?: Enumerable<EscalasDistinctFieldEnum>
}


/**
 * escalas create
 */
export type escalasCreateArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * The data needed to create a escalas.
  **/
  data: escalasCreateInput
}


/**
 * escalas update
 */
export type escalasUpdateArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * The data needed to update a escalas.
  **/
  data: escalasUpdateInput
  /**
   * Choose, which escalas to update.
  **/
  where: escalasWhereUniqueInput
}


/**
 * escalas updateMany
 */
export type escalasUpdateManyArgs = {
  data: escalasUpdateManyMutationInput
  where?: escalasWhereInput
}


/**
 * escalas upsert
 */
export type escalasUpsertArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * The filter to search for the escalas to update in case it exists.
  **/
  where: escalasWhereUniqueInput
  /**
   * In case the escalas found by the `where` argument doesn't exist, create a new escalas with this data.
  **/
  create: escalasCreateInput
  /**
   * In case the escalas was found with the provided `where` argument, update it with this data.
  **/
  update: escalasUpdateInput
}


/**
 * escalas delete
 */
export type escalasDeleteArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
  /**
   * Filter which escalas to delete.
  **/
  where: escalasWhereUniqueInput
}


/**
 * escalas deleteMany
 */
export type escalasDeleteManyArgs = {
  where?: escalasWhereInput
}


/**
 * escalas without action
 */
export type escalasArgs = {
  /**
   * Select specific fields to fetch from the escalas
  **/
  select?: XOR<escalasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalasInclude, null>
}



/**
 * Model meurh
 */

export type meurh = {
  Id: number
  Protocolo: string | null
  CPF: string | null
  DtTicketAbertura: Date | null
  DtTicketFechamento: Date | null
  Assunto: string | null
  Msg: string | null
  Status: string | null
}


export type AggregateMeurh = {
  count: number
  avg: MeurhAvgAggregateOutputType | null
  sum: MeurhSumAggregateOutputType | null
  min: MeurhMinAggregateOutputType | null
  max: MeurhMaxAggregateOutputType | null
}

export type MeurhAvgAggregateOutputType = {
  Id: number
}

export type MeurhSumAggregateOutputType = {
  Id: number
}

export type MeurhMinAggregateOutputType = {
  Id: number
}

export type MeurhMaxAggregateOutputType = {
  Id: number
}


export type MeurhAvgAggregateInputType = {
  Id?: true
}

export type MeurhSumAggregateInputType = {
  Id?: true
}

export type MeurhMinAggregateInputType = {
  Id?: true
}

export type MeurhMaxAggregateInputType = {
  Id?: true
}

export type AggregateMeurhArgs = {
  where?: meurhWhereInput
  orderBy?: XOR<Enumerable<meurhOrderByInput>, meurhOrderByInput>
  cursor?: meurhWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhDistinctFieldEnum>
  count?: true
  avg?: MeurhAvgAggregateInputType
  sum?: MeurhSumAggregateInputType
  min?: MeurhMinAggregateInputType
  max?: MeurhMaxAggregateInputType
}

export type GetMeurhAggregateType<T extends AggregateMeurhArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetMeurhAggregateScalarType<T[P]>
}

export type GetMeurhAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof MeurhAvgAggregateOutputType ? MeurhAvgAggregateOutputType[P] : never
}
    
    

export type meurhSelect = {
  Id?: boolean
  Protocolo?: boolean
  CPF?: boolean
  DtTicketAbertura?: boolean
  DtTicketFechamento?: boolean
  Assunto?: boolean
  Msg?: boolean
  Status?: boolean
  dados?: boolean | dadosArgs
  meurhhistorico?: boolean | FindManymeurhhistoricoArgs
}

export type meurhInclude = {
  dados?: boolean | dadosArgs
  meurhhistorico?: boolean | FindManymeurhhistoricoArgs
}

export type meurhGetPayload<
  S extends boolean | null | undefined | meurhArgs,
  U = keyof S
> = S extends true
  ? meurh
  : S extends undefined
  ? never
  : S extends meurhArgs | FindManymeurhArgs
  ? 'include' extends U
    ? meurh  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dados'
      ? dadosGetPayload<S['include'][P]> | null :
      P extends 'meurhhistorico'
      ? Array<meurhhistoricoGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof meurh ? meurh[P]
: 
      P extends 'dados'
      ? dadosGetPayload<S['select'][P]> | null :
      P extends 'meurhhistorico'
      ? Array<meurhhistoricoGetPayload<S['select'][P]>> : never
    }
  : meurh
: meurh


export interface meurhDelegate {
  /**
   * Find zero or one Meurh that matches the filter.
   * @param {FindOnemeurhArgs} args - Arguments to find a Meurh
   * @example
   * // Get one Meurh
   * const meurh = await prisma.meurh.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnemeurhArgs>(
    args: Subset<T, FindOnemeurhArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh | null>, Prisma__meurhClient<meurhGetPayload<T> | null>>
  /**
   * Find the first Meurh that matches the filter.
   * @param {FindFirstmeurhArgs} args - Arguments to find a Meurh
   * @example
   * // Get one Meurh
   * const meurh = await prisma.meurh.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstmeurhArgs>(
    args?: Subset<T, FindFirstmeurhArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh | null>, Prisma__meurhClient<meurhGetPayload<T> | null>>
  /**
   * Find zero or more Meurhs that matches the filter.
   * @param {FindManymeurhArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Meurhs
   * const meurhs = await prisma.meurh.findMany()
   * 
   * // Get first 10 Meurhs
   * const meurhs = await prisma.meurh.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const meurhWithIdOnly = await prisma.meurh.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManymeurhArgs>(
    args?: Subset<T, FindManymeurhArgs>
  ): CheckSelect<T, Promise<Array<meurh>>, Promise<Array<meurhGetPayload<T>>>>
  /**
   * Create a Meurh.
   * @param {meurhCreateArgs} args - Arguments to create a Meurh.
   * @example
   * // Create one Meurh
   * const Meurh = await prisma.meurh.create({
   *   data: {
   *     // ... data to create a Meurh
   *   }
   * })
   * 
  **/
  create<T extends meurhCreateArgs>(
    args: Subset<T, meurhCreateArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh>, Prisma__meurhClient<meurhGetPayload<T>>>
  /**
   * Delete a Meurh.
   * @param {meurhDeleteArgs} args - Arguments to delete one Meurh.
   * @example
   * // Delete one Meurh
   * const Meurh = await prisma.meurh.delete({
   *   where: {
   *     // ... filter to delete one Meurh
   *   }
   * })
   * 
  **/
  delete<T extends meurhDeleteArgs>(
    args: Subset<T, meurhDeleteArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh>, Prisma__meurhClient<meurhGetPayload<T>>>
  /**
   * Update one Meurh.
   * @param {meurhUpdateArgs} args - Arguments to update one Meurh.
   * @example
   * // Update one Meurh
   * const meurh = await prisma.meurh.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends meurhUpdateArgs>(
    args: Subset<T, meurhUpdateArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh>, Prisma__meurhClient<meurhGetPayload<T>>>
  /**
   * Delete zero or more Meurhs.
   * @param {meurhDeleteManyArgs} args - Arguments to filter Meurhs to delete.
   * @example
   * // Delete a few Meurhs
   * const { count } = await prisma.meurh.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends meurhDeleteManyArgs>(
    args: Subset<T, meurhDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Meurhs.
   * @param {meurhUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Meurhs
   * const meurh = await prisma.meurh.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends meurhUpdateManyArgs>(
    args: Subset<T, meurhUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Meurh.
   * @param {meurhUpsertArgs} args - Arguments to update or create a Meurh.
   * @example
   * // Update or create a Meurh
   * const meurh = await prisma.meurh.upsert({
   *   create: {
   *     // ... data to create a Meurh
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Meurh we want to update
   *   }
   * })
  **/
  upsert<T extends meurhUpsertArgs>(
    args: Subset<T, meurhUpsertArgs>
  ): CheckSelect<T, Prisma__meurhClient<meurh>, Prisma__meurhClient<meurhGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManymeurhArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMeurhArgs>(args: Subset<T, AggregateMeurhArgs>): Promise<GetMeurhAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for meurh.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__meurhClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dados<T extends dadosArgs = {}>(args?: Subset<T, dadosArgs>): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>;

  meurhhistorico<T extends FindManymeurhhistoricoArgs = {}>(args?: Subset<T, FindManymeurhhistoricoArgs>): CheckSelect<T, Promise<Array<meurhhistorico>>, Promise<Array<meurhhistoricoGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * meurh findOne
 */
export type FindOnemeurhArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * Filter, which meurh to fetch.
  **/
  where: meurhWhereUniqueInput
}


/**
 * meurh findFirst
 */
export type FindFirstmeurhArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * Filter, which meurh to fetch.
  **/
  where?: meurhWhereInput
  orderBy?: XOR<Enumerable<meurhOrderByInput>, meurhOrderByInput>
  cursor?: meurhWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhDistinctFieldEnum>
}


/**
 * meurh findMany
 */
export type FindManymeurhArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * Filter, which meurhs to fetch.
  **/
  where?: meurhWhereInput
  /**
   * Determine the order of the meurhs to fetch.
  **/
  orderBy?: XOR<Enumerable<meurhOrderByInput>, meurhOrderByInput>
  /**
   * Sets the position for listing meurhs.
  **/
  cursor?: meurhWhereUniqueInput
  /**
   * The number of meurhs to fetch. If negative number, it will take meurhs before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` meurhs.
  **/
  skip?: number
  distinct?: Enumerable<MeurhDistinctFieldEnum>
}


/**
 * meurh create
 */
export type meurhCreateArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * The data needed to create a meurh.
  **/
  data: meurhCreateInput
}


/**
 * meurh update
 */
export type meurhUpdateArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * The data needed to update a meurh.
  **/
  data: meurhUpdateInput
  /**
   * Choose, which meurh to update.
  **/
  where: meurhWhereUniqueInput
}


/**
 * meurh updateMany
 */
export type meurhUpdateManyArgs = {
  data: meurhUpdateManyMutationInput
  where?: meurhWhereInput
}


/**
 * meurh upsert
 */
export type meurhUpsertArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * The filter to search for the meurh to update in case it exists.
  **/
  where: meurhWhereUniqueInput
  /**
   * In case the meurh found by the `where` argument doesn't exist, create a new meurh with this data.
  **/
  create: meurhCreateInput
  /**
   * In case the meurh was found with the provided `where` argument, update it with this data.
  **/
  update: meurhUpdateInput
}


/**
 * meurh delete
 */
export type meurhDeleteArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
  /**
   * Filter which meurh to delete.
  **/
  where: meurhWhereUniqueInput
}


/**
 * meurh deleteMany
 */
export type meurhDeleteManyArgs = {
  where?: meurhWhereInput
}


/**
 * meurh without action
 */
export type meurhArgs = {
  /**
   * Select specific fields to fetch from the meurh
  **/
  select?: XOR<meurhSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhInclude, null>
}



/**
 * Model ocorrencias
 */

export type ocorrencias = {
  Id: number
  CPF: string | null
  IdTipoOcorrencia: number | null
  DtOcorrencia: Date | null
}


export type AggregateOcorrencias = {
  count: number
  avg: OcorrenciasAvgAggregateOutputType | null
  sum: OcorrenciasSumAggregateOutputType | null
  min: OcorrenciasMinAggregateOutputType | null
  max: OcorrenciasMaxAggregateOutputType | null
}

export type OcorrenciasAvgAggregateOutputType = {
  Id: number
  IdTipoOcorrencia: number | null
}

export type OcorrenciasSumAggregateOutputType = {
  Id: number
  IdTipoOcorrencia: number | null
}

export type OcorrenciasMinAggregateOutputType = {
  Id: number
  IdTipoOcorrencia: number | null
}

export type OcorrenciasMaxAggregateOutputType = {
  Id: number
  IdTipoOcorrencia: number | null
}


export type OcorrenciasAvgAggregateInputType = {
  Id?: true
  IdTipoOcorrencia?: true
}

export type OcorrenciasSumAggregateInputType = {
  Id?: true
  IdTipoOcorrencia?: true
}

export type OcorrenciasMinAggregateInputType = {
  Id?: true
  IdTipoOcorrencia?: true
}

export type OcorrenciasMaxAggregateInputType = {
  Id?: true
  IdTipoOcorrencia?: true
}

export type AggregateOcorrenciasArgs = {
  where?: ocorrenciasWhereInput
  orderBy?: XOR<Enumerable<ocorrenciasOrderByInput>, ocorrenciasOrderByInput>
  cursor?: ocorrenciasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OcorrenciasDistinctFieldEnum>
  count?: true
  avg?: OcorrenciasAvgAggregateInputType
  sum?: OcorrenciasSumAggregateInputType
  min?: OcorrenciasMinAggregateInputType
  max?: OcorrenciasMaxAggregateInputType
}

export type GetOcorrenciasAggregateType<T extends AggregateOcorrenciasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOcorrenciasAggregateScalarType<T[P]>
}

export type GetOcorrenciasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OcorrenciasAvgAggregateOutputType ? OcorrenciasAvgAggregateOutputType[P] : never
}
    
    

export type ocorrenciasSelect = {
  Id?: boolean
  CPF?: boolean
  IdTipoOcorrencia?: boolean
  DtOcorrencia?: boolean
  tiposocorrencias?: boolean | tiposocorrenciasArgs
}

export type ocorrenciasInclude = {
  tiposocorrencias?: boolean | tiposocorrenciasArgs
}

export type ocorrenciasGetPayload<
  S extends boolean | null | undefined | ocorrenciasArgs,
  U = keyof S
> = S extends true
  ? ocorrencias
  : S extends undefined
  ? never
  : S extends ocorrenciasArgs | FindManyocorrenciasArgs
  ? 'include' extends U
    ? ocorrencias  & {
      [P in TrueKeys<S['include']>]:
      P extends 'tiposocorrencias'
      ? tiposocorrenciasGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ocorrencias ? ocorrencias[P]
: 
      P extends 'tiposocorrencias'
      ? tiposocorrenciasGetPayload<S['select'][P]> | null : never
    }
  : ocorrencias
: ocorrencias


export interface ocorrenciasDelegate {
  /**
   * Find zero or one Ocorrencias that matches the filter.
   * @param {FindOneocorrenciasArgs} args - Arguments to find a Ocorrencias
   * @example
   * // Get one Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneocorrenciasArgs>(
    args: Subset<T, FindOneocorrenciasArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias | null>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T> | null>>
  /**
   * Find the first Ocorrencias that matches the filter.
   * @param {FindFirstocorrenciasArgs} args - Arguments to find a Ocorrencias
   * @example
   * // Get one Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstocorrenciasArgs>(
    args?: Subset<T, FindFirstocorrenciasArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias | null>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T> | null>>
  /**
   * Find zero or more Ocorrencias that matches the filter.
   * @param {FindManyocorrenciasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.findMany()
   * 
   * // Get first 10 Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const ocorrenciasWithIdOnly = await prisma.ocorrencias.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyocorrenciasArgs>(
    args?: Subset<T, FindManyocorrenciasArgs>
  ): CheckSelect<T, Promise<Array<ocorrencias>>, Promise<Array<ocorrenciasGetPayload<T>>>>
  /**
   * Create a Ocorrencias.
   * @param {ocorrenciasCreateArgs} args - Arguments to create a Ocorrencias.
   * @example
   * // Create one Ocorrencias
   * const Ocorrencias = await prisma.ocorrencias.create({
   *   data: {
   *     // ... data to create a Ocorrencias
   *   }
   * })
   * 
  **/
  create<T extends ocorrenciasCreateArgs>(
    args: Subset<T, ocorrenciasCreateArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T>>>
  /**
   * Delete a Ocorrencias.
   * @param {ocorrenciasDeleteArgs} args - Arguments to delete one Ocorrencias.
   * @example
   * // Delete one Ocorrencias
   * const Ocorrencias = await prisma.ocorrencias.delete({
   *   where: {
   *     // ... filter to delete one Ocorrencias
   *   }
   * })
   * 
  **/
  delete<T extends ocorrenciasDeleteArgs>(
    args: Subset<T, ocorrenciasDeleteArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T>>>
  /**
   * Update one Ocorrencias.
   * @param {ocorrenciasUpdateArgs} args - Arguments to update one Ocorrencias.
   * @example
   * // Update one Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ocorrenciasUpdateArgs>(
    args: Subset<T, ocorrenciasUpdateArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T>>>
  /**
   * Delete zero or more Ocorrencias.
   * @param {ocorrenciasDeleteManyArgs} args - Arguments to filter Ocorrencias to delete.
   * @example
   * // Delete a few Ocorrencias
   * const { count } = await prisma.ocorrencias.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ocorrenciasDeleteManyArgs>(
    args: Subset<T, ocorrenciasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Ocorrencias.
   * @param {ocorrenciasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ocorrenciasUpdateManyArgs>(
    args: Subset<T, ocorrenciasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Ocorrencias.
   * @param {ocorrenciasUpsertArgs} args - Arguments to update or create a Ocorrencias.
   * @example
   * // Update or create a Ocorrencias
   * const ocorrencias = await prisma.ocorrencias.upsert({
   *   create: {
   *     // ... data to create a Ocorrencias
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Ocorrencias we want to update
   *   }
   * })
  **/
  upsert<T extends ocorrenciasUpsertArgs>(
    args: Subset<T, ocorrenciasUpsertArgs>
  ): CheckSelect<T, Prisma__ocorrenciasClient<ocorrencias>, Prisma__ocorrenciasClient<ocorrenciasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyocorrenciasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOcorrenciasArgs>(args: Subset<T, AggregateOcorrenciasArgs>): Promise<GetOcorrenciasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ocorrencias.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ocorrenciasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  tiposocorrencias<T extends tiposocorrenciasArgs = {}>(args?: Subset<T, tiposocorrenciasArgs>): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias | null>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ocorrencias findOne
 */
export type FindOneocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * Filter, which ocorrencias to fetch.
  **/
  where: ocorrenciasWhereUniqueInput
}


/**
 * ocorrencias findFirst
 */
export type FindFirstocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * Filter, which ocorrencias to fetch.
  **/
  where?: ocorrenciasWhereInput
  orderBy?: XOR<Enumerable<ocorrenciasOrderByInput>, ocorrenciasOrderByInput>
  cursor?: ocorrenciasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OcorrenciasDistinctFieldEnum>
}


/**
 * ocorrencias findMany
 */
export type FindManyocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * Filter, which ocorrencias to fetch.
  **/
  where?: ocorrenciasWhereInput
  /**
   * Determine the order of the ocorrencias to fetch.
  **/
  orderBy?: XOR<Enumerable<ocorrenciasOrderByInput>, ocorrenciasOrderByInput>
  /**
   * Sets the position for listing ocorrencias.
  **/
  cursor?: ocorrenciasWhereUniqueInput
  /**
   * The number of ocorrencias to fetch. If negative number, it will take ocorrencias before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ocorrencias.
  **/
  skip?: number
  distinct?: Enumerable<OcorrenciasDistinctFieldEnum>
}


/**
 * ocorrencias create
 */
export type ocorrenciasCreateArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * The data needed to create a ocorrencias.
  **/
  data: ocorrenciasCreateInput
}


/**
 * ocorrencias update
 */
export type ocorrenciasUpdateArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * The data needed to update a ocorrencias.
  **/
  data: ocorrenciasUpdateInput
  /**
   * Choose, which ocorrencias to update.
  **/
  where: ocorrenciasWhereUniqueInput
}


/**
 * ocorrencias updateMany
 */
export type ocorrenciasUpdateManyArgs = {
  data: ocorrenciasUpdateManyMutationInput
  where?: ocorrenciasWhereInput
}


/**
 * ocorrencias upsert
 */
export type ocorrenciasUpsertArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * The filter to search for the ocorrencias to update in case it exists.
  **/
  where: ocorrenciasWhereUniqueInput
  /**
   * In case the ocorrencias found by the `where` argument doesn't exist, create a new ocorrencias with this data.
  **/
  create: ocorrenciasCreateInput
  /**
   * In case the ocorrencias was found with the provided `where` argument, update it with this data.
  **/
  update: ocorrenciasUpdateInput
}


/**
 * ocorrencias delete
 */
export type ocorrenciasDeleteArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
  /**
   * Filter which ocorrencias to delete.
  **/
  where: ocorrenciasWhereUniqueInput
}


/**
 * ocorrencias deleteMany
 */
export type ocorrenciasDeleteManyArgs = {
  where?: ocorrenciasWhereInput
}


/**
 * ocorrencias without action
 */
export type ocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the ocorrencias
  **/
  select?: XOR<ocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<ocorrenciasInclude, null>
}



/**
 * Model tiposocorrencias
 */

export type tiposocorrencias = {
  Id: number
  NmOcorrencia: string | null
  DescBeneficio: boolean | null
  IdEmpresa: number | null
  Descricao: string | null
}


export type AggregateTiposocorrencias = {
  count: number
  avg: TiposocorrenciasAvgAggregateOutputType | null
  sum: TiposocorrenciasSumAggregateOutputType | null
  min: TiposocorrenciasMinAggregateOutputType | null
  max: TiposocorrenciasMaxAggregateOutputType | null
}

export type TiposocorrenciasAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type TiposocorrenciasSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type TiposocorrenciasMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type TiposocorrenciasMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}


export type TiposocorrenciasAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type TiposocorrenciasSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type TiposocorrenciasMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type TiposocorrenciasMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type AggregateTiposocorrenciasArgs = {
  where?: tiposocorrenciasWhereInput
  orderBy?: XOR<Enumerable<tiposocorrenciasOrderByInput>, tiposocorrenciasOrderByInput>
  cursor?: tiposocorrenciasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TiposocorrenciasDistinctFieldEnum>
  count?: true
  avg?: TiposocorrenciasAvgAggregateInputType
  sum?: TiposocorrenciasSumAggregateInputType
  min?: TiposocorrenciasMinAggregateInputType
  max?: TiposocorrenciasMaxAggregateInputType
}

export type GetTiposocorrenciasAggregateType<T extends AggregateTiposocorrenciasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetTiposocorrenciasAggregateScalarType<T[P]>
}

export type GetTiposocorrenciasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof TiposocorrenciasAvgAggregateOutputType ? TiposocorrenciasAvgAggregateOutputType[P] : never
}
    
    

export type tiposocorrenciasSelect = {
  Id?: boolean
  NmOcorrencia?: boolean
  DescBeneficio?: boolean
  IdEmpresa?: boolean
  Descricao?: boolean
  empresas?: boolean | empresasArgs
  ocorrencias?: boolean | FindManyocorrenciasArgs
}

export type tiposocorrenciasInclude = {
  empresas?: boolean | empresasArgs
  ocorrencias?: boolean | FindManyocorrenciasArgs
}

export type tiposocorrenciasGetPayload<
  S extends boolean | null | undefined | tiposocorrenciasArgs,
  U = keyof S
> = S extends true
  ? tiposocorrencias
  : S extends undefined
  ? never
  : S extends tiposocorrenciasArgs | FindManytiposocorrenciasArgs
  ? 'include' extends U
    ? tiposocorrencias  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'ocorrencias'
      ? Array<ocorrenciasGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof tiposocorrencias ? tiposocorrencias[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'ocorrencias'
      ? Array<ocorrenciasGetPayload<S['select'][P]>> : never
    }
  : tiposocorrencias
: tiposocorrencias


export interface tiposocorrenciasDelegate {
  /**
   * Find zero or one Tiposocorrencias that matches the filter.
   * @param {FindOnetiposocorrenciasArgs} args - Arguments to find a Tiposocorrencias
   * @example
   * // Get one Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnetiposocorrenciasArgs>(
    args: Subset<T, FindOnetiposocorrenciasArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias | null>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T> | null>>
  /**
   * Find the first Tiposocorrencias that matches the filter.
   * @param {FindFirsttiposocorrenciasArgs} args - Arguments to find a Tiposocorrencias
   * @example
   * // Get one Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirsttiposocorrenciasArgs>(
    args?: Subset<T, FindFirsttiposocorrenciasArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias | null>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T> | null>>
  /**
   * Find zero or more Tiposocorrencias that matches the filter.
   * @param {FindManytiposocorrenciasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.findMany()
   * 
   * // Get first 10 Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const tiposocorrenciasWithIdOnly = await prisma.tiposocorrencias.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManytiposocorrenciasArgs>(
    args?: Subset<T, FindManytiposocorrenciasArgs>
  ): CheckSelect<T, Promise<Array<tiposocorrencias>>, Promise<Array<tiposocorrenciasGetPayload<T>>>>
  /**
   * Create a Tiposocorrencias.
   * @param {tiposocorrenciasCreateArgs} args - Arguments to create a Tiposocorrencias.
   * @example
   * // Create one Tiposocorrencias
   * const Tiposocorrencias = await prisma.tiposocorrencias.create({
   *   data: {
   *     // ... data to create a Tiposocorrencias
   *   }
   * })
   * 
  **/
  create<T extends tiposocorrenciasCreateArgs>(
    args: Subset<T, tiposocorrenciasCreateArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T>>>
  /**
   * Delete a Tiposocorrencias.
   * @param {tiposocorrenciasDeleteArgs} args - Arguments to delete one Tiposocorrencias.
   * @example
   * // Delete one Tiposocorrencias
   * const Tiposocorrencias = await prisma.tiposocorrencias.delete({
   *   where: {
   *     // ... filter to delete one Tiposocorrencias
   *   }
   * })
   * 
  **/
  delete<T extends tiposocorrenciasDeleteArgs>(
    args: Subset<T, tiposocorrenciasDeleteArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T>>>
  /**
   * Update one Tiposocorrencias.
   * @param {tiposocorrenciasUpdateArgs} args - Arguments to update one Tiposocorrencias.
   * @example
   * // Update one Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends tiposocorrenciasUpdateArgs>(
    args: Subset<T, tiposocorrenciasUpdateArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T>>>
  /**
   * Delete zero or more Tiposocorrencias.
   * @param {tiposocorrenciasDeleteManyArgs} args - Arguments to filter Tiposocorrencias to delete.
   * @example
   * // Delete a few Tiposocorrencias
   * const { count } = await prisma.tiposocorrencias.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends tiposocorrenciasDeleteManyArgs>(
    args: Subset<T, tiposocorrenciasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Tiposocorrencias.
   * @param {tiposocorrenciasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends tiposocorrenciasUpdateManyArgs>(
    args: Subset<T, tiposocorrenciasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Tiposocorrencias.
   * @param {tiposocorrenciasUpsertArgs} args - Arguments to update or create a Tiposocorrencias.
   * @example
   * // Update or create a Tiposocorrencias
   * const tiposocorrencias = await prisma.tiposocorrencias.upsert({
   *   create: {
   *     // ... data to create a Tiposocorrencias
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Tiposocorrencias we want to update
   *   }
   * })
  **/
  upsert<T extends tiposocorrenciasUpsertArgs>(
    args: Subset<T, tiposocorrenciasUpsertArgs>
  ): CheckSelect<T, Prisma__tiposocorrenciasClient<tiposocorrencias>, Prisma__tiposocorrenciasClient<tiposocorrenciasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManytiposocorrenciasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateTiposocorrenciasArgs>(args: Subset<T, AggregateTiposocorrenciasArgs>): Promise<GetTiposocorrenciasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for tiposocorrencias.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__tiposocorrenciasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  ocorrencias<T extends FindManyocorrenciasArgs = {}>(args?: Subset<T, FindManyocorrenciasArgs>): CheckSelect<T, Promise<Array<ocorrencias>>, Promise<Array<ocorrenciasGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * tiposocorrencias findOne
 */
export type FindOnetiposocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * Filter, which tiposocorrencias to fetch.
  **/
  where: tiposocorrenciasWhereUniqueInput
}


/**
 * tiposocorrencias findFirst
 */
export type FindFirsttiposocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * Filter, which tiposocorrencias to fetch.
  **/
  where?: tiposocorrenciasWhereInput
  orderBy?: XOR<Enumerable<tiposocorrenciasOrderByInput>, tiposocorrenciasOrderByInput>
  cursor?: tiposocorrenciasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TiposocorrenciasDistinctFieldEnum>
}


/**
 * tiposocorrencias findMany
 */
export type FindManytiposocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * Filter, which tiposocorrencias to fetch.
  **/
  where?: tiposocorrenciasWhereInput
  /**
   * Determine the order of the tiposocorrencias to fetch.
  **/
  orderBy?: XOR<Enumerable<tiposocorrenciasOrderByInput>, tiposocorrenciasOrderByInput>
  /**
   * Sets the position for listing tiposocorrencias.
  **/
  cursor?: tiposocorrenciasWhereUniqueInput
  /**
   * The number of tiposocorrencias to fetch. If negative number, it will take tiposocorrencias before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` tiposocorrencias.
  **/
  skip?: number
  distinct?: Enumerable<TiposocorrenciasDistinctFieldEnum>
}


/**
 * tiposocorrencias create
 */
export type tiposocorrenciasCreateArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * The data needed to create a tiposocorrencias.
  **/
  data: tiposocorrenciasCreateInput
}


/**
 * tiposocorrencias update
 */
export type tiposocorrenciasUpdateArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * The data needed to update a tiposocorrencias.
  **/
  data: tiposocorrenciasUpdateInput
  /**
   * Choose, which tiposocorrencias to update.
  **/
  where: tiposocorrenciasWhereUniqueInput
}


/**
 * tiposocorrencias updateMany
 */
export type tiposocorrenciasUpdateManyArgs = {
  data: tiposocorrenciasUpdateManyMutationInput
  where?: tiposocorrenciasWhereInput
}


/**
 * tiposocorrencias upsert
 */
export type tiposocorrenciasUpsertArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * The filter to search for the tiposocorrencias to update in case it exists.
  **/
  where: tiposocorrenciasWhereUniqueInput
  /**
   * In case the tiposocorrencias found by the `where` argument doesn't exist, create a new tiposocorrencias with this data.
  **/
  create: tiposocorrenciasCreateInput
  /**
   * In case the tiposocorrencias was found with the provided `where` argument, update it with this data.
  **/
  update: tiposocorrenciasUpdateInput
}


/**
 * tiposocorrencias delete
 */
export type tiposocorrenciasDeleteArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
  /**
   * Filter which tiposocorrencias to delete.
  **/
  where: tiposocorrenciasWhereUniqueInput
}


/**
 * tiposocorrencias deleteMany
 */
export type tiposocorrenciasDeleteManyArgs = {
  where?: tiposocorrenciasWhereInput
}


/**
 * tiposocorrencias without action
 */
export type tiposocorrenciasArgs = {
  /**
   * Select specific fields to fetch from the tiposocorrencias
  **/
  select?: XOR<tiposocorrenciasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<tiposocorrenciasInclude, null>
}



/**
 * Model escalascompetencia
 */

export type escalascompetencia = {
  Id: number
  IdEscalas: number | null
  Competencia: string | null
  QtdUteis: number | null
  QtdFolgas: number | null
}


export type AggregateEscalascompetencia = {
  count: number
  avg: EscalascompetenciaAvgAggregateOutputType | null
  sum: EscalascompetenciaSumAggregateOutputType | null
  min: EscalascompetenciaMinAggregateOutputType | null
  max: EscalascompetenciaMaxAggregateOutputType | null
}

export type EscalascompetenciaAvgAggregateOutputType = {
  Id: number
  IdEscalas: number | null
  QtdUteis: number | null
  QtdFolgas: number | null
}

export type EscalascompetenciaSumAggregateOutputType = {
  Id: number
  IdEscalas: number | null
  QtdUteis: number | null
  QtdFolgas: number | null
}

export type EscalascompetenciaMinAggregateOutputType = {
  Id: number
  IdEscalas: number | null
  QtdUteis: number | null
  QtdFolgas: number | null
}

export type EscalascompetenciaMaxAggregateOutputType = {
  Id: number
  IdEscalas: number | null
  QtdUteis: number | null
  QtdFolgas: number | null
}


export type EscalascompetenciaAvgAggregateInputType = {
  Id?: true
  IdEscalas?: true
  QtdUteis?: true
  QtdFolgas?: true
}

export type EscalascompetenciaSumAggregateInputType = {
  Id?: true
  IdEscalas?: true
  QtdUteis?: true
  QtdFolgas?: true
}

export type EscalascompetenciaMinAggregateInputType = {
  Id?: true
  IdEscalas?: true
  QtdUteis?: true
  QtdFolgas?: true
}

export type EscalascompetenciaMaxAggregateInputType = {
  Id?: true
  IdEscalas?: true
  QtdUteis?: true
  QtdFolgas?: true
}

export type AggregateEscalascompetenciaArgs = {
  where?: escalascompetenciaWhereInput
  orderBy?: XOR<Enumerable<escalascompetenciaOrderByInput>, escalascompetenciaOrderByInput>
  cursor?: escalascompetenciaWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EscalascompetenciaDistinctFieldEnum>
  count?: true
  avg?: EscalascompetenciaAvgAggregateInputType
  sum?: EscalascompetenciaSumAggregateInputType
  min?: EscalascompetenciaMinAggregateInputType
  max?: EscalascompetenciaMaxAggregateInputType
}

export type GetEscalascompetenciaAggregateType<T extends AggregateEscalascompetenciaArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEscalascompetenciaAggregateScalarType<T[P]>
}

export type GetEscalascompetenciaAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EscalascompetenciaAvgAggregateOutputType ? EscalascompetenciaAvgAggregateOutputType[P] : never
}
    
    

export type escalascompetenciaSelect = {
  Id?: boolean
  IdEscalas?: boolean
  Competencia?: boolean
  QtdUteis?: boolean
  QtdFolgas?: boolean
  escalas?: boolean | escalasArgs
}

export type escalascompetenciaInclude = {
  escalas?: boolean | escalasArgs
}

export type escalascompetenciaGetPayload<
  S extends boolean | null | undefined | escalascompetenciaArgs,
  U = keyof S
> = S extends true
  ? escalascompetencia
  : S extends undefined
  ? never
  : S extends escalascompetenciaArgs | FindManyescalascompetenciaArgs
  ? 'include' extends U
    ? escalascompetencia  & {
      [P in TrueKeys<S['include']>]:
      P extends 'escalas'
      ? escalasGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof escalascompetencia ? escalascompetencia[P]
: 
      P extends 'escalas'
      ? escalasGetPayload<S['select'][P]> | null : never
    }
  : escalascompetencia
: escalascompetencia


export interface escalascompetenciaDelegate {
  /**
   * Find zero or one Escalascompetencia that matches the filter.
   * @param {FindOneescalascompetenciaArgs} args - Arguments to find a Escalascompetencia
   * @example
   * // Get one Escalascompetencia
   * const escalascompetencia = await prisma.escalascompetencia.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneescalascompetenciaArgs>(
    args: Subset<T, FindOneescalascompetenciaArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia | null>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T> | null>>
  /**
   * Find the first Escalascompetencia that matches the filter.
   * @param {FindFirstescalascompetenciaArgs} args - Arguments to find a Escalascompetencia
   * @example
   * // Get one Escalascompetencia
   * const escalascompetencia = await prisma.escalascompetencia.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstescalascompetenciaArgs>(
    args?: Subset<T, FindFirstescalascompetenciaArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia | null>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T> | null>>
  /**
   * Find zero or more Escalascompetencias that matches the filter.
   * @param {FindManyescalascompetenciaArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Escalascompetencias
   * const escalascompetencias = await prisma.escalascompetencia.findMany()
   * 
   * // Get first 10 Escalascompetencias
   * const escalascompetencias = await prisma.escalascompetencia.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const escalascompetenciaWithIdOnly = await prisma.escalascompetencia.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyescalascompetenciaArgs>(
    args?: Subset<T, FindManyescalascompetenciaArgs>
  ): CheckSelect<T, Promise<Array<escalascompetencia>>, Promise<Array<escalascompetenciaGetPayload<T>>>>
  /**
   * Create a Escalascompetencia.
   * @param {escalascompetenciaCreateArgs} args - Arguments to create a Escalascompetencia.
   * @example
   * // Create one Escalascompetencia
   * const Escalascompetencia = await prisma.escalascompetencia.create({
   *   data: {
   *     // ... data to create a Escalascompetencia
   *   }
   * })
   * 
  **/
  create<T extends escalascompetenciaCreateArgs>(
    args: Subset<T, escalascompetenciaCreateArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T>>>
  /**
   * Delete a Escalascompetencia.
   * @param {escalascompetenciaDeleteArgs} args - Arguments to delete one Escalascompetencia.
   * @example
   * // Delete one Escalascompetencia
   * const Escalascompetencia = await prisma.escalascompetencia.delete({
   *   where: {
   *     // ... filter to delete one Escalascompetencia
   *   }
   * })
   * 
  **/
  delete<T extends escalascompetenciaDeleteArgs>(
    args: Subset<T, escalascompetenciaDeleteArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T>>>
  /**
   * Update one Escalascompetencia.
   * @param {escalascompetenciaUpdateArgs} args - Arguments to update one Escalascompetencia.
   * @example
   * // Update one Escalascompetencia
   * const escalascompetencia = await prisma.escalascompetencia.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends escalascompetenciaUpdateArgs>(
    args: Subset<T, escalascompetenciaUpdateArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T>>>
  /**
   * Delete zero or more Escalascompetencias.
   * @param {escalascompetenciaDeleteManyArgs} args - Arguments to filter Escalascompetencias to delete.
   * @example
   * // Delete a few Escalascompetencias
   * const { count } = await prisma.escalascompetencia.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends escalascompetenciaDeleteManyArgs>(
    args: Subset<T, escalascompetenciaDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Escalascompetencias.
   * @param {escalascompetenciaUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Escalascompetencias
   * const escalascompetencia = await prisma.escalascompetencia.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends escalascompetenciaUpdateManyArgs>(
    args: Subset<T, escalascompetenciaUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Escalascompetencia.
   * @param {escalascompetenciaUpsertArgs} args - Arguments to update or create a Escalascompetencia.
   * @example
   * // Update or create a Escalascompetencia
   * const escalascompetencia = await prisma.escalascompetencia.upsert({
   *   create: {
   *     // ... data to create a Escalascompetencia
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Escalascompetencia we want to update
   *   }
   * })
  **/
  upsert<T extends escalascompetenciaUpsertArgs>(
    args: Subset<T, escalascompetenciaUpsertArgs>
  ): CheckSelect<T, Prisma__escalascompetenciaClient<escalascompetencia>, Prisma__escalascompetenciaClient<escalascompetenciaGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyescalascompetenciaArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEscalascompetenciaArgs>(args: Subset<T, AggregateEscalascompetenciaArgs>): Promise<GetEscalascompetenciaAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for escalascompetencia.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__escalascompetenciaClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  escalas<T extends escalasArgs = {}>(args?: Subset<T, escalasArgs>): CheckSelect<T, Prisma__escalasClient<escalas | null>, Prisma__escalasClient<escalasGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * escalascompetencia findOne
 */
export type FindOneescalascompetenciaArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * Filter, which escalascompetencia to fetch.
  **/
  where: escalascompetenciaWhereUniqueInput
}


/**
 * escalascompetencia findFirst
 */
export type FindFirstescalascompetenciaArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * Filter, which escalascompetencia to fetch.
  **/
  where?: escalascompetenciaWhereInput
  orderBy?: XOR<Enumerable<escalascompetenciaOrderByInput>, escalascompetenciaOrderByInput>
  cursor?: escalascompetenciaWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EscalascompetenciaDistinctFieldEnum>
}


/**
 * escalascompetencia findMany
 */
export type FindManyescalascompetenciaArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * Filter, which escalascompetencias to fetch.
  **/
  where?: escalascompetenciaWhereInput
  /**
   * Determine the order of the escalascompetencias to fetch.
  **/
  orderBy?: XOR<Enumerable<escalascompetenciaOrderByInput>, escalascompetenciaOrderByInput>
  /**
   * Sets the position for listing escalascompetencias.
  **/
  cursor?: escalascompetenciaWhereUniqueInput
  /**
   * The number of escalascompetencias to fetch. If negative number, it will take escalascompetencias before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` escalascompetencias.
  **/
  skip?: number
  distinct?: Enumerable<EscalascompetenciaDistinctFieldEnum>
}


/**
 * escalascompetencia create
 */
export type escalascompetenciaCreateArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * The data needed to create a escalascompetencia.
  **/
  data: escalascompetenciaCreateInput
}


/**
 * escalascompetencia update
 */
export type escalascompetenciaUpdateArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * The data needed to update a escalascompetencia.
  **/
  data: escalascompetenciaUpdateInput
  /**
   * Choose, which escalascompetencia to update.
  **/
  where: escalascompetenciaWhereUniqueInput
}


/**
 * escalascompetencia updateMany
 */
export type escalascompetenciaUpdateManyArgs = {
  data: escalascompetenciaUpdateManyMutationInput
  where?: escalascompetenciaWhereInput
}


/**
 * escalascompetencia upsert
 */
export type escalascompetenciaUpsertArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * The filter to search for the escalascompetencia to update in case it exists.
  **/
  where: escalascompetenciaWhereUniqueInput
  /**
   * In case the escalascompetencia found by the `where` argument doesn't exist, create a new escalascompetencia with this data.
  **/
  create: escalascompetenciaCreateInput
  /**
   * In case the escalascompetencia was found with the provided `where` argument, update it with this data.
  **/
  update: escalascompetenciaUpdateInput
}


/**
 * escalascompetencia delete
 */
export type escalascompetenciaDeleteArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
  /**
   * Filter which escalascompetencia to delete.
  **/
  where: escalascompetenciaWhereUniqueInput
}


/**
 * escalascompetencia deleteMany
 */
export type escalascompetenciaDeleteManyArgs = {
  where?: escalascompetenciaWhereInput
}


/**
 * escalascompetencia without action
 */
export type escalascompetenciaArgs = {
  /**
   * Select specific fields to fetch from the escalascompetencia
  **/
  select?: XOR<escalascompetenciaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<escalascompetenciaInclude, null>
}



/**
 * Model meurhhistorico
 */

export type meurhhistorico = {
  Id: number
  IdMeuRh: number | null
  StatusAtual: string | null
  StatusNovo: string | null
  DtAlteracao: Date | null
}


export type AggregateMeurhhistorico = {
  count: number
  avg: MeurhhistoricoAvgAggregateOutputType | null
  sum: MeurhhistoricoSumAggregateOutputType | null
  min: MeurhhistoricoMinAggregateOutputType | null
  max: MeurhhistoricoMaxAggregateOutputType | null
}

export type MeurhhistoricoAvgAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhhistoricoSumAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhhistoricoMinAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhhistoricoMaxAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}


export type MeurhhistoricoAvgAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhhistoricoSumAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhhistoricoMinAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhhistoricoMaxAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type AggregateMeurhhistoricoArgs = {
  where?: meurhhistoricoWhereInput
  orderBy?: XOR<Enumerable<meurhhistoricoOrderByInput>, meurhhistoricoOrderByInput>
  cursor?: meurhhistoricoWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhhistoricoDistinctFieldEnum>
  count?: true
  avg?: MeurhhistoricoAvgAggregateInputType
  sum?: MeurhhistoricoSumAggregateInputType
  min?: MeurhhistoricoMinAggregateInputType
  max?: MeurhhistoricoMaxAggregateInputType
}

export type GetMeurhhistoricoAggregateType<T extends AggregateMeurhhistoricoArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetMeurhhistoricoAggregateScalarType<T[P]>
}

export type GetMeurhhistoricoAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof MeurhhistoricoAvgAggregateOutputType ? MeurhhistoricoAvgAggregateOutputType[P] : never
}
    
    

export type meurhhistoricoSelect = {
  Id?: boolean
  IdMeuRh?: boolean
  StatusAtual?: boolean
  StatusNovo?: boolean
  DtAlteracao?: boolean
  meurh?: boolean | meurhArgs
}

export type meurhhistoricoInclude = {
  meurh?: boolean | meurhArgs
}

export type meurhhistoricoGetPayload<
  S extends boolean | null | undefined | meurhhistoricoArgs,
  U = keyof S
> = S extends true
  ? meurhhistorico
  : S extends undefined
  ? never
  : S extends meurhhistoricoArgs | FindManymeurhhistoricoArgs
  ? 'include' extends U
    ? meurhhistorico  & {
      [P in TrueKeys<S['include']>]:
      P extends 'meurh'
      ? meurhGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof meurhhistorico ? meurhhistorico[P]
: 
      P extends 'meurh'
      ? meurhGetPayload<S['select'][P]> | null : never
    }
  : meurhhistorico
: meurhhistorico


export interface meurhhistoricoDelegate {
  /**
   * Find zero or one Meurhhistorico that matches the filter.
   * @param {FindOnemeurhhistoricoArgs} args - Arguments to find a Meurhhistorico
   * @example
   * // Get one Meurhhistorico
   * const meurhhistorico = await prisma.meurhhistorico.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnemeurhhistoricoArgs>(
    args: Subset<T, FindOnemeurhhistoricoArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico | null>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T> | null>>
  /**
   * Find the first Meurhhistorico that matches the filter.
   * @param {FindFirstmeurhhistoricoArgs} args - Arguments to find a Meurhhistorico
   * @example
   * // Get one Meurhhistorico
   * const meurhhistorico = await prisma.meurhhistorico.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstmeurhhistoricoArgs>(
    args?: Subset<T, FindFirstmeurhhistoricoArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico | null>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T> | null>>
  /**
   * Find zero or more Meurhhistoricos that matches the filter.
   * @param {FindManymeurhhistoricoArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Meurhhistoricos
   * const meurhhistoricos = await prisma.meurhhistorico.findMany()
   * 
   * // Get first 10 Meurhhistoricos
   * const meurhhistoricos = await prisma.meurhhistorico.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const meurhhistoricoWithIdOnly = await prisma.meurhhistorico.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManymeurhhistoricoArgs>(
    args?: Subset<T, FindManymeurhhistoricoArgs>
  ): CheckSelect<T, Promise<Array<meurhhistorico>>, Promise<Array<meurhhistoricoGetPayload<T>>>>
  /**
   * Create a Meurhhistorico.
   * @param {meurhhistoricoCreateArgs} args - Arguments to create a Meurhhistorico.
   * @example
   * // Create one Meurhhistorico
   * const Meurhhistorico = await prisma.meurhhistorico.create({
   *   data: {
   *     // ... data to create a Meurhhistorico
   *   }
   * })
   * 
  **/
  create<T extends meurhhistoricoCreateArgs>(
    args: Subset<T, meurhhistoricoCreateArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T>>>
  /**
   * Delete a Meurhhistorico.
   * @param {meurhhistoricoDeleteArgs} args - Arguments to delete one Meurhhistorico.
   * @example
   * // Delete one Meurhhistorico
   * const Meurhhistorico = await prisma.meurhhistorico.delete({
   *   where: {
   *     // ... filter to delete one Meurhhistorico
   *   }
   * })
   * 
  **/
  delete<T extends meurhhistoricoDeleteArgs>(
    args: Subset<T, meurhhistoricoDeleteArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T>>>
  /**
   * Update one Meurhhistorico.
   * @param {meurhhistoricoUpdateArgs} args - Arguments to update one Meurhhistorico.
   * @example
   * // Update one Meurhhistorico
   * const meurhhistorico = await prisma.meurhhistorico.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends meurhhistoricoUpdateArgs>(
    args: Subset<T, meurhhistoricoUpdateArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T>>>
  /**
   * Delete zero or more Meurhhistoricos.
   * @param {meurhhistoricoDeleteManyArgs} args - Arguments to filter Meurhhistoricos to delete.
   * @example
   * // Delete a few Meurhhistoricos
   * const { count } = await prisma.meurhhistorico.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends meurhhistoricoDeleteManyArgs>(
    args: Subset<T, meurhhistoricoDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Meurhhistoricos.
   * @param {meurhhistoricoUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Meurhhistoricos
   * const meurhhistorico = await prisma.meurhhistorico.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends meurhhistoricoUpdateManyArgs>(
    args: Subset<T, meurhhistoricoUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Meurhhistorico.
   * @param {meurhhistoricoUpsertArgs} args - Arguments to update or create a Meurhhistorico.
   * @example
   * // Update or create a Meurhhistorico
   * const meurhhistorico = await prisma.meurhhistorico.upsert({
   *   create: {
   *     // ... data to create a Meurhhistorico
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Meurhhistorico we want to update
   *   }
   * })
  **/
  upsert<T extends meurhhistoricoUpsertArgs>(
    args: Subset<T, meurhhistoricoUpsertArgs>
  ): CheckSelect<T, Prisma__meurhhistoricoClient<meurhhistorico>, Prisma__meurhhistoricoClient<meurhhistoricoGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManymeurhhistoricoArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMeurhhistoricoArgs>(args: Subset<T, AggregateMeurhhistoricoArgs>): Promise<GetMeurhhistoricoAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for meurhhistorico.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__meurhhistoricoClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  meurh<T extends meurhArgs = {}>(args?: Subset<T, meurhArgs>): CheckSelect<T, Prisma__meurhClient<meurh | null>, Prisma__meurhClient<meurhGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * meurhhistorico findOne
 */
export type FindOnemeurhhistoricoArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * Filter, which meurhhistorico to fetch.
  **/
  where: meurhhistoricoWhereUniqueInput
}


/**
 * meurhhistorico findFirst
 */
export type FindFirstmeurhhistoricoArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * Filter, which meurhhistorico to fetch.
  **/
  where?: meurhhistoricoWhereInput
  orderBy?: XOR<Enumerable<meurhhistoricoOrderByInput>, meurhhistoricoOrderByInput>
  cursor?: meurhhistoricoWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhhistoricoDistinctFieldEnum>
}


/**
 * meurhhistorico findMany
 */
export type FindManymeurhhistoricoArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * Filter, which meurhhistoricos to fetch.
  **/
  where?: meurhhistoricoWhereInput
  /**
   * Determine the order of the meurhhistoricos to fetch.
  **/
  orderBy?: XOR<Enumerable<meurhhistoricoOrderByInput>, meurhhistoricoOrderByInput>
  /**
   * Sets the position for listing meurhhistoricos.
  **/
  cursor?: meurhhistoricoWhereUniqueInput
  /**
   * The number of meurhhistoricos to fetch. If negative number, it will take meurhhistoricos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` meurhhistoricos.
  **/
  skip?: number
  distinct?: Enumerable<MeurhhistoricoDistinctFieldEnum>
}


/**
 * meurhhistorico create
 */
export type meurhhistoricoCreateArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * The data needed to create a meurhhistorico.
  **/
  data: meurhhistoricoCreateInput
}


/**
 * meurhhistorico update
 */
export type meurhhistoricoUpdateArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * The data needed to update a meurhhistorico.
  **/
  data: meurhhistoricoUpdateInput
  /**
   * Choose, which meurhhistorico to update.
  **/
  where: meurhhistoricoWhereUniqueInput
}


/**
 * meurhhistorico updateMany
 */
export type meurhhistoricoUpdateManyArgs = {
  data: meurhhistoricoUpdateManyMutationInput
  where?: meurhhistoricoWhereInput
}


/**
 * meurhhistorico upsert
 */
export type meurhhistoricoUpsertArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * The filter to search for the meurhhistorico to update in case it exists.
  **/
  where: meurhhistoricoWhereUniqueInput
  /**
   * In case the meurhhistorico found by the `where` argument doesn't exist, create a new meurhhistorico with this data.
  **/
  create: meurhhistoricoCreateInput
  /**
   * In case the meurhhistorico was found with the provided `where` argument, update it with this data.
  **/
  update: meurhhistoricoUpdateInput
}


/**
 * meurhhistorico delete
 */
export type meurhhistoricoDeleteArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
  /**
   * Filter which meurhhistorico to delete.
  **/
  where: meurhhistoricoWhereUniqueInput
}


/**
 * meurhhistorico deleteMany
 */
export type meurhhistoricoDeleteManyArgs = {
  where?: meurhhistoricoWhereInput
}


/**
 * meurhhistorico without action
 */
export type meurhhistoricoArgs = {
  /**
   * Select specific fields to fetch from the meurhhistorico
  **/
  select?: XOR<meurhhistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhhistoricoInclude, null>
}



/**
 * Model suporte
 */

export type suporte = {
  Id: number
  Protocolo: string | null
  CPF: string | null
  DtTicketAbertura: Date
  DtTicketFechamento: Date | null
  Assunto: string | null
  Msg: string | null
  Avaliacao: number | null
  Status: string | null
}


export type AggregateSuporte = {
  count: number
  avg: SuporteAvgAggregateOutputType | null
  sum: SuporteSumAggregateOutputType | null
  min: SuporteMinAggregateOutputType | null
  max: SuporteMaxAggregateOutputType | null
}

export type SuporteAvgAggregateOutputType = {
  Id: number
  Avaliacao: number | null
}

export type SuporteSumAggregateOutputType = {
  Id: number
  Avaliacao: number | null
}

export type SuporteMinAggregateOutputType = {
  Id: number
  Avaliacao: number | null
}

export type SuporteMaxAggregateOutputType = {
  Id: number
  Avaliacao: number | null
}


export type SuporteAvgAggregateInputType = {
  Id?: true
  Avaliacao?: true
}

export type SuporteSumAggregateInputType = {
  Id?: true
  Avaliacao?: true
}

export type SuporteMinAggregateInputType = {
  Id?: true
  Avaliacao?: true
}

export type SuporteMaxAggregateInputType = {
  Id?: true
  Avaliacao?: true
}

export type AggregateSuporteArgs = {
  where?: suporteWhereInput
  orderBy?: XOR<Enumerable<suporteOrderByInput>, suporteOrderByInput>
  cursor?: suporteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SuporteDistinctFieldEnum>
  count?: true
  avg?: SuporteAvgAggregateInputType
  sum?: SuporteSumAggregateInputType
  min?: SuporteMinAggregateInputType
  max?: SuporteMaxAggregateInputType
}

export type GetSuporteAggregateType<T extends AggregateSuporteArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetSuporteAggregateScalarType<T[P]>
}

export type GetSuporteAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof SuporteAvgAggregateOutputType ? SuporteAvgAggregateOutputType[P] : never
}
    
    

export type suporteSelect = {
  Id?: boolean
  Protocolo?: boolean
  CPF?: boolean
  DtTicketAbertura?: boolean
  DtTicketFechamento?: boolean
  Assunto?: boolean
  Msg?: boolean
  Avaliacao?: boolean
  Status?: boolean
  dados?: boolean | dadosArgs
  suportehistorico?: boolean | FindManysuportehistoricoArgs
}

export type suporteInclude = {
  dados?: boolean | dadosArgs
  suportehistorico?: boolean | FindManysuportehistoricoArgs
}

export type suporteGetPayload<
  S extends boolean | null | undefined | suporteArgs,
  U = keyof S
> = S extends true
  ? suporte
  : S extends undefined
  ? never
  : S extends suporteArgs | FindManysuporteArgs
  ? 'include' extends U
    ? suporte  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dados'
      ? dadosGetPayload<S['include'][P]> | null :
      P extends 'suportehistorico'
      ? Array<suportehistoricoGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof suporte ? suporte[P]
: 
      P extends 'dados'
      ? dadosGetPayload<S['select'][P]> | null :
      P extends 'suportehistorico'
      ? Array<suportehistoricoGetPayload<S['select'][P]>> : never
    }
  : suporte
: suporte


export interface suporteDelegate {
  /**
   * Find zero or one Suporte that matches the filter.
   * @param {FindOnesuporteArgs} args - Arguments to find a Suporte
   * @example
   * // Get one Suporte
   * const suporte = await prisma.suporte.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnesuporteArgs>(
    args: Subset<T, FindOnesuporteArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte | null>, Prisma__suporteClient<suporteGetPayload<T> | null>>
  /**
   * Find the first Suporte that matches the filter.
   * @param {FindFirstsuporteArgs} args - Arguments to find a Suporte
   * @example
   * // Get one Suporte
   * const suporte = await prisma.suporte.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstsuporteArgs>(
    args?: Subset<T, FindFirstsuporteArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte | null>, Prisma__suporteClient<suporteGetPayload<T> | null>>
  /**
   * Find zero or more Suportes that matches the filter.
   * @param {FindManysuporteArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Suportes
   * const suportes = await prisma.suporte.findMany()
   * 
   * // Get first 10 Suportes
   * const suportes = await prisma.suporte.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const suporteWithIdOnly = await prisma.suporte.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManysuporteArgs>(
    args?: Subset<T, FindManysuporteArgs>
  ): CheckSelect<T, Promise<Array<suporte>>, Promise<Array<suporteGetPayload<T>>>>
  /**
   * Create a Suporte.
   * @param {suporteCreateArgs} args - Arguments to create a Suporte.
   * @example
   * // Create one Suporte
   * const Suporte = await prisma.suporte.create({
   *   data: {
   *     // ... data to create a Suporte
   *   }
   * })
   * 
  **/
  create<T extends suporteCreateArgs>(
    args: Subset<T, suporteCreateArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte>, Prisma__suporteClient<suporteGetPayload<T>>>
  /**
   * Delete a Suporte.
   * @param {suporteDeleteArgs} args - Arguments to delete one Suporte.
   * @example
   * // Delete one Suporte
   * const Suporte = await prisma.suporte.delete({
   *   where: {
   *     // ... filter to delete one Suporte
   *   }
   * })
   * 
  **/
  delete<T extends suporteDeleteArgs>(
    args: Subset<T, suporteDeleteArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte>, Prisma__suporteClient<suporteGetPayload<T>>>
  /**
   * Update one Suporte.
   * @param {suporteUpdateArgs} args - Arguments to update one Suporte.
   * @example
   * // Update one Suporte
   * const suporte = await prisma.suporte.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends suporteUpdateArgs>(
    args: Subset<T, suporteUpdateArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte>, Prisma__suporteClient<suporteGetPayload<T>>>
  /**
   * Delete zero or more Suportes.
   * @param {suporteDeleteManyArgs} args - Arguments to filter Suportes to delete.
   * @example
   * // Delete a few Suportes
   * const { count } = await prisma.suporte.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends suporteDeleteManyArgs>(
    args: Subset<T, suporteDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Suportes.
   * @param {suporteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Suportes
   * const suporte = await prisma.suporte.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends suporteUpdateManyArgs>(
    args: Subset<T, suporteUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Suporte.
   * @param {suporteUpsertArgs} args - Arguments to update or create a Suporte.
   * @example
   * // Update or create a Suporte
   * const suporte = await prisma.suporte.upsert({
   *   create: {
   *     // ... data to create a Suporte
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Suporte we want to update
   *   }
   * })
  **/
  upsert<T extends suporteUpsertArgs>(
    args: Subset<T, suporteUpsertArgs>
  ): CheckSelect<T, Prisma__suporteClient<suporte>, Prisma__suporteClient<suporteGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManysuporteArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateSuporteArgs>(args: Subset<T, AggregateSuporteArgs>): Promise<GetSuporteAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for suporte.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__suporteClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dados<T extends dadosArgs = {}>(args?: Subset<T, dadosArgs>): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>;

  suportehistorico<T extends FindManysuportehistoricoArgs = {}>(args?: Subset<T, FindManysuportehistoricoArgs>): CheckSelect<T, Promise<Array<suportehistorico>>, Promise<Array<suportehistoricoGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * suporte findOne
 */
export type FindOnesuporteArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * Filter, which suporte to fetch.
  **/
  where: suporteWhereUniqueInput
}


/**
 * suporte findFirst
 */
export type FindFirstsuporteArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * Filter, which suporte to fetch.
  **/
  where?: suporteWhereInput
  orderBy?: XOR<Enumerable<suporteOrderByInput>, suporteOrderByInput>
  cursor?: suporteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SuporteDistinctFieldEnum>
}


/**
 * suporte findMany
 */
export type FindManysuporteArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * Filter, which suportes to fetch.
  **/
  where?: suporteWhereInput
  /**
   * Determine the order of the suportes to fetch.
  **/
  orderBy?: XOR<Enumerable<suporteOrderByInput>, suporteOrderByInput>
  /**
   * Sets the position for listing suportes.
  **/
  cursor?: suporteWhereUniqueInput
  /**
   * The number of suportes to fetch. If negative number, it will take suportes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` suportes.
  **/
  skip?: number
  distinct?: Enumerable<SuporteDistinctFieldEnum>
}


/**
 * suporte create
 */
export type suporteCreateArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * The data needed to create a suporte.
  **/
  data: suporteCreateInput
}


/**
 * suporte update
 */
export type suporteUpdateArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * The data needed to update a suporte.
  **/
  data: suporteUpdateInput
  /**
   * Choose, which suporte to update.
  **/
  where: suporteWhereUniqueInput
}


/**
 * suporte updateMany
 */
export type suporteUpdateManyArgs = {
  data: suporteUpdateManyMutationInput
  where?: suporteWhereInput
}


/**
 * suporte upsert
 */
export type suporteUpsertArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * The filter to search for the suporte to update in case it exists.
  **/
  where: suporteWhereUniqueInput
  /**
   * In case the suporte found by the `where` argument doesn't exist, create a new suporte with this data.
  **/
  create: suporteCreateInput
  /**
   * In case the suporte was found with the provided `where` argument, update it with this data.
  **/
  update: suporteUpdateInput
}


/**
 * suporte delete
 */
export type suporteDeleteArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
  /**
   * Filter which suporte to delete.
  **/
  where: suporteWhereUniqueInput
}


/**
 * suporte deleteMany
 */
export type suporteDeleteManyArgs = {
  where?: suporteWhereInput
}


/**
 * suporte without action
 */
export type suporteArgs = {
  /**
   * Select specific fields to fetch from the suporte
  **/
  select?: XOR<suporteSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suporteInclude, null>
}



/**
 * Model suportehistorico
 */

export type suportehistorico = {
  Id: number
  IdSuporte: number | null
  StatusAtual: string | null
  StatusNovo: string | null
  DtAlteracao: Date | null
  Msg: string | null
}


export type AggregateSuportehistorico = {
  count: number
  avg: SuportehistoricoAvgAggregateOutputType | null
  sum: SuportehistoricoSumAggregateOutputType | null
  min: SuportehistoricoMinAggregateOutputType | null
  max: SuportehistoricoMaxAggregateOutputType | null
}

export type SuportehistoricoAvgAggregateOutputType = {
  Id: number
  IdSuporte: number | null
}

export type SuportehistoricoSumAggregateOutputType = {
  Id: number
  IdSuporte: number | null
}

export type SuportehistoricoMinAggregateOutputType = {
  Id: number
  IdSuporte: number | null
}

export type SuportehistoricoMaxAggregateOutputType = {
  Id: number
  IdSuporte: number | null
}


export type SuportehistoricoAvgAggregateInputType = {
  Id?: true
  IdSuporte?: true
}

export type SuportehistoricoSumAggregateInputType = {
  Id?: true
  IdSuporte?: true
}

export type SuportehistoricoMinAggregateInputType = {
  Id?: true
  IdSuporte?: true
}

export type SuportehistoricoMaxAggregateInputType = {
  Id?: true
  IdSuporte?: true
}

export type AggregateSuportehistoricoArgs = {
  where?: suportehistoricoWhereInput
  orderBy?: XOR<Enumerable<suportehistoricoOrderByInput>, suportehistoricoOrderByInput>
  cursor?: suportehistoricoWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SuportehistoricoDistinctFieldEnum>
  count?: true
  avg?: SuportehistoricoAvgAggregateInputType
  sum?: SuportehistoricoSumAggregateInputType
  min?: SuportehistoricoMinAggregateInputType
  max?: SuportehistoricoMaxAggregateInputType
}

export type GetSuportehistoricoAggregateType<T extends AggregateSuportehistoricoArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetSuportehistoricoAggregateScalarType<T[P]>
}

export type GetSuportehistoricoAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof SuportehistoricoAvgAggregateOutputType ? SuportehistoricoAvgAggregateOutputType[P] : never
}
    
    

export type suportehistoricoSelect = {
  Id?: boolean
  IdSuporte?: boolean
  StatusAtual?: boolean
  StatusNovo?: boolean
  DtAlteracao?: boolean
  Msg?: boolean
  suporte?: boolean | suporteArgs
}

export type suportehistoricoInclude = {
  suporte?: boolean | suporteArgs
}

export type suportehistoricoGetPayload<
  S extends boolean | null | undefined | suportehistoricoArgs,
  U = keyof S
> = S extends true
  ? suportehistorico
  : S extends undefined
  ? never
  : S extends suportehistoricoArgs | FindManysuportehistoricoArgs
  ? 'include' extends U
    ? suportehistorico  & {
      [P in TrueKeys<S['include']>]:
      P extends 'suporte'
      ? suporteGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof suportehistorico ? suportehistorico[P]
: 
      P extends 'suporte'
      ? suporteGetPayload<S['select'][P]> | null : never
    }
  : suportehistorico
: suportehistorico


export interface suportehistoricoDelegate {
  /**
   * Find zero or one Suportehistorico that matches the filter.
   * @param {FindOnesuportehistoricoArgs} args - Arguments to find a Suportehistorico
   * @example
   * // Get one Suportehistorico
   * const suportehistorico = await prisma.suportehistorico.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnesuportehistoricoArgs>(
    args: Subset<T, FindOnesuportehistoricoArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico | null>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T> | null>>
  /**
   * Find the first Suportehistorico that matches the filter.
   * @param {FindFirstsuportehistoricoArgs} args - Arguments to find a Suportehistorico
   * @example
   * // Get one Suportehistorico
   * const suportehistorico = await prisma.suportehistorico.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstsuportehistoricoArgs>(
    args?: Subset<T, FindFirstsuportehistoricoArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico | null>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T> | null>>
  /**
   * Find zero or more Suportehistoricos that matches the filter.
   * @param {FindManysuportehistoricoArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Suportehistoricos
   * const suportehistoricos = await prisma.suportehistorico.findMany()
   * 
   * // Get first 10 Suportehistoricos
   * const suportehistoricos = await prisma.suportehistorico.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const suportehistoricoWithIdOnly = await prisma.suportehistorico.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManysuportehistoricoArgs>(
    args?: Subset<T, FindManysuportehistoricoArgs>
  ): CheckSelect<T, Promise<Array<suportehistorico>>, Promise<Array<suportehistoricoGetPayload<T>>>>
  /**
   * Create a Suportehistorico.
   * @param {suportehistoricoCreateArgs} args - Arguments to create a Suportehistorico.
   * @example
   * // Create one Suportehistorico
   * const Suportehistorico = await prisma.suportehistorico.create({
   *   data: {
   *     // ... data to create a Suportehistorico
   *   }
   * })
   * 
  **/
  create<T extends suportehistoricoCreateArgs>(
    args: Subset<T, suportehistoricoCreateArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T>>>
  /**
   * Delete a Suportehistorico.
   * @param {suportehistoricoDeleteArgs} args - Arguments to delete one Suportehistorico.
   * @example
   * // Delete one Suportehistorico
   * const Suportehistorico = await prisma.suportehistorico.delete({
   *   where: {
   *     // ... filter to delete one Suportehistorico
   *   }
   * })
   * 
  **/
  delete<T extends suportehistoricoDeleteArgs>(
    args: Subset<T, suportehistoricoDeleteArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T>>>
  /**
   * Update one Suportehistorico.
   * @param {suportehistoricoUpdateArgs} args - Arguments to update one Suportehistorico.
   * @example
   * // Update one Suportehistorico
   * const suportehistorico = await prisma.suportehistorico.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends suportehistoricoUpdateArgs>(
    args: Subset<T, suportehistoricoUpdateArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T>>>
  /**
   * Delete zero or more Suportehistoricos.
   * @param {suportehistoricoDeleteManyArgs} args - Arguments to filter Suportehistoricos to delete.
   * @example
   * // Delete a few Suportehistoricos
   * const { count } = await prisma.suportehistorico.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends suportehistoricoDeleteManyArgs>(
    args: Subset<T, suportehistoricoDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Suportehistoricos.
   * @param {suportehistoricoUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Suportehistoricos
   * const suportehistorico = await prisma.suportehistorico.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends suportehistoricoUpdateManyArgs>(
    args: Subset<T, suportehistoricoUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Suportehistorico.
   * @param {suportehistoricoUpsertArgs} args - Arguments to update or create a Suportehistorico.
   * @example
   * // Update or create a Suportehistorico
   * const suportehistorico = await prisma.suportehistorico.upsert({
   *   create: {
   *     // ... data to create a Suportehistorico
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Suportehistorico we want to update
   *   }
   * })
  **/
  upsert<T extends suportehistoricoUpsertArgs>(
    args: Subset<T, suportehistoricoUpsertArgs>
  ): CheckSelect<T, Prisma__suportehistoricoClient<suportehistorico>, Prisma__suportehistoricoClient<suportehistoricoGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManysuportehistoricoArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateSuportehistoricoArgs>(args: Subset<T, AggregateSuportehistoricoArgs>): Promise<GetSuportehistoricoAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for suportehistorico.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__suportehistoricoClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  suporte<T extends suporteArgs = {}>(args?: Subset<T, suporteArgs>): CheckSelect<T, Prisma__suporteClient<suporte | null>, Prisma__suporteClient<suporteGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * suportehistorico findOne
 */
export type FindOnesuportehistoricoArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * Filter, which suportehistorico to fetch.
  **/
  where: suportehistoricoWhereUniqueInput
}


/**
 * suportehistorico findFirst
 */
export type FindFirstsuportehistoricoArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * Filter, which suportehistorico to fetch.
  **/
  where?: suportehistoricoWhereInput
  orderBy?: XOR<Enumerable<suportehistoricoOrderByInput>, suportehistoricoOrderByInput>
  cursor?: suportehistoricoWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SuportehistoricoDistinctFieldEnum>
}


/**
 * suportehistorico findMany
 */
export type FindManysuportehistoricoArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * Filter, which suportehistoricos to fetch.
  **/
  where?: suportehistoricoWhereInput
  /**
   * Determine the order of the suportehistoricos to fetch.
  **/
  orderBy?: XOR<Enumerable<suportehistoricoOrderByInput>, suportehistoricoOrderByInput>
  /**
   * Sets the position for listing suportehistoricos.
  **/
  cursor?: suportehistoricoWhereUniqueInput
  /**
   * The number of suportehistoricos to fetch. If negative number, it will take suportehistoricos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` suportehistoricos.
  **/
  skip?: number
  distinct?: Enumerable<SuportehistoricoDistinctFieldEnum>
}


/**
 * suportehistorico create
 */
export type suportehistoricoCreateArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * The data needed to create a suportehistorico.
  **/
  data: suportehistoricoCreateInput
}


/**
 * suportehistorico update
 */
export type suportehistoricoUpdateArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * The data needed to update a suportehistorico.
  **/
  data: suportehistoricoUpdateInput
  /**
   * Choose, which suportehistorico to update.
  **/
  where: suportehistoricoWhereUniqueInput
}


/**
 * suportehistorico updateMany
 */
export type suportehistoricoUpdateManyArgs = {
  data: suportehistoricoUpdateManyMutationInput
  where?: suportehistoricoWhereInput
}


/**
 * suportehistorico upsert
 */
export type suportehistoricoUpsertArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * The filter to search for the suportehistorico to update in case it exists.
  **/
  where: suportehistoricoWhereUniqueInput
  /**
   * In case the suportehistorico found by the `where` argument doesn't exist, create a new suportehistorico with this data.
  **/
  create: suportehistoricoCreateInput
  /**
   * In case the suportehistorico was found with the provided `where` argument, update it with this data.
  **/
  update: suportehistoricoUpdateInput
}


/**
 * suportehistorico delete
 */
export type suportehistoricoDeleteArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
  /**
   * Filter which suportehistorico to delete.
  **/
  where: suportehistoricoWhereUniqueInput
}


/**
 * suportehistorico deleteMany
 */
export type suportehistoricoDeleteManyArgs = {
  where?: suportehistoricoWhereInput
}


/**
 * suportehistorico without action
 */
export type suportehistoricoArgs = {
  /**
   * Select specific fields to fetch from the suportehistorico
  **/
  select?: XOR<suportehistoricoSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<suportehistoricoInclude, null>
}



/**
 * Model meurhrespostas
 */

export type meurhrespostas = {
  Id: number
  IdMeuRh: number | null
  DtResposta: Date | null
  CPF: string | null
  Msg: string | null
}


export type AggregateMeurhrespostas = {
  count: number
  avg: MeurhrespostasAvgAggregateOutputType | null
  sum: MeurhrespostasSumAggregateOutputType | null
  min: MeurhrespostasMinAggregateOutputType | null
  max: MeurhrespostasMaxAggregateOutputType | null
}

export type MeurhrespostasAvgAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhrespostasSumAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhrespostasMinAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}

export type MeurhrespostasMaxAggregateOutputType = {
  Id: number
  IdMeuRh: number | null
}


export type MeurhrespostasAvgAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhrespostasSumAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhrespostasMinAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type MeurhrespostasMaxAggregateInputType = {
  Id?: true
  IdMeuRh?: true
}

export type AggregateMeurhrespostasArgs = {
  where?: meurhrespostasWhereInput
  orderBy?: XOR<Enumerable<meurhrespostasOrderByInput>, meurhrespostasOrderByInput>
  cursor?: meurhrespostasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhrespostasDistinctFieldEnum>
  count?: true
  avg?: MeurhrespostasAvgAggregateInputType
  sum?: MeurhrespostasSumAggregateInputType
  min?: MeurhrespostasMinAggregateInputType
  max?: MeurhrespostasMaxAggregateInputType
}

export type GetMeurhrespostasAggregateType<T extends AggregateMeurhrespostasArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetMeurhrespostasAggregateScalarType<T[P]>
}

export type GetMeurhrespostasAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof MeurhrespostasAvgAggregateOutputType ? MeurhrespostasAvgAggregateOutputType[P] : never
}
    
    

export type meurhrespostasSelect = {
  Id?: boolean
  IdMeuRh?: boolean
  DtResposta?: boolean
  CPF?: boolean
  Msg?: boolean
  dados?: boolean | dadosArgs
}

export type meurhrespostasInclude = {
  dados?: boolean | dadosArgs
}

export type meurhrespostasGetPayload<
  S extends boolean | null | undefined | meurhrespostasArgs,
  U = keyof S
> = S extends true
  ? meurhrespostas
  : S extends undefined
  ? never
  : S extends meurhrespostasArgs | FindManymeurhrespostasArgs
  ? 'include' extends U
    ? meurhrespostas  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dados'
      ? dadosGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof meurhrespostas ? meurhrespostas[P]
: 
      P extends 'dados'
      ? dadosGetPayload<S['select'][P]> | null : never
    }
  : meurhrespostas
: meurhrespostas


export interface meurhrespostasDelegate {
  /**
   * Find zero or one Meurhrespostas that matches the filter.
   * @param {FindOnemeurhrespostasArgs} args - Arguments to find a Meurhrespostas
   * @example
   * // Get one Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnemeurhrespostasArgs>(
    args: Subset<T, FindOnemeurhrespostasArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas | null>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T> | null>>
  /**
   * Find the first Meurhrespostas that matches the filter.
   * @param {FindFirstmeurhrespostasArgs} args - Arguments to find a Meurhrespostas
   * @example
   * // Get one Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstmeurhrespostasArgs>(
    args?: Subset<T, FindFirstmeurhrespostasArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas | null>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T> | null>>
  /**
   * Find zero or more Meurhrespostas that matches the filter.
   * @param {FindManymeurhrespostasArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.findMany()
   * 
   * // Get first 10 Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const meurhrespostasWithIdOnly = await prisma.meurhrespostas.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManymeurhrespostasArgs>(
    args?: Subset<T, FindManymeurhrespostasArgs>
  ): CheckSelect<T, Promise<Array<meurhrespostas>>, Promise<Array<meurhrespostasGetPayload<T>>>>
  /**
   * Create a Meurhrespostas.
   * @param {meurhrespostasCreateArgs} args - Arguments to create a Meurhrespostas.
   * @example
   * // Create one Meurhrespostas
   * const Meurhrespostas = await prisma.meurhrespostas.create({
   *   data: {
   *     // ... data to create a Meurhrespostas
   *   }
   * })
   * 
  **/
  create<T extends meurhrespostasCreateArgs>(
    args: Subset<T, meurhrespostasCreateArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T>>>
  /**
   * Delete a Meurhrespostas.
   * @param {meurhrespostasDeleteArgs} args - Arguments to delete one Meurhrespostas.
   * @example
   * // Delete one Meurhrespostas
   * const Meurhrespostas = await prisma.meurhrespostas.delete({
   *   where: {
   *     // ... filter to delete one Meurhrespostas
   *   }
   * })
   * 
  **/
  delete<T extends meurhrespostasDeleteArgs>(
    args: Subset<T, meurhrespostasDeleteArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T>>>
  /**
   * Update one Meurhrespostas.
   * @param {meurhrespostasUpdateArgs} args - Arguments to update one Meurhrespostas.
   * @example
   * // Update one Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends meurhrespostasUpdateArgs>(
    args: Subset<T, meurhrespostasUpdateArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T>>>
  /**
   * Delete zero or more Meurhrespostas.
   * @param {meurhrespostasDeleteManyArgs} args - Arguments to filter Meurhrespostas to delete.
   * @example
   * // Delete a few Meurhrespostas
   * const { count } = await prisma.meurhrespostas.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends meurhrespostasDeleteManyArgs>(
    args: Subset<T, meurhrespostasDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Meurhrespostas.
   * @param {meurhrespostasUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends meurhrespostasUpdateManyArgs>(
    args: Subset<T, meurhrespostasUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Meurhrespostas.
   * @param {meurhrespostasUpsertArgs} args - Arguments to update or create a Meurhrespostas.
   * @example
   * // Update or create a Meurhrespostas
   * const meurhrespostas = await prisma.meurhrespostas.upsert({
   *   create: {
   *     // ... data to create a Meurhrespostas
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Meurhrespostas we want to update
   *   }
   * })
  **/
  upsert<T extends meurhrespostasUpsertArgs>(
    args: Subset<T, meurhrespostasUpsertArgs>
  ): CheckSelect<T, Prisma__meurhrespostasClient<meurhrespostas>, Prisma__meurhrespostasClient<meurhrespostasGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManymeurhrespostasArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMeurhrespostasArgs>(args: Subset<T, AggregateMeurhrespostasArgs>): Promise<GetMeurhrespostasAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for meurhrespostas.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__meurhrespostasClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dados<T extends dadosArgs = {}>(args?: Subset<T, dadosArgs>): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * meurhrespostas findOne
 */
export type FindOnemeurhrespostasArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * Filter, which meurhrespostas to fetch.
  **/
  where: meurhrespostasWhereUniqueInput
}


/**
 * meurhrespostas findFirst
 */
export type FindFirstmeurhrespostasArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * Filter, which meurhrespostas to fetch.
  **/
  where?: meurhrespostasWhereInput
  orderBy?: XOR<Enumerable<meurhrespostasOrderByInput>, meurhrespostasOrderByInput>
  cursor?: meurhrespostasWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MeurhrespostasDistinctFieldEnum>
}


/**
 * meurhrespostas findMany
 */
export type FindManymeurhrespostasArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * Filter, which meurhrespostas to fetch.
  **/
  where?: meurhrespostasWhereInput
  /**
   * Determine the order of the meurhrespostas to fetch.
  **/
  orderBy?: XOR<Enumerable<meurhrespostasOrderByInput>, meurhrespostasOrderByInput>
  /**
   * Sets the position for listing meurhrespostas.
  **/
  cursor?: meurhrespostasWhereUniqueInput
  /**
   * The number of meurhrespostas to fetch. If negative number, it will take meurhrespostas before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` meurhrespostas.
  **/
  skip?: number
  distinct?: Enumerable<MeurhrespostasDistinctFieldEnum>
}


/**
 * meurhrespostas create
 */
export type meurhrespostasCreateArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * The data needed to create a meurhrespostas.
  **/
  data: meurhrespostasCreateInput
}


/**
 * meurhrespostas update
 */
export type meurhrespostasUpdateArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * The data needed to update a meurhrespostas.
  **/
  data: meurhrespostasUpdateInput
  /**
   * Choose, which meurhrespostas to update.
  **/
  where: meurhrespostasWhereUniqueInput
}


/**
 * meurhrespostas updateMany
 */
export type meurhrespostasUpdateManyArgs = {
  data: meurhrespostasUpdateManyMutationInput
  where?: meurhrespostasWhereInput
}


/**
 * meurhrespostas upsert
 */
export type meurhrespostasUpsertArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * The filter to search for the meurhrespostas to update in case it exists.
  **/
  where: meurhrespostasWhereUniqueInput
  /**
   * In case the meurhrespostas found by the `where` argument doesn't exist, create a new meurhrespostas with this data.
  **/
  create: meurhrespostasCreateInput
  /**
   * In case the meurhrespostas was found with the provided `where` argument, update it with this data.
  **/
  update: meurhrespostasUpdateInput
}


/**
 * meurhrespostas delete
 */
export type meurhrespostasDeleteArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
  /**
   * Filter which meurhrespostas to delete.
  **/
  where: meurhrespostasWhereUniqueInput
}


/**
 * meurhrespostas deleteMany
 */
export type meurhrespostasDeleteManyArgs = {
  where?: meurhrespostasWhereInput
}


/**
 * meurhrespostas without action
 */
export type meurhrespostasArgs = {
  /**
   * Select specific fields to fetch from the meurhrespostas
  **/
  select?: XOR<meurhrespostasSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<meurhrespostasInclude, null>
}



/**
 * Model notification
 */

export type notification = {
  Id: number
  CPF: string | null
  Msg: string | null
  lido: boolean | null
  created_at: Date
}


export type AggregateNotification = {
  count: number
  avg: NotificationAvgAggregateOutputType | null
  sum: NotificationSumAggregateOutputType | null
  min: NotificationMinAggregateOutputType | null
  max: NotificationMaxAggregateOutputType | null
}

export type NotificationAvgAggregateOutputType = {
  Id: number
}

export type NotificationSumAggregateOutputType = {
  Id: number
}

export type NotificationMinAggregateOutputType = {
  Id: number
}

export type NotificationMaxAggregateOutputType = {
  Id: number
}


export type NotificationAvgAggregateInputType = {
  Id?: true
}

export type NotificationSumAggregateInputType = {
  Id?: true
}

export type NotificationMinAggregateInputType = {
  Id?: true
}

export type NotificationMaxAggregateInputType = {
  Id?: true
}

export type AggregateNotificationArgs = {
  where?: notificationWhereInput
  orderBy?: XOR<Enumerable<notificationOrderByInput>, notificationOrderByInput>
  cursor?: notificationWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NotificationDistinctFieldEnum>
  count?: true
  avg?: NotificationAvgAggregateInputType
  sum?: NotificationSumAggregateInputType
  min?: NotificationMinAggregateInputType
  max?: NotificationMaxAggregateInputType
}

export type GetNotificationAggregateType<T extends AggregateNotificationArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetNotificationAggregateScalarType<T[P]>
}

export type GetNotificationAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof NotificationAvgAggregateOutputType ? NotificationAvgAggregateOutputType[P] : never
}
    
    

export type notificationSelect = {
  Id?: boolean
  CPF?: boolean
  Msg?: boolean
  lido?: boolean
  created_at?: boolean
}

export type notificationGetPayload<
  S extends boolean | null | undefined | notificationArgs,
  U = keyof S
> = S extends true
  ? notification
  : S extends undefined
  ? never
  : S extends notificationArgs | FindManynotificationArgs
  ? 'include' extends U
    ? notification 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof notification ? notification[P]
: 
 never
    }
  : notification
: notification


export interface notificationDelegate {
  /**
   * Find zero or one Notification that matches the filter.
   * @param {FindOnenotificationArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnenotificationArgs>(
    args: Subset<T, FindOnenotificationArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification | null>, Prisma__notificationClient<notificationGetPayload<T> | null>>
  /**
   * Find the first Notification that matches the filter.
   * @param {FindFirstnotificationArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstnotificationArgs>(
    args?: Subset<T, FindFirstnotificationArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification | null>, Prisma__notificationClient<notificationGetPayload<T> | null>>
  /**
   * Find zero or more Notifications that matches the filter.
   * @param {FindManynotificationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Notifications
   * const notifications = await prisma.notification.findMany()
   * 
   * // Get first 10 Notifications
   * const notifications = await prisma.notification.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const notificationWithIdOnly = await prisma.notification.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManynotificationArgs>(
    args?: Subset<T, FindManynotificationArgs>
  ): CheckSelect<T, Promise<Array<notification>>, Promise<Array<notificationGetPayload<T>>>>
  /**
   * Create a Notification.
   * @param {notificationCreateArgs} args - Arguments to create a Notification.
   * @example
   * // Create one Notification
   * const Notification = await prisma.notification.create({
   *   data: {
   *     // ... data to create a Notification
   *   }
   * })
   * 
  **/
  create<T extends notificationCreateArgs>(
    args: Subset<T, notificationCreateArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
  /**
   * Delete a Notification.
   * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
   * @example
   * // Delete one Notification
   * const Notification = await prisma.notification.delete({
   *   where: {
   *     // ... filter to delete one Notification
   *   }
   * })
   * 
  **/
  delete<T extends notificationDeleteArgs>(
    args: Subset<T, notificationDeleteArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
  /**
   * Update one Notification.
   * @param {notificationUpdateArgs} args - Arguments to update one Notification.
   * @example
   * // Update one Notification
   * const notification = await prisma.notification.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends notificationUpdateArgs>(
    args: Subset<T, notificationUpdateArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
  /**
   * Delete zero or more Notifications.
   * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
   * @example
   * // Delete a few Notifications
   * const { count } = await prisma.notification.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends notificationDeleteManyArgs>(
    args: Subset<T, notificationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Notifications.
   * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Notifications
   * const notification = await prisma.notification.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends notificationUpdateManyArgs>(
    args: Subset<T, notificationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Notification.
   * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
   * @example
   * // Update or create a Notification
   * const notification = await prisma.notification.upsert({
   *   create: {
   *     // ... data to create a Notification
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Notification we want to update
   *   }
   * })
  **/
  upsert<T extends notificationUpsertArgs>(
    args: Subset<T, notificationUpsertArgs>
  ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManynotificationArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateNotificationArgs>(args: Subset<T, AggregateNotificationArgs>): Promise<GetNotificationAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for notification.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__notificationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * notification findOne
 */
export type FindOnenotificationArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * Filter, which notification to fetch.
  **/
  where: notificationWhereUniqueInput
}


/**
 * notification findFirst
 */
export type FindFirstnotificationArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * Filter, which notification to fetch.
  **/
  where?: notificationWhereInput
  orderBy?: XOR<Enumerable<notificationOrderByInput>, notificationOrderByInput>
  cursor?: notificationWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NotificationDistinctFieldEnum>
}


/**
 * notification findMany
 */
export type FindManynotificationArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * Filter, which notifications to fetch.
  **/
  where?: notificationWhereInput
  /**
   * Determine the order of the notifications to fetch.
  **/
  orderBy?: XOR<Enumerable<notificationOrderByInput>, notificationOrderByInput>
  /**
   * Sets the position for listing notifications.
  **/
  cursor?: notificationWhereUniqueInput
  /**
   * The number of notifications to fetch. If negative number, it will take notifications before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` notifications.
  **/
  skip?: number
  distinct?: Enumerable<NotificationDistinctFieldEnum>
}


/**
 * notification create
 */
export type notificationCreateArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * The data needed to create a notification.
  **/
  data: notificationCreateInput
}


/**
 * notification update
 */
export type notificationUpdateArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * The data needed to update a notification.
  **/
  data: notificationUpdateInput
  /**
   * Choose, which notification to update.
  **/
  where: notificationWhereUniqueInput
}


/**
 * notification updateMany
 */
export type notificationUpdateManyArgs = {
  data: notificationUpdateManyMutationInput
  where?: notificationWhereInput
}


/**
 * notification upsert
 */
export type notificationUpsertArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * The filter to search for the notification to update in case it exists.
  **/
  where: notificationWhereUniqueInput
  /**
   * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
  **/
  create: notificationCreateInput
  /**
   * In case the notification was found with the provided `where` argument, update it with this data.
  **/
  update: notificationUpdateInput
}


/**
 * notification delete
 */
export type notificationDeleteArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
  /**
   * Filter which notification to delete.
  **/
  where: notificationWhereUniqueInput
}


/**
 * notification deleteMany
 */
export type notificationDeleteManyArgs = {
  where?: notificationWhereInput
}


/**
 * notification without action
 */
export type notificationArgs = {
  /**
   * Select specific fields to fetch from the notification
  **/
  select?: XOR<notificationSelect, null>
}



/**
 * Model pedidos
 */

export type pedidos = {
  Id: number
  IdEmpresa: number | null
  Competencia: string | null
  DtInicialFolgas: Date | null
  DtFinalFolgas: Date | null
  DtInicialFaltas: Date | null
  DtFinalFaltas: Date | null
  Status: string | null
}


export type AggregatePedidos = {
  count: number
  avg: PedidosAvgAggregateOutputType | null
  sum: PedidosSumAggregateOutputType | null
  min: PedidosMinAggregateOutputType | null
  max: PedidosMaxAggregateOutputType | null
}

export type PedidosAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type PedidosSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type PedidosMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}

export type PedidosMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
}


export type PedidosAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type PedidosSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type PedidosMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type PedidosMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
}

export type AggregatePedidosArgs = {
  where?: pedidosWhereInput
  orderBy?: XOR<Enumerable<pedidosOrderByInput>, pedidosOrderByInput>
  cursor?: pedidosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PedidosDistinctFieldEnum>
  count?: true
  avg?: PedidosAvgAggregateInputType
  sum?: PedidosSumAggregateInputType
  min?: PedidosMinAggregateInputType
  max?: PedidosMaxAggregateInputType
}

export type GetPedidosAggregateType<T extends AggregatePedidosArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetPedidosAggregateScalarType<T[P]>
}

export type GetPedidosAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof PedidosAvgAggregateOutputType ? PedidosAvgAggregateOutputType[P] : never
}
    
    

export type pedidosSelect = {
  Id?: boolean
  IdEmpresa?: boolean
  Competencia?: boolean
  DtInicialFolgas?: boolean
  DtFinalFolgas?: boolean
  DtInicialFaltas?: boolean
  DtFinalFaltas?: boolean
  Status?: boolean
  empresas?: boolean | empresasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
}

export type pedidosInclude = {
  empresas?: boolean | empresasArgs
  detalhepedidos_old?: boolean | FindManydetalhepedidos_oldArgs
}

export type pedidosGetPayload<
  S extends boolean | null | undefined | pedidosArgs,
  U = keyof S
> = S extends true
  ? pedidos
  : S extends undefined
  ? never
  : S extends pedidosArgs | FindManypedidosArgs
  ? 'include' extends U
    ? pedidos  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof pedidos ? pedidos[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null :
      P extends 'detalhepedidos_old'
      ? Array<detalhepedidos_oldGetPayload<S['select'][P]>> : never
    }
  : pedidos
: pedidos


export interface pedidosDelegate {
  /**
   * Find zero or one Pedidos that matches the filter.
   * @param {FindOnepedidosArgs} args - Arguments to find a Pedidos
   * @example
   * // Get one Pedidos
   * const pedidos = await prisma.pedidos.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnepedidosArgs>(
    args: Subset<T, FindOnepedidosArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos | null>, Prisma__pedidosClient<pedidosGetPayload<T> | null>>
  /**
   * Find the first Pedidos that matches the filter.
   * @param {FindFirstpedidosArgs} args - Arguments to find a Pedidos
   * @example
   * // Get one Pedidos
   * const pedidos = await prisma.pedidos.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstpedidosArgs>(
    args?: Subset<T, FindFirstpedidosArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos | null>, Prisma__pedidosClient<pedidosGetPayload<T> | null>>
  /**
   * Find zero or more Pedidos that matches the filter.
   * @param {FindManypedidosArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Pedidos
   * const pedidos = await prisma.pedidos.findMany()
   * 
   * // Get first 10 Pedidos
   * const pedidos = await prisma.pedidos.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const pedidosWithIdOnly = await prisma.pedidos.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManypedidosArgs>(
    args?: Subset<T, FindManypedidosArgs>
  ): CheckSelect<T, Promise<Array<pedidos>>, Promise<Array<pedidosGetPayload<T>>>>
  /**
   * Create a Pedidos.
   * @param {pedidosCreateArgs} args - Arguments to create a Pedidos.
   * @example
   * // Create one Pedidos
   * const Pedidos = await prisma.pedidos.create({
   *   data: {
   *     // ... data to create a Pedidos
   *   }
   * })
   * 
  **/
  create<T extends pedidosCreateArgs>(
    args: Subset<T, pedidosCreateArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos>, Prisma__pedidosClient<pedidosGetPayload<T>>>
  /**
   * Delete a Pedidos.
   * @param {pedidosDeleteArgs} args - Arguments to delete one Pedidos.
   * @example
   * // Delete one Pedidos
   * const Pedidos = await prisma.pedidos.delete({
   *   where: {
   *     // ... filter to delete one Pedidos
   *   }
   * })
   * 
  **/
  delete<T extends pedidosDeleteArgs>(
    args: Subset<T, pedidosDeleteArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos>, Prisma__pedidosClient<pedidosGetPayload<T>>>
  /**
   * Update one Pedidos.
   * @param {pedidosUpdateArgs} args - Arguments to update one Pedidos.
   * @example
   * // Update one Pedidos
   * const pedidos = await prisma.pedidos.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends pedidosUpdateArgs>(
    args: Subset<T, pedidosUpdateArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos>, Prisma__pedidosClient<pedidosGetPayload<T>>>
  /**
   * Delete zero or more Pedidos.
   * @param {pedidosDeleteManyArgs} args - Arguments to filter Pedidos to delete.
   * @example
   * // Delete a few Pedidos
   * const { count } = await prisma.pedidos.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends pedidosDeleteManyArgs>(
    args: Subset<T, pedidosDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Pedidos.
   * @param {pedidosUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Pedidos
   * const pedidos = await prisma.pedidos.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends pedidosUpdateManyArgs>(
    args: Subset<T, pedidosUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Pedidos.
   * @param {pedidosUpsertArgs} args - Arguments to update or create a Pedidos.
   * @example
   * // Update or create a Pedidos
   * const pedidos = await prisma.pedidos.upsert({
   *   create: {
   *     // ... data to create a Pedidos
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Pedidos we want to update
   *   }
   * })
  **/
  upsert<T extends pedidosUpsertArgs>(
    args: Subset<T, pedidosUpsertArgs>
  ): CheckSelect<T, Prisma__pedidosClient<pedidos>, Prisma__pedidosClient<pedidosGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManypedidosArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregatePedidosArgs>(args: Subset<T, AggregatePedidosArgs>): Promise<GetPedidosAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for pedidos.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__pedidosClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  detalhepedidos_old<T extends FindManydetalhepedidos_oldArgs = {}>(args?: Subset<T, FindManydetalhepedidos_oldArgs>): CheckSelect<T, Promise<Array<detalhepedidos_old>>, Promise<Array<detalhepedidos_oldGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * pedidos findOne
 */
export type FindOnepedidosArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * Filter, which pedidos to fetch.
  **/
  where: pedidosWhereUniqueInput
}


/**
 * pedidos findFirst
 */
export type FindFirstpedidosArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * Filter, which pedidos to fetch.
  **/
  where?: pedidosWhereInput
  orderBy?: XOR<Enumerable<pedidosOrderByInput>, pedidosOrderByInput>
  cursor?: pedidosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PedidosDistinctFieldEnum>
}


/**
 * pedidos findMany
 */
export type FindManypedidosArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * Filter, which pedidos to fetch.
  **/
  where?: pedidosWhereInput
  /**
   * Determine the order of the pedidos to fetch.
  **/
  orderBy?: XOR<Enumerable<pedidosOrderByInput>, pedidosOrderByInput>
  /**
   * Sets the position for listing pedidos.
  **/
  cursor?: pedidosWhereUniqueInput
  /**
   * The number of pedidos to fetch. If negative number, it will take pedidos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` pedidos.
  **/
  skip?: number
  distinct?: Enumerable<PedidosDistinctFieldEnum>
}


/**
 * pedidos create
 */
export type pedidosCreateArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * The data needed to create a pedidos.
  **/
  data: pedidosCreateInput
}


/**
 * pedidos update
 */
export type pedidosUpdateArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * The data needed to update a pedidos.
  **/
  data: pedidosUpdateInput
  /**
   * Choose, which pedidos to update.
  **/
  where: pedidosWhereUniqueInput
}


/**
 * pedidos updateMany
 */
export type pedidosUpdateManyArgs = {
  data: pedidosUpdateManyMutationInput
  where?: pedidosWhereInput
}


/**
 * pedidos upsert
 */
export type pedidosUpsertArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * The filter to search for the pedidos to update in case it exists.
  **/
  where: pedidosWhereUniqueInput
  /**
   * In case the pedidos found by the `where` argument doesn't exist, create a new pedidos with this data.
  **/
  create: pedidosCreateInput
  /**
   * In case the pedidos was found with the provided `where` argument, update it with this data.
  **/
  update: pedidosUpdateInput
}


/**
 * pedidos delete
 */
export type pedidosDeleteArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
  /**
   * Filter which pedidos to delete.
  **/
  where: pedidosWhereUniqueInput
}


/**
 * pedidos deleteMany
 */
export type pedidosDeleteManyArgs = {
  where?: pedidosWhereInput
}


/**
 * pedidos without action
 */
export type pedidosArgs = {
  /**
   * Select specific fields to fetch from the pedidos
  **/
  select?: XOR<pedidosSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<pedidosInclude, null>
}



/**
 * Model detalhepedidos
 */

export type detalhepedidos = {
  Id: number
  IdPedido: number | null
  NmColaborador: string | null
  CPF: string | null
  NrCartao: string | null
  IdOperadora: number | null
  NmOperadora: string | null
  ValorDia: number | null
  NmEscala: string | null
  QtdOcorrencias: number | null
  QtdFolgas: number | null
  QtdDias: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  Valor_Total: number | null
  MemoriaCalculo: string | null
}


export type AggregateDetalhepedidos = {
  count: number
  avg: DetalhepedidosAvgAggregateOutputType | null
  sum: DetalhepedidosSumAggregateOutputType | null
  min: DetalhepedidosMinAggregateOutputType | null
  max: DetalhepedidosMaxAggregateOutputType | null
}

export type DetalhepedidosAvgAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdOcorrencias: number | null
  QtdFolgas: number | null
  QtdDias: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  Valor_Total: number | null
}

export type DetalhepedidosSumAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdOcorrencias: number | null
  QtdFolgas: number | null
  QtdDias: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  Valor_Total: number | null
}

export type DetalhepedidosMinAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdOcorrencias: number | null
  QtdFolgas: number | null
  QtdDias: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  Valor_Total: number | null
}

export type DetalhepedidosMaxAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdOcorrencias: number | null
  QtdFolgas: number | null
  QtdDias: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  Valor_Total: number | null
}


export type DetalhepedidosAvgAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdOcorrencias?: true
  QtdFolgas?: true
  QtdDias?: true
  QtdDiasUteis?: true
  Valor?: true
  Valor_Total?: true
}

export type DetalhepedidosSumAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdOcorrencias?: true
  QtdFolgas?: true
  QtdDias?: true
  QtdDiasUteis?: true
  Valor?: true
  Valor_Total?: true
}

export type DetalhepedidosMinAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdOcorrencias?: true
  QtdFolgas?: true
  QtdDias?: true
  QtdDiasUteis?: true
  Valor?: true
  Valor_Total?: true
}

export type DetalhepedidosMaxAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdOcorrencias?: true
  QtdFolgas?: true
  QtdDias?: true
  QtdDiasUteis?: true
  Valor?: true
  Valor_Total?: true
}

export type AggregateDetalhepedidosArgs = {
  where?: detalhepedidosWhereInput
  orderBy?: XOR<Enumerable<detalhepedidosOrderByInput>, detalhepedidosOrderByInput>
  cursor?: detalhepedidosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DetalhepedidosDistinctFieldEnum>
  count?: true
  avg?: DetalhepedidosAvgAggregateInputType
  sum?: DetalhepedidosSumAggregateInputType
  min?: DetalhepedidosMinAggregateInputType
  max?: DetalhepedidosMaxAggregateInputType
}

export type GetDetalhepedidosAggregateType<T extends AggregateDetalhepedidosArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDetalhepedidosAggregateScalarType<T[P]>
}

export type GetDetalhepedidosAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DetalhepedidosAvgAggregateOutputType ? DetalhepedidosAvgAggregateOutputType[P] : never
}
    
    

export type detalhepedidosSelect = {
  Id?: boolean
  IdPedido?: boolean
  NmColaborador?: boolean
  CPF?: boolean
  NrCartao?: boolean
  IdOperadora?: boolean
  NmOperadora?: boolean
  ValorDia?: boolean
  NmEscala?: boolean
  QtdOcorrencias?: boolean
  QtdFolgas?: boolean
  QtdDias?: boolean
  QtdDiasUteis?: boolean
  Valor?: boolean
  Valor_Total?: boolean
  MemoriaCalculo?: boolean
}

export type detalhepedidosGetPayload<
  S extends boolean | null | undefined | detalhepedidosArgs,
  U = keyof S
> = S extends true
  ? detalhepedidos
  : S extends undefined
  ? never
  : S extends detalhepedidosArgs | FindManydetalhepedidosArgs
  ? 'include' extends U
    ? detalhepedidos 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof detalhepedidos ? detalhepedidos[P]
: 
 never
    }
  : detalhepedidos
: detalhepedidos


export interface detalhepedidosDelegate {
  /**
   * Find zero or one Detalhepedidos that matches the filter.
   * @param {FindOnedetalhepedidosArgs} args - Arguments to find a Detalhepedidos
   * @example
   * // Get one Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedetalhepedidosArgs>(
    args: Subset<T, FindOnedetalhepedidosArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos | null>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T> | null>>
  /**
   * Find the first Detalhepedidos that matches the filter.
   * @param {FindFirstdetalhepedidosArgs} args - Arguments to find a Detalhepedidos
   * @example
   * // Get one Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstdetalhepedidosArgs>(
    args?: Subset<T, FindFirstdetalhepedidosArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos | null>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T> | null>>
  /**
   * Find zero or more Detalhepedidos that matches the filter.
   * @param {FindManydetalhepedidosArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.findMany()
   * 
   * // Get first 10 Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const detalhepedidosWithIdOnly = await prisma.detalhepedidos.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManydetalhepedidosArgs>(
    args?: Subset<T, FindManydetalhepedidosArgs>
  ): CheckSelect<T, Promise<Array<detalhepedidos>>, Promise<Array<detalhepedidosGetPayload<T>>>>
  /**
   * Create a Detalhepedidos.
   * @param {detalhepedidosCreateArgs} args - Arguments to create a Detalhepedidos.
   * @example
   * // Create one Detalhepedidos
   * const Detalhepedidos = await prisma.detalhepedidos.create({
   *   data: {
   *     // ... data to create a Detalhepedidos
   *   }
   * })
   * 
  **/
  create<T extends detalhepedidosCreateArgs>(
    args: Subset<T, detalhepedidosCreateArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T>>>
  /**
   * Delete a Detalhepedidos.
   * @param {detalhepedidosDeleteArgs} args - Arguments to delete one Detalhepedidos.
   * @example
   * // Delete one Detalhepedidos
   * const Detalhepedidos = await prisma.detalhepedidos.delete({
   *   where: {
   *     // ... filter to delete one Detalhepedidos
   *   }
   * })
   * 
  **/
  delete<T extends detalhepedidosDeleteArgs>(
    args: Subset<T, detalhepedidosDeleteArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T>>>
  /**
   * Update one Detalhepedidos.
   * @param {detalhepedidosUpdateArgs} args - Arguments to update one Detalhepedidos.
   * @example
   * // Update one Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends detalhepedidosUpdateArgs>(
    args: Subset<T, detalhepedidosUpdateArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T>>>
  /**
   * Delete zero or more Detalhepedidos.
   * @param {detalhepedidosDeleteManyArgs} args - Arguments to filter Detalhepedidos to delete.
   * @example
   * // Delete a few Detalhepedidos
   * const { count } = await prisma.detalhepedidos.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends detalhepedidosDeleteManyArgs>(
    args: Subset<T, detalhepedidosDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Detalhepedidos.
   * @param {detalhepedidosUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends detalhepedidosUpdateManyArgs>(
    args: Subset<T, detalhepedidosUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Detalhepedidos.
   * @param {detalhepedidosUpsertArgs} args - Arguments to update or create a Detalhepedidos.
   * @example
   * // Update or create a Detalhepedidos
   * const detalhepedidos = await prisma.detalhepedidos.upsert({
   *   create: {
   *     // ... data to create a Detalhepedidos
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Detalhepedidos we want to update
   *   }
   * })
  **/
  upsert<T extends detalhepedidosUpsertArgs>(
    args: Subset<T, detalhepedidosUpsertArgs>
  ): CheckSelect<T, Prisma__detalhepedidosClient<detalhepedidos>, Prisma__detalhepedidosClient<detalhepedidosGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydetalhepedidosArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDetalhepedidosArgs>(args: Subset<T, AggregateDetalhepedidosArgs>): Promise<GetDetalhepedidosAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for detalhepedidos.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__detalhepedidosClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * detalhepedidos findOne
 */
export type FindOnedetalhepedidosArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * Filter, which detalhepedidos to fetch.
  **/
  where: detalhepedidosWhereUniqueInput
}


/**
 * detalhepedidos findFirst
 */
export type FindFirstdetalhepedidosArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * Filter, which detalhepedidos to fetch.
  **/
  where?: detalhepedidosWhereInput
  orderBy?: XOR<Enumerable<detalhepedidosOrderByInput>, detalhepedidosOrderByInput>
  cursor?: detalhepedidosWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DetalhepedidosDistinctFieldEnum>
}


/**
 * detalhepedidos findMany
 */
export type FindManydetalhepedidosArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * Filter, which detalhepedidos to fetch.
  **/
  where?: detalhepedidosWhereInput
  /**
   * Determine the order of the detalhepedidos to fetch.
  **/
  orderBy?: XOR<Enumerable<detalhepedidosOrderByInput>, detalhepedidosOrderByInput>
  /**
   * Sets the position for listing detalhepedidos.
  **/
  cursor?: detalhepedidosWhereUniqueInput
  /**
   * The number of detalhepedidos to fetch. If negative number, it will take detalhepedidos before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` detalhepedidos.
  **/
  skip?: number
  distinct?: Enumerable<DetalhepedidosDistinctFieldEnum>
}


/**
 * detalhepedidos create
 */
export type detalhepedidosCreateArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * The data needed to create a detalhepedidos.
  **/
  data: detalhepedidosCreateInput
}


/**
 * detalhepedidos update
 */
export type detalhepedidosUpdateArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * The data needed to update a detalhepedidos.
  **/
  data: detalhepedidosUpdateInput
  /**
   * Choose, which detalhepedidos to update.
  **/
  where: detalhepedidosWhereUniqueInput
}


/**
 * detalhepedidos updateMany
 */
export type detalhepedidosUpdateManyArgs = {
  data: detalhepedidosUpdateManyMutationInput
  where?: detalhepedidosWhereInput
}


/**
 * detalhepedidos upsert
 */
export type detalhepedidosUpsertArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * The filter to search for the detalhepedidos to update in case it exists.
  **/
  where: detalhepedidosWhereUniqueInput
  /**
   * In case the detalhepedidos found by the `where` argument doesn't exist, create a new detalhepedidos with this data.
  **/
  create: detalhepedidosCreateInput
  /**
   * In case the detalhepedidos was found with the provided `where` argument, update it with this data.
  **/
  update: detalhepedidosUpdateInput
}


/**
 * detalhepedidos delete
 */
export type detalhepedidosDeleteArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
  /**
   * Filter which detalhepedidos to delete.
  **/
  where: detalhepedidosWhereUniqueInput
}


/**
 * detalhepedidos deleteMany
 */
export type detalhepedidosDeleteManyArgs = {
  where?: detalhepedidosWhereInput
}


/**
 * detalhepedidos without action
 */
export type detalhepedidosArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos
  **/
  select?: XOR<detalhepedidosSelect, null>
}



/**
 * Model detalhepedidos_old
 */

export type detalhepedidos_old = {
  Id: number
  IdPedido: number | null
  NmColaborador: string | null
  CPF: string | null
  NrCartao: string | null
  IdOperadora: number | null
  NmOperadora: string | null
  ValorDia: number | null
  QtdFolgas: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  IdEscalas: number | null
  QtdVale: number | null
  MemoriaCalculo: string | null
}


export type AggregateDetalhepedidos_old = {
  count: number
  avg: Detalhepedidos_oldAvgAggregateOutputType | null
  sum: Detalhepedidos_oldSumAggregateOutputType | null
  min: Detalhepedidos_oldMinAggregateOutputType | null
  max: Detalhepedidos_oldMaxAggregateOutputType | null
}

export type Detalhepedidos_oldAvgAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdFolgas: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  IdEscalas: number | null
  QtdVale: number | null
}

export type Detalhepedidos_oldSumAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdFolgas: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  IdEscalas: number | null
  QtdVale: number | null
}

export type Detalhepedidos_oldMinAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdFolgas: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  IdEscalas: number | null
  QtdVale: number | null
}

export type Detalhepedidos_oldMaxAggregateOutputType = {
  Id: number
  IdPedido: number | null
  IdOperadora: number | null
  ValorDia: number | null
  QtdFolgas: number | null
  QtdDiasUteis: number | null
  Valor: number | null
  IdEscalas: number | null
  QtdVale: number | null
}


export type Detalhepedidos_oldAvgAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdFolgas?: true
  QtdDiasUteis?: true
  Valor?: true
  IdEscalas?: true
  QtdVale?: true
}

export type Detalhepedidos_oldSumAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdFolgas?: true
  QtdDiasUteis?: true
  Valor?: true
  IdEscalas?: true
  QtdVale?: true
}

export type Detalhepedidos_oldMinAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdFolgas?: true
  QtdDiasUteis?: true
  Valor?: true
  IdEscalas?: true
  QtdVale?: true
}

export type Detalhepedidos_oldMaxAggregateInputType = {
  Id?: true
  IdPedido?: true
  IdOperadora?: true
  ValorDia?: true
  QtdFolgas?: true
  QtdDiasUteis?: true
  Valor?: true
  IdEscalas?: true
  QtdVale?: true
}

export type AggregateDetalhepedidos_oldArgs = {
  where?: detalhepedidos_oldWhereInput
  orderBy?: XOR<Enumerable<detalhepedidos_oldOrderByInput>, detalhepedidos_oldOrderByInput>
  cursor?: detalhepedidos_oldWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<Detalhepedidos_oldDistinctFieldEnum>
  count?: true
  avg?: Detalhepedidos_oldAvgAggregateInputType
  sum?: Detalhepedidos_oldSumAggregateInputType
  min?: Detalhepedidos_oldMinAggregateInputType
  max?: Detalhepedidos_oldMaxAggregateInputType
}

export type GetDetalhepedidos_oldAggregateType<T extends AggregateDetalhepedidos_oldArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDetalhepedidos_oldAggregateScalarType<T[P]>
}

export type GetDetalhepedidos_oldAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof Detalhepedidos_oldAvgAggregateOutputType ? Detalhepedidos_oldAvgAggregateOutputType[P] : never
}
    
    

export type detalhepedidos_oldSelect = {
  Id?: boolean
  IdPedido?: boolean
  NmColaborador?: boolean
  CPF?: boolean
  NrCartao?: boolean
  IdOperadora?: boolean
  NmOperadora?: boolean
  ValorDia?: boolean
  QtdFolgas?: boolean
  QtdDiasUteis?: boolean
  Valor?: boolean
  IdEscalas?: boolean
  QtdVale?: boolean
  MemoriaCalculo?: boolean
  dados?: boolean | dadosArgs
  escalas?: boolean | escalasArgs
  operadoras?: boolean | operadorasArgs
  pedidos?: boolean | pedidosArgs
}

export type detalhepedidos_oldInclude = {
  dados?: boolean | dadosArgs
  escalas?: boolean | escalasArgs
  operadoras?: boolean | operadorasArgs
  pedidos?: boolean | pedidosArgs
}

export type detalhepedidos_oldGetPayload<
  S extends boolean | null | undefined | detalhepedidos_oldArgs,
  U = keyof S
> = S extends true
  ? detalhepedidos_old
  : S extends undefined
  ? never
  : S extends detalhepedidos_oldArgs | FindManydetalhepedidos_oldArgs
  ? 'include' extends U
    ? detalhepedidos_old  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dados'
      ? dadosGetPayload<S['include'][P]> | null :
      P extends 'escalas'
      ? escalasGetPayload<S['include'][P]> | null :
      P extends 'operadoras'
      ? operadorasGetPayload<S['include'][P]> | null :
      P extends 'pedidos'
      ? pedidosGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof detalhepedidos_old ? detalhepedidos_old[P]
: 
      P extends 'dados'
      ? dadosGetPayload<S['select'][P]> | null :
      P extends 'escalas'
      ? escalasGetPayload<S['select'][P]> | null :
      P extends 'operadoras'
      ? operadorasGetPayload<S['select'][P]> | null :
      P extends 'pedidos'
      ? pedidosGetPayload<S['select'][P]> | null : never
    }
  : detalhepedidos_old
: detalhepedidos_old


export interface detalhepedidos_oldDelegate {
  /**
   * Find zero or one Detalhepedidos_old that matches the filter.
   * @param {FindOnedetalhepedidos_oldArgs} args - Arguments to find a Detalhepedidos_old
   * @example
   * // Get one Detalhepedidos_old
   * const detalhepedidos_old = await prisma.detalhepedidos_old.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedetalhepedidos_oldArgs>(
    args: Subset<T, FindOnedetalhepedidos_oldArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old | null>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T> | null>>
  /**
   * Find the first Detalhepedidos_old that matches the filter.
   * @param {FindFirstdetalhepedidos_oldArgs} args - Arguments to find a Detalhepedidos_old
   * @example
   * // Get one Detalhepedidos_old
   * const detalhepedidos_old = await prisma.detalhepedidos_old.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstdetalhepedidos_oldArgs>(
    args?: Subset<T, FindFirstdetalhepedidos_oldArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old | null>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T> | null>>
  /**
   * Find zero or more Detalhepedidos_olds that matches the filter.
   * @param {FindManydetalhepedidos_oldArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Detalhepedidos_olds
   * const detalhepedidos_olds = await prisma.detalhepedidos_old.findMany()
   * 
   * // Get first 10 Detalhepedidos_olds
   * const detalhepedidos_olds = await prisma.detalhepedidos_old.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const detalhepedidos_oldWithIdOnly = await prisma.detalhepedidos_old.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManydetalhepedidos_oldArgs>(
    args?: Subset<T, FindManydetalhepedidos_oldArgs>
  ): CheckSelect<T, Promise<Array<detalhepedidos_old>>, Promise<Array<detalhepedidos_oldGetPayload<T>>>>
  /**
   * Create a Detalhepedidos_old.
   * @param {detalhepedidos_oldCreateArgs} args - Arguments to create a Detalhepedidos_old.
   * @example
   * // Create one Detalhepedidos_old
   * const Detalhepedidos_old = await prisma.detalhepedidos_old.create({
   *   data: {
   *     // ... data to create a Detalhepedidos_old
   *   }
   * })
   * 
  **/
  create<T extends detalhepedidos_oldCreateArgs>(
    args: Subset<T, detalhepedidos_oldCreateArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T>>>
  /**
   * Delete a Detalhepedidos_old.
   * @param {detalhepedidos_oldDeleteArgs} args - Arguments to delete one Detalhepedidos_old.
   * @example
   * // Delete one Detalhepedidos_old
   * const Detalhepedidos_old = await prisma.detalhepedidos_old.delete({
   *   where: {
   *     // ... filter to delete one Detalhepedidos_old
   *   }
   * })
   * 
  **/
  delete<T extends detalhepedidos_oldDeleteArgs>(
    args: Subset<T, detalhepedidos_oldDeleteArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T>>>
  /**
   * Update one Detalhepedidos_old.
   * @param {detalhepedidos_oldUpdateArgs} args - Arguments to update one Detalhepedidos_old.
   * @example
   * // Update one Detalhepedidos_old
   * const detalhepedidos_old = await prisma.detalhepedidos_old.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends detalhepedidos_oldUpdateArgs>(
    args: Subset<T, detalhepedidos_oldUpdateArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T>>>
  /**
   * Delete zero or more Detalhepedidos_olds.
   * @param {detalhepedidos_oldDeleteManyArgs} args - Arguments to filter Detalhepedidos_olds to delete.
   * @example
   * // Delete a few Detalhepedidos_olds
   * const { count } = await prisma.detalhepedidos_old.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends detalhepedidos_oldDeleteManyArgs>(
    args: Subset<T, detalhepedidos_oldDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Detalhepedidos_olds.
   * @param {detalhepedidos_oldUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Detalhepedidos_olds
   * const detalhepedidos_old = await prisma.detalhepedidos_old.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends detalhepedidos_oldUpdateManyArgs>(
    args: Subset<T, detalhepedidos_oldUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Detalhepedidos_old.
   * @param {detalhepedidos_oldUpsertArgs} args - Arguments to update or create a Detalhepedidos_old.
   * @example
   * // Update or create a Detalhepedidos_old
   * const detalhepedidos_old = await prisma.detalhepedidos_old.upsert({
   *   create: {
   *     // ... data to create a Detalhepedidos_old
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Detalhepedidos_old we want to update
   *   }
   * })
  **/
  upsert<T extends detalhepedidos_oldUpsertArgs>(
    args: Subset<T, detalhepedidos_oldUpsertArgs>
  ): CheckSelect<T, Prisma__detalhepedidos_oldClient<detalhepedidos_old>, Prisma__detalhepedidos_oldClient<detalhepedidos_oldGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydetalhepedidos_oldArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDetalhepedidos_oldArgs>(args: Subset<T, AggregateDetalhepedidos_oldArgs>): Promise<GetDetalhepedidos_oldAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for detalhepedidos_old.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__detalhepedidos_oldClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dados<T extends dadosArgs = {}>(args?: Subset<T, dadosArgs>): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>;

  escalas<T extends escalasArgs = {}>(args?: Subset<T, escalasArgs>): CheckSelect<T, Prisma__escalasClient<escalas | null>, Prisma__escalasClient<escalasGetPayload<T> | null>>;

  operadoras<T extends operadorasArgs = {}>(args?: Subset<T, operadorasArgs>): CheckSelect<T, Prisma__operadorasClient<operadoras | null>, Prisma__operadorasClient<operadorasGetPayload<T> | null>>;

  pedidos<T extends pedidosArgs = {}>(args?: Subset<T, pedidosArgs>): CheckSelect<T, Prisma__pedidosClient<pedidos | null>, Prisma__pedidosClient<pedidosGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * detalhepedidos_old findOne
 */
export type FindOnedetalhepedidos_oldArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * Filter, which detalhepedidos_old to fetch.
  **/
  where: detalhepedidos_oldWhereUniqueInput
}


/**
 * detalhepedidos_old findFirst
 */
export type FindFirstdetalhepedidos_oldArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * Filter, which detalhepedidos_old to fetch.
  **/
  where?: detalhepedidos_oldWhereInput
  orderBy?: XOR<Enumerable<detalhepedidos_oldOrderByInput>, detalhepedidos_oldOrderByInput>
  cursor?: detalhepedidos_oldWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<Detalhepedidos_oldDistinctFieldEnum>
}


/**
 * detalhepedidos_old findMany
 */
export type FindManydetalhepedidos_oldArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * Filter, which detalhepedidos_olds to fetch.
  **/
  where?: detalhepedidos_oldWhereInput
  /**
   * Determine the order of the detalhepedidos_olds to fetch.
  **/
  orderBy?: XOR<Enumerable<detalhepedidos_oldOrderByInput>, detalhepedidos_oldOrderByInput>
  /**
   * Sets the position for listing detalhepedidos_olds.
  **/
  cursor?: detalhepedidos_oldWhereUniqueInput
  /**
   * The number of detalhepedidos_olds to fetch. If negative number, it will take detalhepedidos_olds before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` detalhepedidos_olds.
  **/
  skip?: number
  distinct?: Enumerable<Detalhepedidos_oldDistinctFieldEnum>
}


/**
 * detalhepedidos_old create
 */
export type detalhepedidos_oldCreateArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * The data needed to create a detalhepedidos_old.
  **/
  data: detalhepedidos_oldCreateInput
}


/**
 * detalhepedidos_old update
 */
export type detalhepedidos_oldUpdateArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * The data needed to update a detalhepedidos_old.
  **/
  data: detalhepedidos_oldUpdateInput
  /**
   * Choose, which detalhepedidos_old to update.
  **/
  where: detalhepedidos_oldWhereUniqueInput
}


/**
 * detalhepedidos_old updateMany
 */
export type detalhepedidos_oldUpdateManyArgs = {
  data: detalhepedidos_oldUpdateManyMutationInput
  where?: detalhepedidos_oldWhereInput
}


/**
 * detalhepedidos_old upsert
 */
export type detalhepedidos_oldUpsertArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * The filter to search for the detalhepedidos_old to update in case it exists.
  **/
  where: detalhepedidos_oldWhereUniqueInput
  /**
   * In case the detalhepedidos_old found by the `where` argument doesn't exist, create a new detalhepedidos_old with this data.
  **/
  create: detalhepedidos_oldCreateInput
  /**
   * In case the detalhepedidos_old was found with the provided `where` argument, update it with this data.
  **/
  update: detalhepedidos_oldUpdateInput
}


/**
 * detalhepedidos_old delete
 */
export type detalhepedidos_oldDeleteArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
  /**
   * Filter which detalhepedidos_old to delete.
  **/
  where: detalhepedidos_oldWhereUniqueInput
}


/**
 * detalhepedidos_old deleteMany
 */
export type detalhepedidos_oldDeleteManyArgs = {
  where?: detalhepedidos_oldWhereInput
}


/**
 * detalhepedidos_old without action
 */
export type detalhepedidos_oldArgs = {
  /**
   * Select specific fields to fetch from the detalhepedidos_old
  **/
  select?: XOR<detalhepedidos_oldSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<detalhepedidos_oldInclude, null>
}



/**
 * Model economia
 */

export type economia = {
  Id: number
  IdEmpresa: number | null
  Competencia: string | null
  Valor: number | null
}


export type AggregateEconomia = {
  count: number
  avg: EconomiaAvgAggregateOutputType | null
  sum: EconomiaSumAggregateOutputType | null
  min: EconomiaMinAggregateOutputType | null
  max: EconomiaMaxAggregateOutputType | null
}

export type EconomiaAvgAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  Valor: number | null
}

export type EconomiaSumAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  Valor: number | null
}

export type EconomiaMinAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  Valor: number | null
}

export type EconomiaMaxAggregateOutputType = {
  Id: number
  IdEmpresa: number | null
  Valor: number | null
}


export type EconomiaAvgAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  Valor?: true
}

export type EconomiaSumAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  Valor?: true
}

export type EconomiaMinAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  Valor?: true
}

export type EconomiaMaxAggregateInputType = {
  Id?: true
  IdEmpresa?: true
  Valor?: true
}

export type AggregateEconomiaArgs = {
  where?: economiaWhereInput
  orderBy?: XOR<Enumerable<economiaOrderByInput>, economiaOrderByInput>
  cursor?: economiaWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EconomiaDistinctFieldEnum>
  count?: true
  avg?: EconomiaAvgAggregateInputType
  sum?: EconomiaSumAggregateInputType
  min?: EconomiaMinAggregateInputType
  max?: EconomiaMaxAggregateInputType
}

export type GetEconomiaAggregateType<T extends AggregateEconomiaArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEconomiaAggregateScalarType<T[P]>
}

export type GetEconomiaAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EconomiaAvgAggregateOutputType ? EconomiaAvgAggregateOutputType[P] : never
}
    
    

export type economiaSelect = {
  Id?: boolean
  IdEmpresa?: boolean
  Competencia?: boolean
  Valor?: boolean
  empresas?: boolean | empresasArgs
}

export type economiaInclude = {
  empresas?: boolean | empresasArgs
}

export type economiaGetPayload<
  S extends boolean | null | undefined | economiaArgs,
  U = keyof S
> = S extends true
  ? economia
  : S extends undefined
  ? never
  : S extends economiaArgs | FindManyeconomiaArgs
  ? 'include' extends U
    ? economia  & {
      [P in TrueKeys<S['include']>]:
      P extends 'empresas'
      ? empresasGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof economia ? economia[P]
: 
      P extends 'empresas'
      ? empresasGetPayload<S['select'][P]> | null : never
    }
  : economia
: economia


export interface economiaDelegate {
  /**
   * Find zero or one Economia that matches the filter.
   * @param {FindOneeconomiaArgs} args - Arguments to find a Economia
   * @example
   * // Get one Economia
   * const economia = await prisma.economia.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneeconomiaArgs>(
    args: Subset<T, FindOneeconomiaArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia | null>, Prisma__economiaClient<economiaGetPayload<T> | null>>
  /**
   * Find the first Economia that matches the filter.
   * @param {FindFirsteconomiaArgs} args - Arguments to find a Economia
   * @example
   * // Get one Economia
   * const economia = await prisma.economia.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirsteconomiaArgs>(
    args?: Subset<T, FindFirsteconomiaArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia | null>, Prisma__economiaClient<economiaGetPayload<T> | null>>
  /**
   * Find zero or more Economias that matches the filter.
   * @param {FindManyeconomiaArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Economias
   * const economias = await prisma.economia.findMany()
   * 
   * // Get first 10 Economias
   * const economias = await prisma.economia.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const economiaWithIdOnly = await prisma.economia.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManyeconomiaArgs>(
    args?: Subset<T, FindManyeconomiaArgs>
  ): CheckSelect<T, Promise<Array<economia>>, Promise<Array<economiaGetPayload<T>>>>
  /**
   * Create a Economia.
   * @param {economiaCreateArgs} args - Arguments to create a Economia.
   * @example
   * // Create one Economia
   * const Economia = await prisma.economia.create({
   *   data: {
   *     // ... data to create a Economia
   *   }
   * })
   * 
  **/
  create<T extends economiaCreateArgs>(
    args: Subset<T, economiaCreateArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia>, Prisma__economiaClient<economiaGetPayload<T>>>
  /**
   * Delete a Economia.
   * @param {economiaDeleteArgs} args - Arguments to delete one Economia.
   * @example
   * // Delete one Economia
   * const Economia = await prisma.economia.delete({
   *   where: {
   *     // ... filter to delete one Economia
   *   }
   * })
   * 
  **/
  delete<T extends economiaDeleteArgs>(
    args: Subset<T, economiaDeleteArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia>, Prisma__economiaClient<economiaGetPayload<T>>>
  /**
   * Update one Economia.
   * @param {economiaUpdateArgs} args - Arguments to update one Economia.
   * @example
   * // Update one Economia
   * const economia = await prisma.economia.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends economiaUpdateArgs>(
    args: Subset<T, economiaUpdateArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia>, Prisma__economiaClient<economiaGetPayload<T>>>
  /**
   * Delete zero or more Economias.
   * @param {economiaDeleteManyArgs} args - Arguments to filter Economias to delete.
   * @example
   * // Delete a few Economias
   * const { count } = await prisma.economia.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends economiaDeleteManyArgs>(
    args: Subset<T, economiaDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Economias.
   * @param {economiaUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Economias
   * const economia = await prisma.economia.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends economiaUpdateManyArgs>(
    args: Subset<T, economiaUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Economia.
   * @param {economiaUpsertArgs} args - Arguments to update or create a Economia.
   * @example
   * // Update or create a Economia
   * const economia = await prisma.economia.upsert({
   *   create: {
   *     // ... data to create a Economia
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Economia we want to update
   *   }
   * })
  **/
  upsert<T extends economiaUpsertArgs>(
    args: Subset<T, economiaUpsertArgs>
  ): CheckSelect<T, Prisma__economiaClient<economia>, Prisma__economiaClient<economiaGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyeconomiaArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEconomiaArgs>(args: Subset<T, AggregateEconomiaArgs>): Promise<GetEconomiaAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for economia.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__economiaClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  empresas<T extends empresasArgs = {}>(args?: Subset<T, empresasArgs>): CheckSelect<T, Prisma__empresasClient<empresas | null>, Prisma__empresasClient<empresasGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * economia findOne
 */
export type FindOneeconomiaArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * Filter, which economia to fetch.
  **/
  where: economiaWhereUniqueInput
}


/**
 * economia findFirst
 */
export type FindFirsteconomiaArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * Filter, which economia to fetch.
  **/
  where?: economiaWhereInput
  orderBy?: XOR<Enumerable<economiaOrderByInput>, economiaOrderByInput>
  cursor?: economiaWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EconomiaDistinctFieldEnum>
}


/**
 * economia findMany
 */
export type FindManyeconomiaArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * Filter, which economias to fetch.
  **/
  where?: economiaWhereInput
  /**
   * Determine the order of the economias to fetch.
  **/
  orderBy?: XOR<Enumerable<economiaOrderByInput>, economiaOrderByInput>
  /**
   * Sets the position for listing economias.
  **/
  cursor?: economiaWhereUniqueInput
  /**
   * The number of economias to fetch. If negative number, it will take economias before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` economias.
  **/
  skip?: number
  distinct?: Enumerable<EconomiaDistinctFieldEnum>
}


/**
 * economia create
 */
export type economiaCreateArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * The data needed to create a economia.
  **/
  data: economiaCreateInput
}


/**
 * economia update
 */
export type economiaUpdateArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * The data needed to update a economia.
  **/
  data: economiaUpdateInput
  /**
   * Choose, which economia to update.
  **/
  where: economiaWhereUniqueInput
}


/**
 * economia updateMany
 */
export type economiaUpdateManyArgs = {
  data: economiaUpdateManyMutationInput
  where?: economiaWhereInput
}


/**
 * economia upsert
 */
export type economiaUpsertArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * The filter to search for the economia to update in case it exists.
  **/
  where: economiaWhereUniqueInput
  /**
   * In case the economia found by the `where` argument doesn't exist, create a new economia with this data.
  **/
  create: economiaCreateInput
  /**
   * In case the economia was found with the provided `where` argument, update it with this data.
  **/
  update: economiaUpdateInput
}


/**
 * economia delete
 */
export type economiaDeleteArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
  /**
   * Filter which economia to delete.
  **/
  where: economiaWhereUniqueInput
}


/**
 * economia deleteMany
 */
export type economiaDeleteManyArgs = {
  where?: economiaWhereInput
}


/**
 * economia without action
 */
export type economiaArgs = {
  /**
   * Select specific fields to fetch from the economia
  **/
  select?: XOR<economiaSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<economiaInclude, null>
}



/**
 * Model solicitacoes
 */

export type solicitacoes = {
  Id: number
  Protocolo: string | null
  CPF: string | null
  TipoSolicitacao: string | null
  OrigemSolicitacao: string | null
  NrCartao: string | null
  DtSolicitacao: Date
  DtFinalizacao: Date | null
  Status: string | null
}


export type AggregateSolicitacoes = {
  count: number
  avg: SolicitacoesAvgAggregateOutputType | null
  sum: SolicitacoesSumAggregateOutputType | null
  min: SolicitacoesMinAggregateOutputType | null
  max: SolicitacoesMaxAggregateOutputType | null
}

export type SolicitacoesAvgAggregateOutputType = {
  Id: number
}

export type SolicitacoesSumAggregateOutputType = {
  Id: number
}

export type SolicitacoesMinAggregateOutputType = {
  Id: number
}

export type SolicitacoesMaxAggregateOutputType = {
  Id: number
}


export type SolicitacoesAvgAggregateInputType = {
  Id?: true
}

export type SolicitacoesSumAggregateInputType = {
  Id?: true
}

export type SolicitacoesMinAggregateInputType = {
  Id?: true
}

export type SolicitacoesMaxAggregateInputType = {
  Id?: true
}

export type AggregateSolicitacoesArgs = {
  where?: solicitacoesWhereInput
  orderBy?: XOR<Enumerable<solicitacoesOrderByInput>, solicitacoesOrderByInput>
  cursor?: solicitacoesWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SolicitacoesDistinctFieldEnum>
  count?: true
  avg?: SolicitacoesAvgAggregateInputType
  sum?: SolicitacoesSumAggregateInputType
  min?: SolicitacoesMinAggregateInputType
  max?: SolicitacoesMaxAggregateInputType
}

export type GetSolicitacoesAggregateType<T extends AggregateSolicitacoesArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetSolicitacoesAggregateScalarType<T[P]>
}

export type GetSolicitacoesAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof SolicitacoesAvgAggregateOutputType ? SolicitacoesAvgAggregateOutputType[P] : never
}
    
    

export type solicitacoesSelect = {
  Id?: boolean
  Protocolo?: boolean
  CPF?: boolean
  TipoSolicitacao?: boolean
  OrigemSolicitacao?: boolean
  NrCartao?: boolean
  DtSolicitacao?: boolean
  DtFinalizacao?: boolean
  Status?: boolean
  dados?: boolean | dadosArgs
}

export type solicitacoesInclude = {
  dados?: boolean | dadosArgs
}

export type solicitacoesGetPayload<
  S extends boolean | null | undefined | solicitacoesArgs,
  U = keyof S
> = S extends true
  ? solicitacoes
  : S extends undefined
  ? never
  : S extends solicitacoesArgs | FindManysolicitacoesArgs
  ? 'include' extends U
    ? solicitacoes  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dados'
      ? dadosGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof solicitacoes ? solicitacoes[P]
: 
      P extends 'dados'
      ? dadosGetPayload<S['select'][P]> | null : never
    }
  : solicitacoes
: solicitacoes


export interface solicitacoesDelegate {
  /**
   * Find zero or one Solicitacoes that matches the filter.
   * @param {FindOnesolicitacoesArgs} args - Arguments to find a Solicitacoes
   * @example
   * // Get one Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnesolicitacoesArgs>(
    args: Subset<T, FindOnesolicitacoesArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes | null>, Prisma__solicitacoesClient<solicitacoesGetPayload<T> | null>>
  /**
   * Find the first Solicitacoes that matches the filter.
   * @param {FindFirstsolicitacoesArgs} args - Arguments to find a Solicitacoes
   * @example
   * // Get one Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstsolicitacoesArgs>(
    args?: Subset<T, FindFirstsolicitacoesArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes | null>, Prisma__solicitacoesClient<solicitacoesGetPayload<T> | null>>
  /**
   * Find zero or more Solicitacoes that matches the filter.
   * @param {FindManysolicitacoesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.findMany()
   * 
   * // Get first 10 Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.findMany({ take: 10 })
   * 
   * // Only select the `Id`
   * const solicitacoesWithIdOnly = await prisma.solicitacoes.findMany({ select: { Id: true } })
   * 
  **/
  findMany<T extends FindManysolicitacoesArgs>(
    args?: Subset<T, FindManysolicitacoesArgs>
  ): CheckSelect<T, Promise<Array<solicitacoes>>, Promise<Array<solicitacoesGetPayload<T>>>>
  /**
   * Create a Solicitacoes.
   * @param {solicitacoesCreateArgs} args - Arguments to create a Solicitacoes.
   * @example
   * // Create one Solicitacoes
   * const Solicitacoes = await prisma.solicitacoes.create({
   *   data: {
   *     // ... data to create a Solicitacoes
   *   }
   * })
   * 
  **/
  create<T extends solicitacoesCreateArgs>(
    args: Subset<T, solicitacoesCreateArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes>, Prisma__solicitacoesClient<solicitacoesGetPayload<T>>>
  /**
   * Delete a Solicitacoes.
   * @param {solicitacoesDeleteArgs} args - Arguments to delete one Solicitacoes.
   * @example
   * // Delete one Solicitacoes
   * const Solicitacoes = await prisma.solicitacoes.delete({
   *   where: {
   *     // ... filter to delete one Solicitacoes
   *   }
   * })
   * 
  **/
  delete<T extends solicitacoesDeleteArgs>(
    args: Subset<T, solicitacoesDeleteArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes>, Prisma__solicitacoesClient<solicitacoesGetPayload<T>>>
  /**
   * Update one Solicitacoes.
   * @param {solicitacoesUpdateArgs} args - Arguments to update one Solicitacoes.
   * @example
   * // Update one Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends solicitacoesUpdateArgs>(
    args: Subset<T, solicitacoesUpdateArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes>, Prisma__solicitacoesClient<solicitacoesGetPayload<T>>>
  /**
   * Delete zero or more Solicitacoes.
   * @param {solicitacoesDeleteManyArgs} args - Arguments to filter Solicitacoes to delete.
   * @example
   * // Delete a few Solicitacoes
   * const { count } = await prisma.solicitacoes.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends solicitacoesDeleteManyArgs>(
    args: Subset<T, solicitacoesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Solicitacoes.
   * @param {solicitacoesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends solicitacoesUpdateManyArgs>(
    args: Subset<T, solicitacoesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Solicitacoes.
   * @param {solicitacoesUpsertArgs} args - Arguments to update or create a Solicitacoes.
   * @example
   * // Update or create a Solicitacoes
   * const solicitacoes = await prisma.solicitacoes.upsert({
   *   create: {
   *     // ... data to create a Solicitacoes
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Solicitacoes we want to update
   *   }
   * })
  **/
  upsert<T extends solicitacoesUpsertArgs>(
    args: Subset<T, solicitacoesUpsertArgs>
  ): CheckSelect<T, Prisma__solicitacoesClient<solicitacoes>, Prisma__solicitacoesClient<solicitacoesGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManysolicitacoesArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateSolicitacoesArgs>(args: Subset<T, AggregateSolicitacoesArgs>): Promise<GetSolicitacoesAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for solicitacoes.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__solicitacoesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dados<T extends dadosArgs = {}>(args?: Subset<T, dadosArgs>): CheckSelect<T, Prisma__dadosClient<dados | null>, Prisma__dadosClient<dadosGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * solicitacoes findOne
 */
export type FindOnesolicitacoesArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * Filter, which solicitacoes to fetch.
  **/
  where: solicitacoesWhereUniqueInput
}


/**
 * solicitacoes findFirst
 */
export type FindFirstsolicitacoesArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * Filter, which solicitacoes to fetch.
  **/
  where?: solicitacoesWhereInput
  orderBy?: XOR<Enumerable<solicitacoesOrderByInput>, solicitacoesOrderByInput>
  cursor?: solicitacoesWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SolicitacoesDistinctFieldEnum>
}


/**
 * solicitacoes findMany
 */
export type FindManysolicitacoesArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * Filter, which solicitacoes to fetch.
  **/
  where?: solicitacoesWhereInput
  /**
   * Determine the order of the solicitacoes to fetch.
  **/
  orderBy?: XOR<Enumerable<solicitacoesOrderByInput>, solicitacoesOrderByInput>
  /**
   * Sets the position for listing solicitacoes.
  **/
  cursor?: solicitacoesWhereUniqueInput
  /**
   * The number of solicitacoes to fetch. If negative number, it will take solicitacoes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` solicitacoes.
  **/
  skip?: number
  distinct?: Enumerable<SolicitacoesDistinctFieldEnum>
}


/**
 * solicitacoes create
 */
export type solicitacoesCreateArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * The data needed to create a solicitacoes.
  **/
  data: solicitacoesCreateInput
}


/**
 * solicitacoes update
 */
export type solicitacoesUpdateArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * The data needed to update a solicitacoes.
  **/
  data: solicitacoesUpdateInput
  /**
   * Choose, which solicitacoes to update.
  **/
  where: solicitacoesWhereUniqueInput
}


/**
 * solicitacoes updateMany
 */
export type solicitacoesUpdateManyArgs = {
  data: solicitacoesUpdateManyMutationInput
  where?: solicitacoesWhereInput
}


/**
 * solicitacoes upsert
 */
export type solicitacoesUpsertArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * The filter to search for the solicitacoes to update in case it exists.
  **/
  where: solicitacoesWhereUniqueInput
  /**
   * In case the solicitacoes found by the `where` argument doesn't exist, create a new solicitacoes with this data.
  **/
  create: solicitacoesCreateInput
  /**
   * In case the solicitacoes was found with the provided `where` argument, update it with this data.
  **/
  update: solicitacoesUpdateInput
}


/**
 * solicitacoes delete
 */
export type solicitacoesDeleteArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
  /**
   * Filter which solicitacoes to delete.
  **/
  where: solicitacoesWhereUniqueInput
}


/**
 * solicitacoes deleteMany
 */
export type solicitacoesDeleteManyArgs = {
  where?: solicitacoesWhereInput
}


/**
 * solicitacoes without action
 */
export type solicitacoesArgs = {
  /**
   * Select specific fields to fetch from the solicitacoes
  **/
  select?: XOR<solicitacoesSelect, null>
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: XOR<solicitacoesInclude, null>
}



/**
 * Deep Input Types
 */


export type centrodecustosWhereInput = {
  AND?: XOR<centrodecustosWhereInput, Enumerable<centrodecustosWhereInput>>
  OR?: XOR<centrodecustosWhereInput, Enumerable<centrodecustosWhereInput>>
  NOT?: XOR<centrodecustosWhereInput, Enumerable<centrodecustosWhereInput>>
  Id?: XOR<IntFilter, number>
  NmCentroDeCusto?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  dados?: DadosListRelationFilter
}

export type centrodecustosOrderByInput = {
  Id?: SortOrder
  NmCentroDeCusto?: SortOrder
  IdEmpresa?: SortOrder
  Situacao?: SortOrder
}

export type centrodecustosWhereUniqueInput = {
  Id?: number
}

export type empresasWhereInput = {
  AND?: XOR<empresasWhereInput, Enumerable<empresasWhereInput>>
  OR?: XOR<empresasWhereInput, Enumerable<empresasWhereInput>>
  NOT?: XOR<empresasWhereInput, Enumerable<empresasWhereInput>>
  Id?: XOR<IntFilter, number>
  CNPJ?: StringNullableFilter | string | null
  NmEmpresa?: StringNullableFilter | string | null
  NmFantasia?: StringNullableFilter | string | null
  Endereco?: StringNullableFilter | string | null
  CEP?: StringNullableFilter | string | null
  Situacao?: StringNullableFilter | string | null
  Tipo?: StringNullableFilter | string | null
  centrodecustos?: CentrodecustosListRelationFilter
  dados?: DadosListRelationFilter
  economia?: EconomiaListRelationFilter
  escalas?: EscalasListRelationFilter
  operadoras?: OperadorasListRelationFilter
  pedidos?: PedidosListRelationFilter
  tiposocorrencias?: TiposocorrenciasListRelationFilter
}

export type empresasOrderByInput = {
  Id?: SortOrder
  CNPJ?: SortOrder
  NmEmpresa?: SortOrder
  NmFantasia?: SortOrder
  Endereco?: SortOrder
  CEP?: SortOrder
  Situacao?: SortOrder
  Tipo?: SortOrder
}

export type empresasWhereUniqueInput = {
  Id?: number
  CNPJ?: string
}

export type operadorasWhereInput = {
  AND?: XOR<operadorasWhereInput, Enumerable<operadorasWhereInput>>
  OR?: XOR<operadorasWhereInput, Enumerable<operadorasWhereInput>>
  NOT?: XOR<operadorasWhereInput, Enumerable<operadorasWhereInput>>
  Id?: XOR<IntFilter, number>
  NmOperadora?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  UF?: StringNullableFilter | string | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  detalhepedidos_old?: Detalhepedidos_oldListRelationFilter
  passagens?: PassagensListRelationFilter
}

export type operadorasOrderByInput = {
  Id?: SortOrder
  NmOperadora?: SortOrder
  IdEmpresa?: SortOrder
  UF?: SortOrder
}

export type operadorasWhereUniqueInput = {
  Id?: number
}

export type usuariosWhereInput = {
  AND?: XOR<usuariosWhereInput, Enumerable<usuariosWhereInput>>
  OR?: XOR<usuariosWhereInput, Enumerable<usuariosWhereInput>>
  NOT?: XOR<usuariosWhereInput, Enumerable<usuariosWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  Nome?: StringNullableFilter | string | null
  Senha?: StringNullableFilter | string | null
  Email?: StringNullableFilter | string | null
  Lvl?: StringNullableFilter | string | null
}

export type usuariosOrderByInput = {
  Id?: SortOrder
  CPF?: SortOrder
  Nome?: SortOrder
  Senha?: SortOrder
  Email?: SortOrder
  Lvl?: SortOrder
}

export type usuariosWhereUniqueInput = {
  Id?: number
  CPF?: string
  Email?: string
}

export type dadosWhereInput = {
  AND?: XOR<dadosWhereInput, Enumerable<dadosWhereInput>>
  OR?: XOR<dadosWhereInput, Enumerable<dadosWhereInput>>
  NOT?: XOR<dadosWhereInput, Enumerable<dadosWhereInput>>
  Id?: XOR<IntFilter, number>
  NmColaborador?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  DtNascimento?: StringNullableFilter | string | null
  IdCentroDeCusto?: IntNullableFilter | number | null
  Matricula?: StringNullableFilter | string | null
  IdEscala?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
  centrodecustos?: CentrodecustosRelationFilter | centrodecustosWhereInput | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  escalas?: EscalasRelationFilter | escalasWhereInput | null
  detalhepedidos_old?: Detalhepedidos_oldListRelationFilter
  meurh?: MeurhListRelationFilter
  meurhrespostas?: MeurhrespostasListRelationFilter
  solicitacoes?: SolicitacoesListRelationFilter
  suporte?: SuporteListRelationFilter
}

export type dadosOrderByInput = {
  Id?: SortOrder
  NmColaborador?: SortOrder
  CPF?: SortOrder
  IdEmpresa?: SortOrder
  DtNascimento?: SortOrder
  IdCentroDeCusto?: SortOrder
  Matricula?: SortOrder
  IdEscala?: SortOrder
  Situacao?: SortOrder
}

export type dadosWhereUniqueInput = {
  Id?: number
  CPF?: string
}

export type passagensWhereInput = {
  AND?: XOR<passagensWhereInput, Enumerable<passagensWhereInput>>
  OR?: XOR<passagensWhereInput, Enumerable<passagensWhereInput>>
  NOT?: XOR<passagensWhereInput, Enumerable<passagensWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  Valor?: FloatNullableFilter | number | null
  IdOperadora?: IntNullableFilter | number | null
  QtdDia?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
  operadoras?: OperadorasRelationFilter | operadorasWhereInput | null
}

export type passagensOrderByInput = {
  Id?: SortOrder
  CPF?: SortOrder
  NrCartao?: SortOrder
  Valor?: SortOrder
  IdOperadora?: SortOrder
  QtdDia?: SortOrder
  Situacao?: SortOrder
}

export type passagensWhereUniqueInput = {
  Id?: number
}

export type escalasWhereInput = {
  AND?: XOR<escalasWhereInput, Enumerable<escalasWhereInput>>
  OR?: XOR<escalasWhereInput, Enumerable<escalasWhereInput>>
  NOT?: XOR<escalasWhereInput, Enumerable<escalasWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  NmEscala?: StringNullableFilter | string | null
  Folgas?: StringNullableFilter | string | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  dados?: DadosListRelationFilter
  detalhepedidos_old?: Detalhepedidos_oldListRelationFilter
  escalascompetencia?: EscalascompetenciaListRelationFilter
}

export type escalasOrderByInput = {
  Id?: SortOrder
  IdEmpresa?: SortOrder
  NmEscala?: SortOrder
  Folgas?: SortOrder
}

export type escalasWhereUniqueInput = {
  Id?: number
}

export type meurhWhereInput = {
  AND?: XOR<meurhWhereInput, Enumerable<meurhWhereInput>>
  OR?: XOR<meurhWhereInput, Enumerable<meurhWhereInput>>
  NOT?: XOR<meurhWhereInput, Enumerable<meurhWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  DtTicketAbertura?: DateTimeNullableFilter | Date | string | null
  DtTicketFechamento?: DateTimeNullableFilter | Date | string | null
  Assunto?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  Status?: StringNullableFilter | string | null
  dados?: DadosRelationFilter | dadosWhereInput | null
  meurhhistorico?: MeurhhistoricoListRelationFilter
}

export type meurhOrderByInput = {
  Id?: SortOrder
  Protocolo?: SortOrder
  CPF?: SortOrder
  DtTicketAbertura?: SortOrder
  DtTicketFechamento?: SortOrder
  Assunto?: SortOrder
  Msg?: SortOrder
  Status?: SortOrder
}

export type meurhWhereUniqueInput = {
  Id?: number
}

export type ocorrenciasWhereInput = {
  AND?: XOR<ocorrenciasWhereInput, Enumerable<ocorrenciasWhereInput>>
  OR?: XOR<ocorrenciasWhereInput, Enumerable<ocorrenciasWhereInput>>
  NOT?: XOR<ocorrenciasWhereInput, Enumerable<ocorrenciasWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  IdTipoOcorrencia?: IntNullableFilter | number | null
  DtOcorrencia?: DateTimeNullableFilter | Date | string | null
  tiposocorrencias?: TiposocorrenciasRelationFilter | tiposocorrenciasWhereInput | null
}

export type ocorrenciasOrderByInput = {
  Id?: SortOrder
  CPF?: SortOrder
  IdTipoOcorrencia?: SortOrder
  DtOcorrencia?: SortOrder
}

export type ocorrenciasWhereUniqueInput = {
  Id?: number
}

export type tiposocorrenciasWhereInput = {
  AND?: XOR<tiposocorrenciasWhereInput, Enumerable<tiposocorrenciasWhereInput>>
  OR?: XOR<tiposocorrenciasWhereInput, Enumerable<tiposocorrenciasWhereInput>>
  NOT?: XOR<tiposocorrenciasWhereInput, Enumerable<tiposocorrenciasWhereInput>>
  Id?: XOR<IntFilter, number>
  NmOcorrencia?: StringNullableFilter | string | null
  DescBeneficio?: BoolNullableFilter | boolean | null
  IdEmpresa?: IntNullableFilter | number | null
  Descricao?: StringNullableFilter | string | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  ocorrencias?: OcorrenciasListRelationFilter
}

export type tiposocorrenciasOrderByInput = {
  Id?: SortOrder
  NmOcorrencia?: SortOrder
  DescBeneficio?: SortOrder
  IdEmpresa?: SortOrder
  Descricao?: SortOrder
}

export type tiposocorrenciasWhereUniqueInput = {
  Id?: number
}

export type escalascompetenciaWhereInput = {
  AND?: XOR<escalascompetenciaWhereInput, Enumerable<escalascompetenciaWhereInput>>
  OR?: XOR<escalascompetenciaWhereInput, Enumerable<escalascompetenciaWhereInput>>
  NOT?: XOR<escalascompetenciaWhereInput, Enumerable<escalascompetenciaWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEscalas?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  QtdUteis?: IntNullableFilter | number | null
  QtdFolgas?: IntNullableFilter | number | null
  escalas?: EscalasRelationFilter | escalasWhereInput | null
}

export type escalascompetenciaOrderByInput = {
  Id?: SortOrder
  IdEscalas?: SortOrder
  Competencia?: SortOrder
  QtdUteis?: SortOrder
  QtdFolgas?: SortOrder
}

export type escalascompetenciaWhereUniqueInput = {
  Id?: number
}

export type meurhhistoricoWhereInput = {
  AND?: XOR<meurhhistoricoWhereInput, Enumerable<meurhhistoricoWhereInput>>
  OR?: XOR<meurhhistoricoWhereInput, Enumerable<meurhhistoricoWhereInput>>
  NOT?: XOR<meurhhistoricoWhereInput, Enumerable<meurhhistoricoWhereInput>>
  Id?: XOR<IntFilter, number>
  IdMeuRh?: IntNullableFilter | number | null
  StatusAtual?: StringNullableFilter | string | null
  StatusNovo?: StringNullableFilter | string | null
  DtAlteracao?: DateTimeNullableFilter | Date | string | null
  meurh?: MeurhRelationFilter | meurhWhereInput | null
}

export type meurhhistoricoOrderByInput = {
  Id?: SortOrder
  IdMeuRh?: SortOrder
  StatusAtual?: SortOrder
  StatusNovo?: SortOrder
  DtAlteracao?: SortOrder
}

export type meurhhistoricoWhereUniqueInput = {
  Id?: number
}

export type suporteWhereInput = {
  AND?: XOR<suporteWhereInput, Enumerable<suporteWhereInput>>
  OR?: XOR<suporteWhereInput, Enumerable<suporteWhereInput>>
  NOT?: XOR<suporteWhereInput, Enumerable<suporteWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  DtTicketAbertura?: XOR<DateTimeFilter, Date | string>
  DtTicketFechamento?: DateTimeNullableFilter | Date | string | null
  Assunto?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  Avaliacao?: IntNullableFilter | number | null
  Status?: StringNullableFilter | string | null
  dados?: DadosRelationFilter | dadosWhereInput | null
  suportehistorico?: SuportehistoricoListRelationFilter
}

export type suporteOrderByInput = {
  Id?: SortOrder
  Protocolo?: SortOrder
  CPF?: SortOrder
  DtTicketAbertura?: SortOrder
  DtTicketFechamento?: SortOrder
  Assunto?: SortOrder
  Msg?: SortOrder
  Avaliacao?: SortOrder
  Status?: SortOrder
}

export type suporteWhereUniqueInput = {
  Id?: number
}

export type suportehistoricoWhereInput = {
  AND?: XOR<suportehistoricoWhereInput, Enumerable<suportehistoricoWhereInput>>
  OR?: XOR<suportehistoricoWhereInput, Enumerable<suportehistoricoWhereInput>>
  NOT?: XOR<suportehistoricoWhereInput, Enumerable<suportehistoricoWhereInput>>
  Id?: XOR<IntFilter, number>
  IdSuporte?: IntNullableFilter | number | null
  StatusAtual?: StringNullableFilter | string | null
  StatusNovo?: StringNullableFilter | string | null
  DtAlteracao?: DateTimeNullableFilter | Date | string | null
  Msg?: StringNullableFilter | string | null
  suporte?: SuporteRelationFilter | suporteWhereInput | null
}

export type suportehistoricoOrderByInput = {
  Id?: SortOrder
  IdSuporte?: SortOrder
  StatusAtual?: SortOrder
  StatusNovo?: SortOrder
  DtAlteracao?: SortOrder
  Msg?: SortOrder
}

export type suportehistoricoWhereUniqueInput = {
  Id?: number
}

export type meurhrespostasWhereInput = {
  AND?: XOR<meurhrespostasWhereInput, Enumerable<meurhrespostasWhereInput>>
  OR?: XOR<meurhrespostasWhereInput, Enumerable<meurhrespostasWhereInput>>
  NOT?: XOR<meurhrespostasWhereInput, Enumerable<meurhrespostasWhereInput>>
  Id?: XOR<IntFilter, number>
  IdMeuRh?: IntNullableFilter | number | null
  DtResposta?: DateTimeNullableFilter | Date | string | null
  CPF?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  dados?: DadosRelationFilter | dadosWhereInput | null
}

export type meurhrespostasOrderByInput = {
  Id?: SortOrder
  IdMeuRh?: SortOrder
  DtResposta?: SortOrder
  CPF?: SortOrder
  Msg?: SortOrder
}

export type meurhrespostasWhereUniqueInput = {
  Id?: number
}

export type notificationWhereInput = {
  AND?: XOR<notificationWhereInput, Enumerable<notificationWhereInput>>
  OR?: XOR<notificationWhereInput, Enumerable<notificationWhereInput>>
  NOT?: XOR<notificationWhereInput, Enumerable<notificationWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  lido?: BoolNullableFilter | boolean | null
  created_at?: XOR<DateTimeFilter, Date | string>
}

export type notificationOrderByInput = {
  Id?: SortOrder
  CPF?: SortOrder
  Msg?: SortOrder
  lido?: SortOrder
  created_at?: SortOrder
}

export type notificationWhereUniqueInput = {
  Id?: number
}

export type pedidosWhereInput = {
  AND?: XOR<pedidosWhereInput, Enumerable<pedidosWhereInput>>
  OR?: XOR<pedidosWhereInput, Enumerable<pedidosWhereInput>>
  NOT?: XOR<pedidosWhereInput, Enumerable<pedidosWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  DtInicialFolgas?: DateTimeNullableFilter | Date | string | null
  DtFinalFolgas?: DateTimeNullableFilter | Date | string | null
  DtInicialFaltas?: DateTimeNullableFilter | Date | string | null
  DtFinalFaltas?: DateTimeNullableFilter | Date | string | null
  Status?: StringNullableFilter | string | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
  detalhepedidos_old?: Detalhepedidos_oldListRelationFilter
}

export type pedidosOrderByInput = {
  Id?: SortOrder
  IdEmpresa?: SortOrder
  Competencia?: SortOrder
  DtInicialFolgas?: SortOrder
  DtFinalFolgas?: SortOrder
  DtInicialFaltas?: SortOrder
  DtFinalFaltas?: SortOrder
  Status?: SortOrder
}

export type pedidosWhereUniqueInput = {
  Id?: number
}

export type detalhepedidosWhereInput = {
  AND?: XOR<detalhepedidosWhereInput, Enumerable<detalhepedidosWhereInput>>
  OR?: XOR<detalhepedidosWhereInput, Enumerable<detalhepedidosWhereInput>>
  NOT?: XOR<detalhepedidosWhereInput, Enumerable<detalhepedidosWhereInput>>
  Id?: XOR<IntFilter, number>
  IdPedido?: IntNullableFilter | number | null
  NmColaborador?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  IdOperadora?: IntNullableFilter | number | null
  NmOperadora?: StringNullableFilter | string | null
  ValorDia?: FloatNullableFilter | number | null
  NmEscala?: StringNullableFilter | string | null
  QtdOcorrencias?: IntNullableFilter | number | null
  QtdFolgas?: IntNullableFilter | number | null
  QtdDias?: IntNullableFilter | number | null
  QtdDiasUteis?: IntNullableFilter | number | null
  Valor?: FloatNullableFilter | number | null
  Valor_Total?: FloatNullableFilter | number | null
  MemoriaCalculo?: StringNullableFilter | string | null
}

export type detalhepedidosOrderByInput = {
  Id?: SortOrder
  IdPedido?: SortOrder
  NmColaborador?: SortOrder
  CPF?: SortOrder
  NrCartao?: SortOrder
  IdOperadora?: SortOrder
  NmOperadora?: SortOrder
  ValorDia?: SortOrder
  NmEscala?: SortOrder
  QtdOcorrencias?: SortOrder
  QtdFolgas?: SortOrder
  QtdDias?: SortOrder
  QtdDiasUteis?: SortOrder
  Valor?: SortOrder
  Valor_Total?: SortOrder
  MemoriaCalculo?: SortOrder
}

export type detalhepedidosWhereUniqueInput = {
  Id?: number
}

export type detalhepedidos_oldWhereInput = {
  AND?: XOR<detalhepedidos_oldWhereInput, Enumerable<detalhepedidos_oldWhereInput>>
  OR?: XOR<detalhepedidos_oldWhereInput, Enumerable<detalhepedidos_oldWhereInput>>
  NOT?: XOR<detalhepedidos_oldWhereInput, Enumerable<detalhepedidos_oldWhereInput>>
  Id?: XOR<IntFilter, number>
  IdPedido?: IntNullableFilter | number | null
  NmColaborador?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  IdOperadora?: IntNullableFilter | number | null
  NmOperadora?: StringNullableFilter | string | null
  ValorDia?: FloatNullableFilter | number | null
  QtdFolgas?: IntNullableFilter | number | null
  QtdDiasUteis?: IntNullableFilter | number | null
  Valor?: FloatNullableFilter | number | null
  IdEscalas?: IntNullableFilter | number | null
  QtdVale?: IntNullableFilter | number | null
  MemoriaCalculo?: StringNullableFilter | string | null
  dados?: DadosRelationFilter | dadosWhereInput | null
  escalas?: EscalasRelationFilter | escalasWhereInput | null
  operadoras?: OperadorasRelationFilter | operadorasWhereInput | null
  pedidos?: PedidosRelationFilter | pedidosWhereInput | null
}

export type detalhepedidos_oldOrderByInput = {
  Id?: SortOrder
  IdPedido?: SortOrder
  NmColaborador?: SortOrder
  CPF?: SortOrder
  NrCartao?: SortOrder
  IdOperadora?: SortOrder
  NmOperadora?: SortOrder
  ValorDia?: SortOrder
  QtdFolgas?: SortOrder
  QtdDiasUteis?: SortOrder
  Valor?: SortOrder
  IdEscalas?: SortOrder
  QtdVale?: SortOrder
  MemoriaCalculo?: SortOrder
}

export type detalhepedidos_oldWhereUniqueInput = {
  Id?: number
}

export type economiaWhereInput = {
  AND?: XOR<economiaWhereInput, Enumerable<economiaWhereInput>>
  OR?: XOR<economiaWhereInput, Enumerable<economiaWhereInput>>
  NOT?: XOR<economiaWhereInput, Enumerable<economiaWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  Valor?: FloatNullableFilter | number | null
  empresas?: EmpresasRelationFilter | empresasWhereInput | null
}

export type economiaOrderByInput = {
  Id?: SortOrder
  IdEmpresa?: SortOrder
  Competencia?: SortOrder
  Valor?: SortOrder
}

export type economiaWhereUniqueInput = {
  Id?: number
}

export type solicitacoesWhereInput = {
  AND?: XOR<solicitacoesWhereInput, Enumerable<solicitacoesWhereInput>>
  OR?: XOR<solicitacoesWhereInput, Enumerable<solicitacoesWhereInput>>
  NOT?: XOR<solicitacoesWhereInput, Enumerable<solicitacoesWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  TipoSolicitacao?: StringNullableFilter | string | null
  OrigemSolicitacao?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  DtSolicitacao?: XOR<DateTimeFilter, Date | string>
  DtFinalizacao?: DateTimeNullableFilter | Date | string | null
  Status?: StringNullableFilter | string | null
  dados?: DadosRelationFilter | dadosWhereInput | null
}

export type solicitacoesOrderByInput = {
  Id?: SortOrder
  Protocolo?: SortOrder
  CPF?: SortOrder
  TipoSolicitacao?: SortOrder
  OrigemSolicitacao?: SortOrder
  NrCartao?: SortOrder
  DtSolicitacao?: SortOrder
  DtFinalizacao?: SortOrder
  Status?: SortOrder
}

export type solicitacoesWhereUniqueInput = {
  Id?: number
}

export type centrodecustosCreateInput = {
  NmCentroDeCusto?: XOR<string, null>
  Situacao?: XOR<string, null>
  empresas?: empresasCreateOneWithoutCentrodecustosInput
  dados?: dadosCreateManyWithoutCentrodecustosInput
}

export type centrodecustosUpdateInput = {
  NmCentroDeCusto?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutCentrodecustosInput
  dados?: dadosUpdateManyWithoutCentrodecustosInput
}

export type centrodecustosUpdateManyMutationInput = {
  NmCentroDeCusto?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
}

export type empresasCreateInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasUpdateInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpdateManyMutationInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
}

export type operadorasCreateInput = {
  NmOperadora?: XOR<string, null>
  UF?: XOR<string, null>
  empresas?: empresasCreateOneWithoutOperadorasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutOperadorasInput
  passagens?: passagensCreateManyWithoutOperadorasInput
}

export type operadorasUpdateInput = {
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  UF?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutOperadorasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutOperadorasInput
  passagens?: passagensUpdateManyWithoutOperadorasInput
}

export type operadorasUpdateManyMutationInput = {
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  UF?: string | NullableStringFieldUpdateOperationsInput | null
}

export type usuariosCreateInput = {
  CPF?: XOR<string, null>
  Nome?: XOR<string, null>
  Senha?: XOR<string, null>
  Email?: XOR<string, null>
  Lvl?: XOR<string, null>
}

export type usuariosUpdateInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  Nome?: string | NullableStringFieldUpdateOperationsInput | null
  Senha?: string | NullableStringFieldUpdateOperationsInput | null
  Email?: string | NullableStringFieldUpdateOperationsInput | null
  Lvl?: string | NullableStringFieldUpdateOperationsInput | null
}

export type usuariosUpdateManyMutationInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  Nome?: string | NullableStringFieldUpdateOperationsInput | null
  Senha?: string | NullableStringFieldUpdateOperationsInput | null
  Email?: string | NullableStringFieldUpdateOperationsInput | null
  Lvl?: string | NullableStringFieldUpdateOperationsInput | null
}

export type dadosCreateInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosUpdateInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type dadosUpdateManyMutationInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
}

export type passagensCreateInput = {
  CPF?: XOR<string, null>
  NrCartao?: XOR<string, null>
  Valor?: XOR<number, null>
  QtdDia?: XOR<number, null>
  Situacao?: XOR<string, null>
  operadoras?: operadorasCreateOneWithoutPassagensInput
}

export type passagensUpdateInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdDia?: number | NullableIntFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  operadoras?: operadorasUpdateOneWithoutPassagensInput
}

export type passagensUpdateManyMutationInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdDia?: number | NullableIntFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
}

export type escalasCreateInput = {
  NmEscala?: XOR<string, null>
  Folgas?: XOR<string, null>
  empresas?: empresasCreateOneWithoutEscalasInput
  dados?: dadosCreateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaCreateManyWithoutEscalasInput
}

export type escalasUpdateInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutEscalasInput
  dados?: dadosUpdateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaUpdateManyWithoutEscalasInput
}

export type escalasUpdateManyMutationInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
}

export type meurhCreateInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: XOR<Date | string, null>
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Status?: XOR<string, null>
  dados?: dadosCreateOneWithoutMeurhInput
  meurhhistorico?: meurhhistoricoCreateManyWithoutMeurhInput
}

export type meurhUpdateInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutMeurhInput
  meurhhistorico?: meurhhistoricoUpdateManyWithoutMeurhInput
}

export type meurhUpdateManyMutationInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
}

export type ocorrenciasCreateInput = {
  CPF?: XOR<string, null>
  DtOcorrencia?: XOR<Date | string, null>
  tiposocorrencias?: tiposocorrenciasCreateOneWithoutOcorrenciasInput
}

export type ocorrenciasUpdateInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtOcorrencia?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  tiposocorrencias?: tiposocorrenciasUpdateOneWithoutOcorrenciasInput
}

export type ocorrenciasUpdateManyMutationInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtOcorrencia?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type tiposocorrenciasCreateInput = {
  NmOcorrencia?: XOR<string, null>
  DescBeneficio?: XOR<boolean, null>
  Descricao?: XOR<string, null>
  empresas?: empresasCreateOneWithoutTiposocorrenciasInput
  ocorrencias?: ocorrenciasCreateManyWithoutTiposocorrenciasInput
}

export type tiposocorrenciasUpdateInput = {
  NmOcorrencia?: string | NullableStringFieldUpdateOperationsInput | null
  DescBeneficio?: boolean | NullableBoolFieldUpdateOperationsInput | null
  Descricao?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutTiposocorrenciasInput
  ocorrencias?: ocorrenciasUpdateManyWithoutTiposocorrenciasInput
}

export type tiposocorrenciasUpdateManyMutationInput = {
  NmOcorrencia?: string | NullableStringFieldUpdateOperationsInput | null
  DescBeneficio?: boolean | NullableBoolFieldUpdateOperationsInput | null
  Descricao?: string | NullableStringFieldUpdateOperationsInput | null
}

export type escalascompetenciaCreateInput = {
  Competencia?: XOR<string, null>
  QtdUteis?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  escalas?: escalasCreateOneWithoutEscalascompetenciaInput
}

export type escalascompetenciaUpdateInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  QtdUteis?: number | NullableIntFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  escalas?: escalasUpdateOneWithoutEscalascompetenciaInput
}

export type escalascompetenciaUpdateManyMutationInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  QtdUteis?: number | NullableIntFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
}

export type meurhhistoricoCreateInput = {
  StatusAtual?: XOR<string, null>
  StatusNovo?: XOR<string, null>
  DtAlteracao?: XOR<Date | string, null>
  meurh?: meurhCreateOneWithoutMeurhhistoricoInput
}

export type meurhhistoricoUpdateInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  meurh?: meurhUpdateOneWithoutMeurhhistoricoInput
}

export type meurhhistoricoUpdateManyMutationInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type suporteCreateInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: Date | string
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Avaliacao?: XOR<number, null>
  Status?: XOR<string, null>
  dados?: dadosCreateOneWithoutSuporteInput
  suportehistorico?: suportehistoricoCreateManyWithoutSuporteInput
}

export type suporteUpdateInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Avaliacao?: number | NullableIntFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutSuporteInput
  suportehistorico?: suportehistoricoUpdateManyWithoutSuporteInput
}

export type suporteUpdateManyMutationInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Avaliacao?: number | NullableIntFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
}

export type suportehistoricoCreateInput = {
  StatusAtual?: XOR<string, null>
  StatusNovo?: XOR<string, null>
  DtAlteracao?: XOR<Date | string, null>
  Msg?: XOR<string, null>
  suporte?: suporteCreateOneWithoutSuportehistoricoInput
}

export type suportehistoricoUpdateInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  suporte?: suporteUpdateOneWithoutSuportehistoricoInput
}

export type suportehistoricoUpdateManyMutationInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
}

export type meurhrespostasCreateInput = {
  IdMeuRh?: XOR<number, null>
  DtResposta?: XOR<Date | string, null>
  Msg?: XOR<string, null>
  dados?: dadosCreateOneWithoutMeurhrespostasInput
}

export type meurhrespostasUpdateInput = {
  IdMeuRh?: number | NullableIntFieldUpdateOperationsInput | null
  DtResposta?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutMeurhrespostasInput
}

export type meurhrespostasUpdateManyMutationInput = {
  IdMeuRh?: number | NullableIntFieldUpdateOperationsInput | null
  DtResposta?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
}

export type notificationCreateInput = {
  CPF?: XOR<string, null>
  Msg?: XOR<string, null>
  lido?: XOR<boolean, null>
  created_at?: Date | string
}

export type notificationUpdateInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  lido?: boolean | NullableBoolFieldUpdateOperationsInput | null
  created_at?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
}

export type notificationUpdateManyMutationInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  lido?: boolean | NullableBoolFieldUpdateOperationsInput | null
  created_at?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
}

export type pedidosCreateInput = {
  Competencia?: XOR<string, null>
  DtInicialFolgas?: XOR<Date | string, null>
  DtFinalFolgas?: XOR<Date | string, null>
  DtInicialFaltas?: XOR<Date | string, null>
  DtFinalFaltas?: XOR<Date | string, null>
  Status?: XOR<string, null>
  empresas?: empresasCreateOneWithoutPedidosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutPedidosInput
}

export type pedidosUpdateInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  DtInicialFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtInicialFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutPedidosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutPedidosInput
}

export type pedidosUpdateManyMutationInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  DtInicialFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtInicialFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
}

export type detalhepedidosCreateInput = {
  IdPedido?: XOR<number, null>
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  NrCartao?: XOR<string, null>
  IdOperadora?: XOR<number, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  NmEscala?: XOR<string, null>
  QtdOcorrencias?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDias?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  Valor_Total?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
}

export type detalhepedidosUpdateInput = {
  IdPedido?: number | NullableIntFieldUpdateOperationsInput | null
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  IdOperadora?: number | NullableIntFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  QtdOcorrencias?: number | NullableIntFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDias?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  Valor_Total?: number | NullableFloatFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
}

export type detalhepedidosUpdateManyMutationInput = {
  IdPedido?: number | NullableIntFieldUpdateOperationsInput | null
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  IdOperadora?: number | NullableIntFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  QtdOcorrencias?: number | NullableIntFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDias?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  Valor_Total?: number | NullableFloatFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
}

export type detalhepedidos_oldCreateInput = {
  NmColaborador?: XOR<string, null>
  NrCartao?: XOR<string, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  QtdVale?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
  dados?: dadosCreateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasCreateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasCreateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosCreateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldUpdateInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasUpdateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasUpdateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosUpdateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldUpdateManyMutationInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
}

export type economiaCreateInput = {
  Competencia?: XOR<string, null>
  Valor?: XOR<number, null>
  empresas?: empresasCreateOneWithoutEconomiaInput
}

export type economiaUpdateInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutEconomiaInput
}

export type economiaUpdateManyMutationInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
}

export type solicitacoesCreateInput = {
  Protocolo?: XOR<string, null>
  TipoSolicitacao?: XOR<string, null>
  OrigemSolicitacao?: XOR<string, null>
  NrCartao?: XOR<string, null>
  DtSolicitacao?: Date | string
  DtFinalizacao?: XOR<Date | string, null>
  Status?: XOR<string, null>
  dados?: dadosCreateOneWithoutSolicitacoesInput
}

export type solicitacoesUpdateInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  TipoSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  OrigemSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  DtSolicitacao?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtFinalizacao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutSolicitacoesInput
}

export type solicitacoesUpdateManyMutationInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  TipoSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  OrigemSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  DtSolicitacao?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtFinalizacao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: XOR<number, NestedIntFilter>
}

export type StringNullableFilter = {
  equals?: XOR<string, null>
  in?: XOR<Enumerable<string>, null>
  notIn?: XOR<Enumerable<string>, null>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type IntNullableFilter = {
  equals?: XOR<number, null>
  in?: XOR<Enumerable<number>, null>
  notIn?: XOR<Enumerable<number>, null>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type EmpresasRelationFilter = {
  is?: XOR<empresasWhereInput, null>
  isNot?: XOR<empresasWhereInput, null>
}

export type DadosListRelationFilter = {
  every?: dadosWhereInput
  some?: dadosWhereInput
  none?: dadosWhereInput
}

export type CentrodecustosListRelationFilter = {
  every?: centrodecustosWhereInput
  some?: centrodecustosWhereInput
  none?: centrodecustosWhereInput
}

export type EconomiaListRelationFilter = {
  every?: economiaWhereInput
  some?: economiaWhereInput
  none?: economiaWhereInput
}

export type EscalasListRelationFilter = {
  every?: escalasWhereInput
  some?: escalasWhereInput
  none?: escalasWhereInput
}

export type OperadorasListRelationFilter = {
  every?: operadorasWhereInput
  some?: operadorasWhereInput
  none?: operadorasWhereInput
}

export type PedidosListRelationFilter = {
  every?: pedidosWhereInput
  some?: pedidosWhereInput
  none?: pedidosWhereInput
}

export type TiposocorrenciasListRelationFilter = {
  every?: tiposocorrenciasWhereInput
  some?: tiposocorrenciasWhereInput
  none?: tiposocorrenciasWhereInput
}

export type Detalhepedidos_oldListRelationFilter = {
  every?: detalhepedidos_oldWhereInput
  some?: detalhepedidos_oldWhereInput
  none?: detalhepedidos_oldWhereInput
}

export type PassagensListRelationFilter = {
  every?: passagensWhereInput
  some?: passagensWhereInput
  none?: passagensWhereInput
}

export type CentrodecustosRelationFilter = {
  is?: XOR<centrodecustosWhereInput, null>
  isNot?: XOR<centrodecustosWhereInput, null>
}

export type EscalasRelationFilter = {
  is?: XOR<escalasWhereInput, null>
  isNot?: XOR<escalasWhereInput, null>
}

export type MeurhListRelationFilter = {
  every?: meurhWhereInput
  some?: meurhWhereInput
  none?: meurhWhereInput
}

export type MeurhrespostasListRelationFilter = {
  every?: meurhrespostasWhereInput
  some?: meurhrespostasWhereInput
  none?: meurhrespostasWhereInput
}

export type SolicitacoesListRelationFilter = {
  every?: solicitacoesWhereInput
  some?: solicitacoesWhereInput
  none?: solicitacoesWhereInput
}

export type SuporteListRelationFilter = {
  every?: suporteWhereInput
  some?: suporteWhereInput
  none?: suporteWhereInput
}

export type FloatNullableFilter = {
  equals?: XOR<number, null>
  in?: XOR<Enumerable<number>, null>
  notIn?: XOR<Enumerable<number>, null>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type OperadorasRelationFilter = {
  is?: XOR<operadorasWhereInput, null>
  isNot?: XOR<operadorasWhereInput, null>
}

export type EscalascompetenciaListRelationFilter = {
  every?: escalascompetenciaWhereInput
  some?: escalascompetenciaWhereInput
  none?: escalascompetenciaWhereInput
}

export type DateTimeNullableFilter = {
  equals?: XOR<Date | string, null>
  in?: XOR<Enumerable<Date> | Enumerable<string>, null>
  notIn?: XOR<Enumerable<Date> | Enumerable<string>, null>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type DadosRelationFilter = {
  is?: XOR<dadosWhereInput, null>
  isNot?: XOR<dadosWhereInput, null>
}

export type MeurhhistoricoListRelationFilter = {
  every?: meurhhistoricoWhereInput
  some?: meurhhistoricoWhereInput
  none?: meurhhistoricoWhereInput
}

export type TiposocorrenciasRelationFilter = {
  is?: XOR<tiposocorrenciasWhereInput, null>
  isNot?: XOR<tiposocorrenciasWhereInput, null>
}

export type BoolNullableFilter = {
  equals?: XOR<boolean, null>
  not?: boolean | NestedBoolNullableFilter | null
}

export type OcorrenciasListRelationFilter = {
  every?: ocorrenciasWhereInput
  some?: ocorrenciasWhereInput
  none?: ocorrenciasWhereInput
}

export type MeurhRelationFilter = {
  is?: XOR<meurhWhereInput, null>
  isNot?: XOR<meurhWhereInput, null>
}

export type DateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date> | Enumerable<string>
  notIn?: Enumerable<Date> | Enumerable<string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: XOR<Date | string, NestedDateTimeFilter>
}

export type SuportehistoricoListRelationFilter = {
  every?: suportehistoricoWhereInput
  some?: suportehistoricoWhereInput
  none?: suportehistoricoWhereInput
}

export type SuporteRelationFilter = {
  is?: XOR<suporteWhereInput, null>
  isNot?: XOR<suporteWhereInput, null>
}

export type PedidosRelationFilter = {
  is?: XOR<pedidosWhereInput, null>
  isNot?: XOR<pedidosWhereInput, null>
}

export type empresasCreateOneWithoutCentrodecustosInput = {
  create?: empresasCreateWithoutCentrodecustosInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithoutcentrodecustosInput
}

export type dadosCreateManyWithoutCentrodecustosInput = {
  create?: XOR<dadosCreateWithoutCentrodecustosInput, Enumerable<dadosCreateWithoutCentrodecustosInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutcentrodecustosInput, Enumerable<dadosCreateOrConnectWithoutcentrodecustosInput>>
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: XOR<string, null>
}

export type empresasUpdateOneWithoutCentrodecustosInput = {
  create?: empresasCreateWithoutCentrodecustosInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutCentrodecustosInput
  upsert?: empresasUpsertWithoutCentrodecustosInput
  connectOrCreate?: empresasCreateOrConnectWithoutcentrodecustosInput
}

export type dadosUpdateManyWithoutCentrodecustosInput = {
  create?: XOR<dadosCreateWithoutCentrodecustosInput, Enumerable<dadosCreateWithoutCentrodecustosInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  set?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  disconnect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  delete?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  update?: XOR<dadosUpdateWithWhereUniqueWithoutCentrodecustosInput, Enumerable<dadosUpdateWithWhereUniqueWithoutCentrodecustosInput>>
  updateMany?: XOR<dadosUpdateManyWithWhereWithoutCentrodecustosInput, Enumerable<dadosUpdateManyWithWhereWithoutCentrodecustosInput>>
  deleteMany?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  upsert?: XOR<dadosUpsertWithWhereUniqueWithoutCentrodecustosInput, Enumerable<dadosUpsertWithWhereUniqueWithoutCentrodecustosInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutcentrodecustosInput, Enumerable<dadosCreateOrConnectWithoutcentrodecustosInput>>
}

export type centrodecustosCreateManyWithoutEmpresasInput = {
  create?: XOR<centrodecustosCreateWithoutEmpresasInput, Enumerable<centrodecustosCreateWithoutEmpresasInput>>
  connect?: XOR<centrodecustosWhereUniqueInput, Enumerable<centrodecustosWhereUniqueInput>>
  connectOrCreate?: XOR<centrodecustosCreateOrConnectWithoutempresasInput, Enumerable<centrodecustosCreateOrConnectWithoutempresasInput>>
}

export type dadosCreateManyWithoutEmpresasInput = {
  create?: XOR<dadosCreateWithoutEmpresasInput, Enumerable<dadosCreateWithoutEmpresasInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutempresasInput, Enumerable<dadosCreateOrConnectWithoutempresasInput>>
}

export type economiaCreateManyWithoutEmpresasInput = {
  create?: XOR<economiaCreateWithoutEmpresasInput, Enumerable<economiaCreateWithoutEmpresasInput>>
  connect?: XOR<economiaWhereUniqueInput, Enumerable<economiaWhereUniqueInput>>
  connectOrCreate?: XOR<economiaCreateOrConnectWithoutempresasInput, Enumerable<economiaCreateOrConnectWithoutempresasInput>>
}

export type escalasCreateManyWithoutEmpresasInput = {
  create?: XOR<escalasCreateWithoutEmpresasInput, Enumerable<escalasCreateWithoutEmpresasInput>>
  connect?: XOR<escalasWhereUniqueInput, Enumerable<escalasWhereUniqueInput>>
  connectOrCreate?: XOR<escalasCreateOrConnectWithoutempresasInput, Enumerable<escalasCreateOrConnectWithoutempresasInput>>
}

export type operadorasCreateManyWithoutEmpresasInput = {
  create?: XOR<operadorasCreateWithoutEmpresasInput, Enumerable<operadorasCreateWithoutEmpresasInput>>
  connect?: XOR<operadorasWhereUniqueInput, Enumerable<operadorasWhereUniqueInput>>
  connectOrCreate?: XOR<operadorasCreateOrConnectWithoutempresasInput, Enumerable<operadorasCreateOrConnectWithoutempresasInput>>
}

export type pedidosCreateManyWithoutEmpresasInput = {
  create?: XOR<pedidosCreateWithoutEmpresasInput, Enumerable<pedidosCreateWithoutEmpresasInput>>
  connect?: XOR<pedidosWhereUniqueInput, Enumerable<pedidosWhereUniqueInput>>
  connectOrCreate?: XOR<pedidosCreateOrConnectWithoutempresasInput, Enumerable<pedidosCreateOrConnectWithoutempresasInput>>
}

export type tiposocorrenciasCreateManyWithoutEmpresasInput = {
  create?: XOR<tiposocorrenciasCreateWithoutEmpresasInput, Enumerable<tiposocorrenciasCreateWithoutEmpresasInput>>
  connect?: XOR<tiposocorrenciasWhereUniqueInput, Enumerable<tiposocorrenciasWhereUniqueInput>>
  connectOrCreate?: XOR<tiposocorrenciasCreateOrConnectWithoutempresasInput, Enumerable<tiposocorrenciasCreateOrConnectWithoutempresasInput>>
}

export type centrodecustosUpdateManyWithoutEmpresasInput = {
  create?: XOR<centrodecustosCreateWithoutEmpresasInput, Enumerable<centrodecustosCreateWithoutEmpresasInput>>
  connect?: XOR<centrodecustosWhereUniqueInput, Enumerable<centrodecustosWhereUniqueInput>>
  set?: XOR<centrodecustosWhereUniqueInput, Enumerable<centrodecustosWhereUniqueInput>>
  disconnect?: XOR<centrodecustosWhereUniqueInput, Enumerable<centrodecustosWhereUniqueInput>>
  delete?: XOR<centrodecustosWhereUniqueInput, Enumerable<centrodecustosWhereUniqueInput>>
  update?: XOR<centrodecustosUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<centrodecustosUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<centrodecustosUpdateManyWithWhereWithoutEmpresasInput, Enumerable<centrodecustosUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<centrodecustosScalarWhereInput, Enumerable<centrodecustosScalarWhereInput>>
  upsert?: XOR<centrodecustosUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<centrodecustosUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<centrodecustosCreateOrConnectWithoutempresasInput, Enumerable<centrodecustosCreateOrConnectWithoutempresasInput>>
}

export type dadosUpdateManyWithoutEmpresasInput = {
  create?: XOR<dadosCreateWithoutEmpresasInput, Enumerable<dadosCreateWithoutEmpresasInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  set?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  disconnect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  delete?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  update?: XOR<dadosUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<dadosUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<dadosUpdateManyWithWhereWithoutEmpresasInput, Enumerable<dadosUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  upsert?: XOR<dadosUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<dadosUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutempresasInput, Enumerable<dadosCreateOrConnectWithoutempresasInput>>
}

export type economiaUpdateManyWithoutEmpresasInput = {
  create?: XOR<economiaCreateWithoutEmpresasInput, Enumerable<economiaCreateWithoutEmpresasInput>>
  connect?: XOR<economiaWhereUniqueInput, Enumerable<economiaWhereUniqueInput>>
  set?: XOR<economiaWhereUniqueInput, Enumerable<economiaWhereUniqueInput>>
  disconnect?: XOR<economiaWhereUniqueInput, Enumerable<economiaWhereUniqueInput>>
  delete?: XOR<economiaWhereUniqueInput, Enumerable<economiaWhereUniqueInput>>
  update?: XOR<economiaUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<economiaUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<economiaUpdateManyWithWhereWithoutEmpresasInput, Enumerable<economiaUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<economiaScalarWhereInput, Enumerable<economiaScalarWhereInput>>
  upsert?: XOR<economiaUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<economiaUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<economiaCreateOrConnectWithoutempresasInput, Enumerable<economiaCreateOrConnectWithoutempresasInput>>
}

export type escalasUpdateManyWithoutEmpresasInput = {
  create?: XOR<escalasCreateWithoutEmpresasInput, Enumerable<escalasCreateWithoutEmpresasInput>>
  connect?: XOR<escalasWhereUniqueInput, Enumerable<escalasWhereUniqueInput>>
  set?: XOR<escalasWhereUniqueInput, Enumerable<escalasWhereUniqueInput>>
  disconnect?: XOR<escalasWhereUniqueInput, Enumerable<escalasWhereUniqueInput>>
  delete?: XOR<escalasWhereUniqueInput, Enumerable<escalasWhereUniqueInput>>
  update?: XOR<escalasUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<escalasUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<escalasUpdateManyWithWhereWithoutEmpresasInput, Enumerable<escalasUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<escalasScalarWhereInput, Enumerable<escalasScalarWhereInput>>
  upsert?: XOR<escalasUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<escalasUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<escalasCreateOrConnectWithoutempresasInput, Enumerable<escalasCreateOrConnectWithoutempresasInput>>
}

export type operadorasUpdateManyWithoutEmpresasInput = {
  create?: XOR<operadorasCreateWithoutEmpresasInput, Enumerable<operadorasCreateWithoutEmpresasInput>>
  connect?: XOR<operadorasWhereUniqueInput, Enumerable<operadorasWhereUniqueInput>>
  set?: XOR<operadorasWhereUniqueInput, Enumerable<operadorasWhereUniqueInput>>
  disconnect?: XOR<operadorasWhereUniqueInput, Enumerable<operadorasWhereUniqueInput>>
  delete?: XOR<operadorasWhereUniqueInput, Enumerable<operadorasWhereUniqueInput>>
  update?: XOR<operadorasUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<operadorasUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<operadorasUpdateManyWithWhereWithoutEmpresasInput, Enumerable<operadorasUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<operadorasScalarWhereInput, Enumerable<operadorasScalarWhereInput>>
  upsert?: XOR<operadorasUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<operadorasUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<operadorasCreateOrConnectWithoutempresasInput, Enumerable<operadorasCreateOrConnectWithoutempresasInput>>
}

export type pedidosUpdateManyWithoutEmpresasInput = {
  create?: XOR<pedidosCreateWithoutEmpresasInput, Enumerable<pedidosCreateWithoutEmpresasInput>>
  connect?: XOR<pedidosWhereUniqueInput, Enumerable<pedidosWhereUniqueInput>>
  set?: XOR<pedidosWhereUniqueInput, Enumerable<pedidosWhereUniqueInput>>
  disconnect?: XOR<pedidosWhereUniqueInput, Enumerable<pedidosWhereUniqueInput>>
  delete?: XOR<pedidosWhereUniqueInput, Enumerable<pedidosWhereUniqueInput>>
  update?: XOR<pedidosUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<pedidosUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<pedidosUpdateManyWithWhereWithoutEmpresasInput, Enumerable<pedidosUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<pedidosScalarWhereInput, Enumerable<pedidosScalarWhereInput>>
  upsert?: XOR<pedidosUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<pedidosUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<pedidosCreateOrConnectWithoutempresasInput, Enumerable<pedidosCreateOrConnectWithoutempresasInput>>
}

export type tiposocorrenciasUpdateManyWithoutEmpresasInput = {
  create?: XOR<tiposocorrenciasCreateWithoutEmpresasInput, Enumerable<tiposocorrenciasCreateWithoutEmpresasInput>>
  connect?: XOR<tiposocorrenciasWhereUniqueInput, Enumerable<tiposocorrenciasWhereUniqueInput>>
  set?: XOR<tiposocorrenciasWhereUniqueInput, Enumerable<tiposocorrenciasWhereUniqueInput>>
  disconnect?: XOR<tiposocorrenciasWhereUniqueInput, Enumerable<tiposocorrenciasWhereUniqueInput>>
  delete?: XOR<tiposocorrenciasWhereUniqueInput, Enumerable<tiposocorrenciasWhereUniqueInput>>
  update?: XOR<tiposocorrenciasUpdateWithWhereUniqueWithoutEmpresasInput, Enumerable<tiposocorrenciasUpdateWithWhereUniqueWithoutEmpresasInput>>
  updateMany?: XOR<tiposocorrenciasUpdateManyWithWhereWithoutEmpresasInput, Enumerable<tiposocorrenciasUpdateManyWithWhereWithoutEmpresasInput>>
  deleteMany?: XOR<tiposocorrenciasScalarWhereInput, Enumerable<tiposocorrenciasScalarWhereInput>>
  upsert?: XOR<tiposocorrenciasUpsertWithWhereUniqueWithoutEmpresasInput, Enumerable<tiposocorrenciasUpsertWithWhereUniqueWithoutEmpresasInput>>
  connectOrCreate?: XOR<tiposocorrenciasCreateOrConnectWithoutempresasInput, Enumerable<tiposocorrenciasCreateOrConnectWithoutempresasInput>>
}

export type empresasCreateOneWithoutOperadorasInput = {
  create?: empresasCreateWithoutOperadorasInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithoutoperadorasInput
}

export type detalhepedidos_oldCreateManyWithoutOperadorasInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutOperadorasInput, Enumerable<detalhepedidos_oldCreateWithoutOperadorasInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutoperadorasInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutoperadorasInput>>
}

export type passagensCreateManyWithoutOperadorasInput = {
  create?: XOR<passagensCreateWithoutOperadorasInput, Enumerable<passagensCreateWithoutOperadorasInput>>
  connect?: XOR<passagensWhereUniqueInput, Enumerable<passagensWhereUniqueInput>>
  connectOrCreate?: XOR<passagensCreateOrConnectWithoutoperadorasInput, Enumerable<passagensCreateOrConnectWithoutoperadorasInput>>
}

export type empresasUpdateOneWithoutOperadorasInput = {
  create?: empresasCreateWithoutOperadorasInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutOperadorasInput
  upsert?: empresasUpsertWithoutOperadorasInput
  connectOrCreate?: empresasCreateOrConnectWithoutoperadorasInput
}

export type detalhepedidos_oldUpdateManyWithoutOperadorasInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutOperadorasInput, Enumerable<detalhepedidos_oldCreateWithoutOperadorasInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  set?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  disconnect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  delete?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  update?: XOR<detalhepedidos_oldUpdateWithWhereUniqueWithoutOperadorasInput, Enumerable<detalhepedidos_oldUpdateWithWhereUniqueWithoutOperadorasInput>>
  updateMany?: XOR<detalhepedidos_oldUpdateManyWithWhereWithoutOperadorasInput, Enumerable<detalhepedidos_oldUpdateManyWithWhereWithoutOperadorasInput>>
  deleteMany?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  upsert?: XOR<detalhepedidos_oldUpsertWithWhereUniqueWithoutOperadorasInput, Enumerable<detalhepedidos_oldUpsertWithWhereUniqueWithoutOperadorasInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutoperadorasInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutoperadorasInput>>
}

export type passagensUpdateManyWithoutOperadorasInput = {
  create?: XOR<passagensCreateWithoutOperadorasInput, Enumerable<passagensCreateWithoutOperadorasInput>>
  connect?: XOR<passagensWhereUniqueInput, Enumerable<passagensWhereUniqueInput>>
  set?: XOR<passagensWhereUniqueInput, Enumerable<passagensWhereUniqueInput>>
  disconnect?: XOR<passagensWhereUniqueInput, Enumerable<passagensWhereUniqueInput>>
  delete?: XOR<passagensWhereUniqueInput, Enumerable<passagensWhereUniqueInput>>
  update?: XOR<passagensUpdateWithWhereUniqueWithoutOperadorasInput, Enumerable<passagensUpdateWithWhereUniqueWithoutOperadorasInput>>
  updateMany?: XOR<passagensUpdateManyWithWhereWithoutOperadorasInput, Enumerable<passagensUpdateManyWithWhereWithoutOperadorasInput>>
  deleteMany?: XOR<passagensScalarWhereInput, Enumerable<passagensScalarWhereInput>>
  upsert?: XOR<passagensUpsertWithWhereUniqueWithoutOperadorasInput, Enumerable<passagensUpsertWithWhereUniqueWithoutOperadorasInput>>
  connectOrCreate?: XOR<passagensCreateOrConnectWithoutoperadorasInput, Enumerable<passagensCreateOrConnectWithoutoperadorasInput>>
}

export type centrodecustosCreateOneWithoutDadosInput = {
  create?: centrodecustosCreateWithoutDadosInput
  connect?: centrodecustosWhereUniqueInput
  connectOrCreate?: centrodecustosCreateOrConnectWithoutdadosInput
}

export type empresasCreateOneWithoutDadosInput = {
  create?: empresasCreateWithoutDadosInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithoutdadosInput
}

export type escalasCreateOneWithoutDadosInput = {
  create?: escalasCreateWithoutDadosInput
  connect?: escalasWhereUniqueInput
  connectOrCreate?: escalasCreateOrConnectWithoutdadosInput
}

export type detalhepedidos_oldCreateManyWithoutDadosInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutDadosInput, Enumerable<detalhepedidos_oldCreateWithoutDadosInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutdadosInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutdadosInput>>
}

export type meurhCreateManyWithoutDadosInput = {
  create?: XOR<meurhCreateWithoutDadosInput, Enumerable<meurhCreateWithoutDadosInput>>
  connect?: XOR<meurhWhereUniqueInput, Enumerable<meurhWhereUniqueInput>>
  connectOrCreate?: XOR<meurhCreateOrConnectWithoutdadosInput, Enumerable<meurhCreateOrConnectWithoutdadosInput>>
}

export type meurhrespostasCreateManyWithoutDadosInput = {
  create?: XOR<meurhrespostasCreateWithoutDadosInput, Enumerable<meurhrespostasCreateWithoutDadosInput>>
  connect?: XOR<meurhrespostasWhereUniqueInput, Enumerable<meurhrespostasWhereUniqueInput>>
  connectOrCreate?: XOR<meurhrespostasCreateOrConnectWithoutdadosInput, Enumerable<meurhrespostasCreateOrConnectWithoutdadosInput>>
}

export type solicitacoesCreateManyWithoutDadosInput = {
  create?: XOR<solicitacoesCreateWithoutDadosInput, Enumerable<solicitacoesCreateWithoutDadosInput>>
  connect?: XOR<solicitacoesWhereUniqueInput, Enumerable<solicitacoesWhereUniqueInput>>
  connectOrCreate?: XOR<solicitacoesCreateOrConnectWithoutdadosInput, Enumerable<solicitacoesCreateOrConnectWithoutdadosInput>>
}

export type suporteCreateManyWithoutDadosInput = {
  create?: XOR<suporteCreateWithoutDadosInput, Enumerable<suporteCreateWithoutDadosInput>>
  connect?: XOR<suporteWhereUniqueInput, Enumerable<suporteWhereUniqueInput>>
  connectOrCreate?: XOR<suporteCreateOrConnectWithoutdadosInput, Enumerable<suporteCreateOrConnectWithoutdadosInput>>
}

export type centrodecustosUpdateOneWithoutDadosInput = {
  create?: centrodecustosCreateWithoutDadosInput
  connect?: centrodecustosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: centrodecustosUpdateWithoutDadosInput
  upsert?: centrodecustosUpsertWithoutDadosInput
  connectOrCreate?: centrodecustosCreateOrConnectWithoutdadosInput
}

export type empresasUpdateOneWithoutDadosInput = {
  create?: empresasCreateWithoutDadosInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutDadosInput
  upsert?: empresasUpsertWithoutDadosInput
  connectOrCreate?: empresasCreateOrConnectWithoutdadosInput
}

export type escalasUpdateOneWithoutDadosInput = {
  create?: escalasCreateWithoutDadosInput
  connect?: escalasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: escalasUpdateWithoutDadosInput
  upsert?: escalasUpsertWithoutDadosInput
  connectOrCreate?: escalasCreateOrConnectWithoutdadosInput
}

export type detalhepedidos_oldUpdateManyWithoutDadosInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutDadosInput, Enumerable<detalhepedidos_oldCreateWithoutDadosInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  set?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  disconnect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  delete?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  update?: XOR<detalhepedidos_oldUpdateWithWhereUniqueWithoutDadosInput, Enumerable<detalhepedidos_oldUpdateWithWhereUniqueWithoutDadosInput>>
  updateMany?: XOR<detalhepedidos_oldUpdateManyWithWhereWithoutDadosInput, Enumerable<detalhepedidos_oldUpdateManyWithWhereWithoutDadosInput>>
  deleteMany?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  upsert?: XOR<detalhepedidos_oldUpsertWithWhereUniqueWithoutDadosInput, Enumerable<detalhepedidos_oldUpsertWithWhereUniqueWithoutDadosInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutdadosInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutdadosInput>>
}

export type meurhUpdateManyWithoutDadosInput = {
  create?: XOR<meurhCreateWithoutDadosInput, Enumerable<meurhCreateWithoutDadosInput>>
  connect?: XOR<meurhWhereUniqueInput, Enumerable<meurhWhereUniqueInput>>
  set?: XOR<meurhWhereUniqueInput, Enumerable<meurhWhereUniqueInput>>
  disconnect?: XOR<meurhWhereUniqueInput, Enumerable<meurhWhereUniqueInput>>
  delete?: XOR<meurhWhereUniqueInput, Enumerable<meurhWhereUniqueInput>>
  update?: XOR<meurhUpdateWithWhereUniqueWithoutDadosInput, Enumerable<meurhUpdateWithWhereUniqueWithoutDadosInput>>
  updateMany?: XOR<meurhUpdateManyWithWhereWithoutDadosInput, Enumerable<meurhUpdateManyWithWhereWithoutDadosInput>>
  deleteMany?: XOR<meurhScalarWhereInput, Enumerable<meurhScalarWhereInput>>
  upsert?: XOR<meurhUpsertWithWhereUniqueWithoutDadosInput, Enumerable<meurhUpsertWithWhereUniqueWithoutDadosInput>>
  connectOrCreate?: XOR<meurhCreateOrConnectWithoutdadosInput, Enumerable<meurhCreateOrConnectWithoutdadosInput>>
}

export type meurhrespostasUpdateManyWithoutDadosInput = {
  create?: XOR<meurhrespostasCreateWithoutDadosInput, Enumerable<meurhrespostasCreateWithoutDadosInput>>
  connect?: XOR<meurhrespostasWhereUniqueInput, Enumerable<meurhrespostasWhereUniqueInput>>
  set?: XOR<meurhrespostasWhereUniqueInput, Enumerable<meurhrespostasWhereUniqueInput>>
  disconnect?: XOR<meurhrespostasWhereUniqueInput, Enumerable<meurhrespostasWhereUniqueInput>>
  delete?: XOR<meurhrespostasWhereUniqueInput, Enumerable<meurhrespostasWhereUniqueInput>>
  update?: XOR<meurhrespostasUpdateWithWhereUniqueWithoutDadosInput, Enumerable<meurhrespostasUpdateWithWhereUniqueWithoutDadosInput>>
  updateMany?: XOR<meurhrespostasUpdateManyWithWhereWithoutDadosInput, Enumerable<meurhrespostasUpdateManyWithWhereWithoutDadosInput>>
  deleteMany?: XOR<meurhrespostasScalarWhereInput, Enumerable<meurhrespostasScalarWhereInput>>
  upsert?: XOR<meurhrespostasUpsertWithWhereUniqueWithoutDadosInput, Enumerable<meurhrespostasUpsertWithWhereUniqueWithoutDadosInput>>
  connectOrCreate?: XOR<meurhrespostasCreateOrConnectWithoutdadosInput, Enumerable<meurhrespostasCreateOrConnectWithoutdadosInput>>
}

export type solicitacoesUpdateManyWithoutDadosInput = {
  create?: XOR<solicitacoesCreateWithoutDadosInput, Enumerable<solicitacoesCreateWithoutDadosInput>>
  connect?: XOR<solicitacoesWhereUniqueInput, Enumerable<solicitacoesWhereUniqueInput>>
  set?: XOR<solicitacoesWhereUniqueInput, Enumerable<solicitacoesWhereUniqueInput>>
  disconnect?: XOR<solicitacoesWhereUniqueInput, Enumerable<solicitacoesWhereUniqueInput>>
  delete?: XOR<solicitacoesWhereUniqueInput, Enumerable<solicitacoesWhereUniqueInput>>
  update?: XOR<solicitacoesUpdateWithWhereUniqueWithoutDadosInput, Enumerable<solicitacoesUpdateWithWhereUniqueWithoutDadosInput>>
  updateMany?: XOR<solicitacoesUpdateManyWithWhereWithoutDadosInput, Enumerable<solicitacoesUpdateManyWithWhereWithoutDadosInput>>
  deleteMany?: XOR<solicitacoesScalarWhereInput, Enumerable<solicitacoesScalarWhereInput>>
  upsert?: XOR<solicitacoesUpsertWithWhereUniqueWithoutDadosInput, Enumerable<solicitacoesUpsertWithWhereUniqueWithoutDadosInput>>
  connectOrCreate?: XOR<solicitacoesCreateOrConnectWithoutdadosInput, Enumerable<solicitacoesCreateOrConnectWithoutdadosInput>>
}

export type suporteUpdateManyWithoutDadosInput = {
  create?: XOR<suporteCreateWithoutDadosInput, Enumerable<suporteCreateWithoutDadosInput>>
  connect?: XOR<suporteWhereUniqueInput, Enumerable<suporteWhereUniqueInput>>
  set?: XOR<suporteWhereUniqueInput, Enumerable<suporteWhereUniqueInput>>
  disconnect?: XOR<suporteWhereUniqueInput, Enumerable<suporteWhereUniqueInput>>
  delete?: XOR<suporteWhereUniqueInput, Enumerable<suporteWhereUniqueInput>>
  update?: XOR<suporteUpdateWithWhereUniqueWithoutDadosInput, Enumerable<suporteUpdateWithWhereUniqueWithoutDadosInput>>
  updateMany?: XOR<suporteUpdateManyWithWhereWithoutDadosInput, Enumerable<suporteUpdateManyWithWhereWithoutDadosInput>>
  deleteMany?: XOR<suporteScalarWhereInput, Enumerable<suporteScalarWhereInput>>
  upsert?: XOR<suporteUpsertWithWhereUniqueWithoutDadosInput, Enumerable<suporteUpsertWithWhereUniqueWithoutDadosInput>>
  connectOrCreate?: XOR<suporteCreateOrConnectWithoutdadosInput, Enumerable<suporteCreateOrConnectWithoutdadosInput>>
}

export type operadorasCreateOneWithoutPassagensInput = {
  create?: operadorasCreateWithoutPassagensInput
  connect?: operadorasWhereUniqueInput
  connectOrCreate?: operadorasCreateOrConnectWithoutpassagensInput
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: XOR<number, null>
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: XOR<number, null>
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type operadorasUpdateOneWithoutPassagensInput = {
  create?: operadorasCreateWithoutPassagensInput
  connect?: operadorasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: operadorasUpdateWithoutPassagensInput
  upsert?: operadorasUpsertWithoutPassagensInput
  connectOrCreate?: operadorasCreateOrConnectWithoutpassagensInput
}

export type empresasCreateOneWithoutEscalasInput = {
  create?: empresasCreateWithoutEscalasInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithoutescalasInput
}

export type dadosCreateManyWithoutEscalasInput = {
  create?: XOR<dadosCreateWithoutEscalasInput, Enumerable<dadosCreateWithoutEscalasInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutescalasInput, Enumerable<dadosCreateOrConnectWithoutescalasInput>>
}

export type detalhepedidos_oldCreateManyWithoutEscalasInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutEscalasInput, Enumerable<detalhepedidos_oldCreateWithoutEscalasInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutescalasInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutescalasInput>>
}

export type escalascompetenciaCreateManyWithoutEscalasInput = {
  create?: XOR<escalascompetenciaCreateWithoutEscalasInput, Enumerable<escalascompetenciaCreateWithoutEscalasInput>>
  connect?: XOR<escalascompetenciaWhereUniqueInput, Enumerable<escalascompetenciaWhereUniqueInput>>
  connectOrCreate?: XOR<escalascompetenciaCreateOrConnectWithoutescalasInput, Enumerable<escalascompetenciaCreateOrConnectWithoutescalasInput>>
}

export type empresasUpdateOneWithoutEscalasInput = {
  create?: empresasCreateWithoutEscalasInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutEscalasInput
  upsert?: empresasUpsertWithoutEscalasInput
  connectOrCreate?: empresasCreateOrConnectWithoutescalasInput
}

export type dadosUpdateManyWithoutEscalasInput = {
  create?: XOR<dadosCreateWithoutEscalasInput, Enumerable<dadosCreateWithoutEscalasInput>>
  connect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  set?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  disconnect?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  delete?: XOR<dadosWhereUniqueInput, Enumerable<dadosWhereUniqueInput>>
  update?: XOR<dadosUpdateWithWhereUniqueWithoutEscalasInput, Enumerable<dadosUpdateWithWhereUniqueWithoutEscalasInput>>
  updateMany?: XOR<dadosUpdateManyWithWhereWithoutEscalasInput, Enumerable<dadosUpdateManyWithWhereWithoutEscalasInput>>
  deleteMany?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  upsert?: XOR<dadosUpsertWithWhereUniqueWithoutEscalasInput, Enumerable<dadosUpsertWithWhereUniqueWithoutEscalasInput>>
  connectOrCreate?: XOR<dadosCreateOrConnectWithoutescalasInput, Enumerable<dadosCreateOrConnectWithoutescalasInput>>
}

export type detalhepedidos_oldUpdateManyWithoutEscalasInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutEscalasInput, Enumerable<detalhepedidos_oldCreateWithoutEscalasInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  set?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  disconnect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  delete?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  update?: XOR<detalhepedidos_oldUpdateWithWhereUniqueWithoutEscalasInput, Enumerable<detalhepedidos_oldUpdateWithWhereUniqueWithoutEscalasInput>>
  updateMany?: XOR<detalhepedidos_oldUpdateManyWithWhereWithoutEscalasInput, Enumerable<detalhepedidos_oldUpdateManyWithWhereWithoutEscalasInput>>
  deleteMany?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  upsert?: XOR<detalhepedidos_oldUpsertWithWhereUniqueWithoutEscalasInput, Enumerable<detalhepedidos_oldUpsertWithWhereUniqueWithoutEscalasInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutescalasInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutescalasInput>>
}

export type escalascompetenciaUpdateManyWithoutEscalasInput = {
  create?: XOR<escalascompetenciaCreateWithoutEscalasInput, Enumerable<escalascompetenciaCreateWithoutEscalasInput>>
  connect?: XOR<escalascompetenciaWhereUniqueInput, Enumerable<escalascompetenciaWhereUniqueInput>>
  set?: XOR<escalascompetenciaWhereUniqueInput, Enumerable<escalascompetenciaWhereUniqueInput>>
  disconnect?: XOR<escalascompetenciaWhereUniqueInput, Enumerable<escalascompetenciaWhereUniqueInput>>
  delete?: XOR<escalascompetenciaWhereUniqueInput, Enumerable<escalascompetenciaWhereUniqueInput>>
  update?: XOR<escalascompetenciaUpdateWithWhereUniqueWithoutEscalasInput, Enumerable<escalascompetenciaUpdateWithWhereUniqueWithoutEscalasInput>>
  updateMany?: XOR<escalascompetenciaUpdateManyWithWhereWithoutEscalasInput, Enumerable<escalascompetenciaUpdateManyWithWhereWithoutEscalasInput>>
  deleteMany?: XOR<escalascompetenciaScalarWhereInput, Enumerable<escalascompetenciaScalarWhereInput>>
  upsert?: XOR<escalascompetenciaUpsertWithWhereUniqueWithoutEscalasInput, Enumerable<escalascompetenciaUpsertWithWhereUniqueWithoutEscalasInput>>
  connectOrCreate?: XOR<escalascompetenciaCreateOrConnectWithoutescalasInput, Enumerable<escalascompetenciaCreateOrConnectWithoutescalasInput>>
}

export type dadosCreateOneWithoutMeurhInput = {
  create?: dadosCreateWithoutMeurhInput
  connect?: dadosWhereUniqueInput
  connectOrCreate?: dadosCreateOrConnectWithoutmeurhInput
}

export type meurhhistoricoCreateManyWithoutMeurhInput = {
  create?: XOR<meurhhistoricoCreateWithoutMeurhInput, Enumerable<meurhhistoricoCreateWithoutMeurhInput>>
  connect?: XOR<meurhhistoricoWhereUniqueInput, Enumerable<meurhhistoricoWhereUniqueInput>>
  connectOrCreate?: XOR<meurhhistoricoCreateOrConnectWithoutmeurhInput, Enumerable<meurhhistoricoCreateOrConnectWithoutmeurhInput>>
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: XOR<Date | string, null>
}

export type dadosUpdateOneWithoutMeurhInput = {
  create?: dadosCreateWithoutMeurhInput
  connect?: dadosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: dadosUpdateWithoutMeurhInput
  upsert?: dadosUpsertWithoutMeurhInput
  connectOrCreate?: dadosCreateOrConnectWithoutmeurhInput
}

export type meurhhistoricoUpdateManyWithoutMeurhInput = {
  create?: XOR<meurhhistoricoCreateWithoutMeurhInput, Enumerable<meurhhistoricoCreateWithoutMeurhInput>>
  connect?: XOR<meurhhistoricoWhereUniqueInput, Enumerable<meurhhistoricoWhereUniqueInput>>
  set?: XOR<meurhhistoricoWhereUniqueInput, Enumerable<meurhhistoricoWhereUniqueInput>>
  disconnect?: XOR<meurhhistoricoWhereUniqueInput, Enumerable<meurhhistoricoWhereUniqueInput>>
  delete?: XOR<meurhhistoricoWhereUniqueInput, Enumerable<meurhhistoricoWhereUniqueInput>>
  update?: XOR<meurhhistoricoUpdateWithWhereUniqueWithoutMeurhInput, Enumerable<meurhhistoricoUpdateWithWhereUniqueWithoutMeurhInput>>
  updateMany?: XOR<meurhhistoricoUpdateManyWithWhereWithoutMeurhInput, Enumerable<meurhhistoricoUpdateManyWithWhereWithoutMeurhInput>>
  deleteMany?: XOR<meurhhistoricoScalarWhereInput, Enumerable<meurhhistoricoScalarWhereInput>>
  upsert?: XOR<meurhhistoricoUpsertWithWhereUniqueWithoutMeurhInput, Enumerable<meurhhistoricoUpsertWithWhereUniqueWithoutMeurhInput>>
  connectOrCreate?: XOR<meurhhistoricoCreateOrConnectWithoutmeurhInput, Enumerable<meurhhistoricoCreateOrConnectWithoutmeurhInput>>
}

export type tiposocorrenciasCreateOneWithoutOcorrenciasInput = {
  create?: tiposocorrenciasCreateWithoutOcorrenciasInput
  connect?: tiposocorrenciasWhereUniqueInput
  connectOrCreate?: tiposocorrenciasCreateOrConnectWithoutocorrenciasInput
}

export type tiposocorrenciasUpdateOneWithoutOcorrenciasInput = {
  create?: tiposocorrenciasCreateWithoutOcorrenciasInput
  connect?: tiposocorrenciasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: tiposocorrenciasUpdateWithoutOcorrenciasInput
  upsert?: tiposocorrenciasUpsertWithoutOcorrenciasInput
  connectOrCreate?: tiposocorrenciasCreateOrConnectWithoutocorrenciasInput
}

export type empresasCreateOneWithoutTiposocorrenciasInput = {
  create?: empresasCreateWithoutTiposocorrenciasInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithouttiposocorrenciasInput
}

export type ocorrenciasCreateManyWithoutTiposocorrenciasInput = {
  create?: XOR<ocorrenciasCreateWithoutTiposocorrenciasInput, Enumerable<ocorrenciasCreateWithoutTiposocorrenciasInput>>
  connect?: XOR<ocorrenciasWhereUniqueInput, Enumerable<ocorrenciasWhereUniqueInput>>
  connectOrCreate?: XOR<ocorrenciasCreateOrConnectWithouttiposocorrenciasInput, Enumerable<ocorrenciasCreateOrConnectWithouttiposocorrenciasInput>>
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: XOR<boolean, null>
}

export type empresasUpdateOneWithoutTiposocorrenciasInput = {
  create?: empresasCreateWithoutTiposocorrenciasInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutTiposocorrenciasInput
  upsert?: empresasUpsertWithoutTiposocorrenciasInput
  connectOrCreate?: empresasCreateOrConnectWithouttiposocorrenciasInput
}

export type ocorrenciasUpdateManyWithoutTiposocorrenciasInput = {
  create?: XOR<ocorrenciasCreateWithoutTiposocorrenciasInput, Enumerable<ocorrenciasCreateWithoutTiposocorrenciasInput>>
  connect?: XOR<ocorrenciasWhereUniqueInput, Enumerable<ocorrenciasWhereUniqueInput>>
  set?: XOR<ocorrenciasWhereUniqueInput, Enumerable<ocorrenciasWhereUniqueInput>>
  disconnect?: XOR<ocorrenciasWhereUniqueInput, Enumerable<ocorrenciasWhereUniqueInput>>
  delete?: XOR<ocorrenciasWhereUniqueInput, Enumerable<ocorrenciasWhereUniqueInput>>
  update?: XOR<ocorrenciasUpdateWithWhereUniqueWithoutTiposocorrenciasInput, Enumerable<ocorrenciasUpdateWithWhereUniqueWithoutTiposocorrenciasInput>>
  updateMany?: XOR<ocorrenciasUpdateManyWithWhereWithoutTiposocorrenciasInput, Enumerable<ocorrenciasUpdateManyWithWhereWithoutTiposocorrenciasInput>>
  deleteMany?: XOR<ocorrenciasScalarWhereInput, Enumerable<ocorrenciasScalarWhereInput>>
  upsert?: XOR<ocorrenciasUpsertWithWhereUniqueWithoutTiposocorrenciasInput, Enumerable<ocorrenciasUpsertWithWhereUniqueWithoutTiposocorrenciasInput>>
  connectOrCreate?: XOR<ocorrenciasCreateOrConnectWithouttiposocorrenciasInput, Enumerable<ocorrenciasCreateOrConnectWithouttiposocorrenciasInput>>
}

export type escalasCreateOneWithoutEscalascompetenciaInput = {
  create?: escalasCreateWithoutEscalascompetenciaInput
  connect?: escalasWhereUniqueInput
  connectOrCreate?: escalasCreateOrConnectWithoutescalascompetenciaInput
}

export type escalasUpdateOneWithoutEscalascompetenciaInput = {
  create?: escalasCreateWithoutEscalascompetenciaInput
  connect?: escalasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: escalasUpdateWithoutEscalascompetenciaInput
  upsert?: escalasUpsertWithoutEscalascompetenciaInput
  connectOrCreate?: escalasCreateOrConnectWithoutescalascompetenciaInput
}

export type meurhCreateOneWithoutMeurhhistoricoInput = {
  create?: meurhCreateWithoutMeurhhistoricoInput
  connect?: meurhWhereUniqueInput
  connectOrCreate?: meurhCreateOrConnectWithoutmeurhhistoricoInput
}

export type meurhUpdateOneWithoutMeurhhistoricoInput = {
  create?: meurhCreateWithoutMeurhhistoricoInput
  connect?: meurhWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: meurhUpdateWithoutMeurhhistoricoInput
  upsert?: meurhUpsertWithoutMeurhhistoricoInput
  connectOrCreate?: meurhCreateOrConnectWithoutmeurhhistoricoInput
}

export type dadosCreateOneWithoutSuporteInput = {
  create?: dadosCreateWithoutSuporteInput
  connect?: dadosWhereUniqueInput
  connectOrCreate?: dadosCreateOrConnectWithoutsuporteInput
}

export type suportehistoricoCreateManyWithoutSuporteInput = {
  create?: XOR<suportehistoricoCreateWithoutSuporteInput, Enumerable<suportehistoricoCreateWithoutSuporteInput>>
  connect?: XOR<suportehistoricoWhereUniqueInput, Enumerable<suportehistoricoWhereUniqueInput>>
  connectOrCreate?: XOR<suportehistoricoCreateOrConnectWithoutsuporteInput, Enumerable<suportehistoricoCreateOrConnectWithoutsuporteInput>>
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type dadosUpdateOneWithoutSuporteInput = {
  create?: dadosCreateWithoutSuporteInput
  connect?: dadosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: dadosUpdateWithoutSuporteInput
  upsert?: dadosUpsertWithoutSuporteInput
  connectOrCreate?: dadosCreateOrConnectWithoutsuporteInput
}

export type suportehistoricoUpdateManyWithoutSuporteInput = {
  create?: XOR<suportehistoricoCreateWithoutSuporteInput, Enumerable<suportehistoricoCreateWithoutSuporteInput>>
  connect?: XOR<suportehistoricoWhereUniqueInput, Enumerable<suportehistoricoWhereUniqueInput>>
  set?: XOR<suportehistoricoWhereUniqueInput, Enumerable<suportehistoricoWhereUniqueInput>>
  disconnect?: XOR<suportehistoricoWhereUniqueInput, Enumerable<suportehistoricoWhereUniqueInput>>
  delete?: XOR<suportehistoricoWhereUniqueInput, Enumerable<suportehistoricoWhereUniqueInput>>
  update?: XOR<suportehistoricoUpdateWithWhereUniqueWithoutSuporteInput, Enumerable<suportehistoricoUpdateWithWhereUniqueWithoutSuporteInput>>
  updateMany?: XOR<suportehistoricoUpdateManyWithWhereWithoutSuporteInput, Enumerable<suportehistoricoUpdateManyWithWhereWithoutSuporteInput>>
  deleteMany?: XOR<suportehistoricoScalarWhereInput, Enumerable<suportehistoricoScalarWhereInput>>
  upsert?: XOR<suportehistoricoUpsertWithWhereUniqueWithoutSuporteInput, Enumerable<suportehistoricoUpsertWithWhereUniqueWithoutSuporteInput>>
  connectOrCreate?: XOR<suportehistoricoCreateOrConnectWithoutsuporteInput, Enumerable<suportehistoricoCreateOrConnectWithoutsuporteInput>>
}

export type suporteCreateOneWithoutSuportehistoricoInput = {
  create?: suporteCreateWithoutSuportehistoricoInput
  connect?: suporteWhereUniqueInput
  connectOrCreate?: suporteCreateOrConnectWithoutsuportehistoricoInput
}

export type suporteUpdateOneWithoutSuportehistoricoInput = {
  create?: suporteCreateWithoutSuportehistoricoInput
  connect?: suporteWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: suporteUpdateWithoutSuportehistoricoInput
  upsert?: suporteUpsertWithoutSuportehistoricoInput
  connectOrCreate?: suporteCreateOrConnectWithoutsuportehistoricoInput
}

export type dadosCreateOneWithoutMeurhrespostasInput = {
  create?: dadosCreateWithoutMeurhrespostasInput
  connect?: dadosWhereUniqueInput
  connectOrCreate?: dadosCreateOrConnectWithoutmeurhrespostasInput
}

export type dadosUpdateOneWithoutMeurhrespostasInput = {
  create?: dadosCreateWithoutMeurhrespostasInput
  connect?: dadosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: dadosUpdateWithoutMeurhrespostasInput
  upsert?: dadosUpsertWithoutMeurhrespostasInput
  connectOrCreate?: dadosCreateOrConnectWithoutmeurhrespostasInput
}

export type empresasCreateOneWithoutPedidosInput = {
  create?: empresasCreateWithoutPedidosInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithoutpedidosInput
}

export type detalhepedidos_oldCreateManyWithoutPedidosInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutPedidosInput, Enumerable<detalhepedidos_oldCreateWithoutPedidosInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutpedidosInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutpedidosInput>>
}

export type empresasUpdateOneWithoutPedidosInput = {
  create?: empresasCreateWithoutPedidosInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutPedidosInput
  upsert?: empresasUpsertWithoutPedidosInput
  connectOrCreate?: empresasCreateOrConnectWithoutpedidosInput
}

export type detalhepedidos_oldUpdateManyWithoutPedidosInput = {
  create?: XOR<detalhepedidos_oldCreateWithoutPedidosInput, Enumerable<detalhepedidos_oldCreateWithoutPedidosInput>>
  connect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  set?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  disconnect?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  delete?: XOR<detalhepedidos_oldWhereUniqueInput, Enumerable<detalhepedidos_oldWhereUniqueInput>>
  update?: XOR<detalhepedidos_oldUpdateWithWhereUniqueWithoutPedidosInput, Enumerable<detalhepedidos_oldUpdateWithWhereUniqueWithoutPedidosInput>>
  updateMany?: XOR<detalhepedidos_oldUpdateManyWithWhereWithoutPedidosInput, Enumerable<detalhepedidos_oldUpdateManyWithWhereWithoutPedidosInput>>
  deleteMany?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  upsert?: XOR<detalhepedidos_oldUpsertWithWhereUniqueWithoutPedidosInput, Enumerable<detalhepedidos_oldUpsertWithWhereUniqueWithoutPedidosInput>>
  connectOrCreate?: XOR<detalhepedidos_oldCreateOrConnectWithoutpedidosInput, Enumerable<detalhepedidos_oldCreateOrConnectWithoutpedidosInput>>
}

export type dadosCreateOneWithoutDetalhepedidos_oldInput = {
  create?: dadosCreateWithoutDetalhepedidos_oldInput
  connect?: dadosWhereUniqueInput
  connectOrCreate?: dadosCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type escalasCreateOneWithoutDetalhepedidos_oldInput = {
  create?: escalasCreateWithoutDetalhepedidos_oldInput
  connect?: escalasWhereUniqueInput
  connectOrCreate?: escalasCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type operadorasCreateOneWithoutDetalhepedidos_oldInput = {
  create?: operadorasCreateWithoutDetalhepedidos_oldInput
  connect?: operadorasWhereUniqueInput
  connectOrCreate?: operadorasCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type pedidosCreateOneWithoutDetalhepedidos_oldInput = {
  create?: pedidosCreateWithoutDetalhepedidos_oldInput
  connect?: pedidosWhereUniqueInput
  connectOrCreate?: pedidosCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type dadosUpdateOneWithoutDetalhepedidos_oldInput = {
  create?: dadosCreateWithoutDetalhepedidos_oldInput
  connect?: dadosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: dadosUpdateWithoutDetalhepedidos_oldInput
  upsert?: dadosUpsertWithoutDetalhepedidos_oldInput
  connectOrCreate?: dadosCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type escalasUpdateOneWithoutDetalhepedidos_oldInput = {
  create?: escalasCreateWithoutDetalhepedidos_oldInput
  connect?: escalasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: escalasUpdateWithoutDetalhepedidos_oldInput
  upsert?: escalasUpsertWithoutDetalhepedidos_oldInput
  connectOrCreate?: escalasCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type operadorasUpdateOneWithoutDetalhepedidos_oldInput = {
  create?: operadorasCreateWithoutDetalhepedidos_oldInput
  connect?: operadorasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: operadorasUpdateWithoutDetalhepedidos_oldInput
  upsert?: operadorasUpsertWithoutDetalhepedidos_oldInput
  connectOrCreate?: operadorasCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type pedidosUpdateOneWithoutDetalhepedidos_oldInput = {
  create?: pedidosCreateWithoutDetalhepedidos_oldInput
  connect?: pedidosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: pedidosUpdateWithoutDetalhepedidos_oldInput
  upsert?: pedidosUpsertWithoutDetalhepedidos_oldInput
  connectOrCreate?: pedidosCreateOrConnectWithoutdetalhepedidos_oldInput
}

export type empresasCreateOneWithoutEconomiaInput = {
  create?: empresasCreateWithoutEconomiaInput
  connect?: empresasWhereUniqueInput
  connectOrCreate?: empresasCreateOrConnectWithouteconomiaInput
}

export type empresasUpdateOneWithoutEconomiaInput = {
  create?: empresasCreateWithoutEconomiaInput
  connect?: empresasWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: empresasUpdateWithoutEconomiaInput
  upsert?: empresasUpsertWithoutEconomiaInput
  connectOrCreate?: empresasCreateOrConnectWithouteconomiaInput
}

export type dadosCreateOneWithoutSolicitacoesInput = {
  create?: dadosCreateWithoutSolicitacoesInput
  connect?: dadosWhereUniqueInput
  connectOrCreate?: dadosCreateOrConnectWithoutsolicitacoesInput
}

export type dadosUpdateOneWithoutSolicitacoesInput = {
  create?: dadosCreateWithoutSolicitacoesInput
  connect?: dadosWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: dadosUpdateWithoutSolicitacoesInput
  upsert?: dadosUpsertWithoutSolicitacoesInput
  connectOrCreate?: dadosCreateOrConnectWithoutsolicitacoesInput
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: XOR<number, NestedIntFilter>
}

export type NestedStringNullableFilter = {
  equals?: XOR<string, null>
  in?: XOR<Enumerable<string>, null>
  notIn?: XOR<Enumerable<string>, null>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type NestedIntNullableFilter = {
  equals?: XOR<number, null>
  in?: XOR<Enumerable<number>, null>
  notIn?: XOR<Enumerable<number>, null>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type NestedFloatNullableFilter = {
  equals?: XOR<number, null>
  in?: XOR<Enumerable<number>, null>
  notIn?: XOR<Enumerable<number>, null>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type NestedDateTimeNullableFilter = {
  equals?: XOR<Date | string, null>
  in?: XOR<Enumerable<Date> | Enumerable<string>, null>
  notIn?: XOR<Enumerable<Date> | Enumerable<string>, null>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type NestedBoolNullableFilter = {
  equals?: XOR<boolean, null>
  not?: boolean | NestedBoolNullableFilter | null
}

export type NestedDateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date> | Enumerable<string>
  notIn?: Enumerable<Date> | Enumerable<string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: XOR<Date | string, NestedDateTimeFilter>
}

export type empresasCreateWithoutCentrodecustosInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithoutcentrodecustosInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutCentrodecustosInput
}

export type dadosCreateWithoutCentrodecustosInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutcentrodecustosInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutCentrodecustosInput
}

export type empresasUpdateWithoutCentrodecustosInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutCentrodecustosInput = {
  update: empresasUpdateWithoutCentrodecustosInput
  create: empresasCreateWithoutCentrodecustosInput
}

export type dadosUpdateWithWhereUniqueWithoutCentrodecustosInput = {
  where: dadosWhereUniqueInput
  data: dadosUpdateWithoutCentrodecustosInput
}

export type dadosUpdateManyWithWhereWithoutCentrodecustosInput = {
  where: dadosScalarWhereInput
  data: dadosUpdateManyMutationInput
}

export type dadosScalarWhereInput = {
  AND?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  OR?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  NOT?: XOR<dadosScalarWhereInput, Enumerable<dadosScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  NmColaborador?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  DtNascimento?: StringNullableFilter | string | null
  IdCentroDeCusto?: IntNullableFilter | number | null
  Matricula?: StringNullableFilter | string | null
  IdEscala?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
}

export type dadosUpsertWithWhereUniqueWithoutCentrodecustosInput = {
  where: dadosWhereUniqueInput
  update: dadosUpdateWithoutCentrodecustosInput
  create: dadosCreateWithoutCentrodecustosInput
}

export type centrodecustosCreateWithoutEmpresasInput = {
  NmCentroDeCusto?: XOR<string, null>
  Situacao?: XOR<string, null>
  dados?: dadosCreateManyWithoutCentrodecustosInput
}

export type centrodecustosCreateOrConnectWithoutempresasInput = {
  where: centrodecustosWhereUniqueInput
  create: centrodecustosCreateWithoutEmpresasInput
}

export type dadosCreateWithoutEmpresasInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutempresasInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutEmpresasInput
}

export type economiaCreateWithoutEmpresasInput = {
  Competencia?: XOR<string, null>
  Valor?: XOR<number, null>
}

export type economiaCreateOrConnectWithoutempresasInput = {
  where: economiaWhereUniqueInput
  create: economiaCreateWithoutEmpresasInput
}

export type escalasCreateWithoutEmpresasInput = {
  NmEscala?: XOR<string, null>
  Folgas?: XOR<string, null>
  dados?: dadosCreateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaCreateManyWithoutEscalasInput
}

export type escalasCreateOrConnectWithoutempresasInput = {
  where: escalasWhereUniqueInput
  create: escalasCreateWithoutEmpresasInput
}

export type operadorasCreateWithoutEmpresasInput = {
  NmOperadora?: XOR<string, null>
  UF?: XOR<string, null>
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutOperadorasInput
  passagens?: passagensCreateManyWithoutOperadorasInput
}

export type operadorasCreateOrConnectWithoutempresasInput = {
  where: operadorasWhereUniqueInput
  create: operadorasCreateWithoutEmpresasInput
}

export type pedidosCreateWithoutEmpresasInput = {
  Competencia?: XOR<string, null>
  DtInicialFolgas?: XOR<Date | string, null>
  DtFinalFolgas?: XOR<Date | string, null>
  DtInicialFaltas?: XOR<Date | string, null>
  DtFinalFaltas?: XOR<Date | string, null>
  Status?: XOR<string, null>
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutPedidosInput
}

export type pedidosCreateOrConnectWithoutempresasInput = {
  where: pedidosWhereUniqueInput
  create: pedidosCreateWithoutEmpresasInput
}

export type tiposocorrenciasCreateWithoutEmpresasInput = {
  NmOcorrencia?: XOR<string, null>
  DescBeneficio?: XOR<boolean, null>
  Descricao?: XOR<string, null>
  ocorrencias?: ocorrenciasCreateManyWithoutTiposocorrenciasInput
}

export type tiposocorrenciasCreateOrConnectWithoutempresasInput = {
  where: tiposocorrenciasWhereUniqueInput
  create: tiposocorrenciasCreateWithoutEmpresasInput
}

export type centrodecustosUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: centrodecustosWhereUniqueInput
  data: centrodecustosUpdateWithoutEmpresasInput
}

export type centrodecustosUpdateManyWithWhereWithoutEmpresasInput = {
  where: centrodecustosScalarWhereInput
  data: centrodecustosUpdateManyMutationInput
}

export type centrodecustosScalarWhereInput = {
  AND?: XOR<centrodecustosScalarWhereInput, Enumerable<centrodecustosScalarWhereInput>>
  OR?: XOR<centrodecustosScalarWhereInput, Enumerable<centrodecustosScalarWhereInput>>
  NOT?: XOR<centrodecustosScalarWhereInput, Enumerable<centrodecustosScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  NmCentroDeCusto?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
}

export type centrodecustosUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: centrodecustosWhereUniqueInput
  update: centrodecustosUpdateWithoutEmpresasInput
  create: centrodecustosCreateWithoutEmpresasInput
}

export type dadosUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: dadosWhereUniqueInput
  data: dadosUpdateWithoutEmpresasInput
}

export type dadosUpdateManyWithWhereWithoutEmpresasInput = {
  where: dadosScalarWhereInput
  data: dadosUpdateManyMutationInput
}

export type dadosUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: dadosWhereUniqueInput
  update: dadosUpdateWithoutEmpresasInput
  create: dadosCreateWithoutEmpresasInput
}

export type economiaUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: economiaWhereUniqueInput
  data: economiaUpdateWithoutEmpresasInput
}

export type economiaUpdateManyWithWhereWithoutEmpresasInput = {
  where: economiaScalarWhereInput
  data: economiaUpdateManyMutationInput
}

export type economiaScalarWhereInput = {
  AND?: XOR<economiaScalarWhereInput, Enumerable<economiaScalarWhereInput>>
  OR?: XOR<economiaScalarWhereInput, Enumerable<economiaScalarWhereInput>>
  NOT?: XOR<economiaScalarWhereInput, Enumerable<economiaScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  Valor?: FloatNullableFilter | number | null
}

export type economiaUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: economiaWhereUniqueInput
  update: economiaUpdateWithoutEmpresasInput
  create: economiaCreateWithoutEmpresasInput
}

export type escalasUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: escalasWhereUniqueInput
  data: escalasUpdateWithoutEmpresasInput
}

export type escalasUpdateManyWithWhereWithoutEmpresasInput = {
  where: escalasScalarWhereInput
  data: escalasUpdateManyMutationInput
}

export type escalasScalarWhereInput = {
  AND?: XOR<escalasScalarWhereInput, Enumerable<escalasScalarWhereInput>>
  OR?: XOR<escalasScalarWhereInput, Enumerable<escalasScalarWhereInput>>
  NOT?: XOR<escalasScalarWhereInput, Enumerable<escalasScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  NmEscala?: StringNullableFilter | string | null
  Folgas?: StringNullableFilter | string | null
}

export type escalasUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: escalasWhereUniqueInput
  update: escalasUpdateWithoutEmpresasInput
  create: escalasCreateWithoutEmpresasInput
}

export type operadorasUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: operadorasWhereUniqueInput
  data: operadorasUpdateWithoutEmpresasInput
}

export type operadorasUpdateManyWithWhereWithoutEmpresasInput = {
  where: operadorasScalarWhereInput
  data: operadorasUpdateManyMutationInput
}

export type operadorasScalarWhereInput = {
  AND?: XOR<operadorasScalarWhereInput, Enumerable<operadorasScalarWhereInput>>
  OR?: XOR<operadorasScalarWhereInput, Enumerable<operadorasScalarWhereInput>>
  NOT?: XOR<operadorasScalarWhereInput, Enumerable<operadorasScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  NmOperadora?: StringNullableFilter | string | null
  IdEmpresa?: IntNullableFilter | number | null
  UF?: StringNullableFilter | string | null
}

export type operadorasUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: operadorasWhereUniqueInput
  update: operadorasUpdateWithoutEmpresasInput
  create: operadorasCreateWithoutEmpresasInput
}

export type pedidosUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: pedidosWhereUniqueInput
  data: pedidosUpdateWithoutEmpresasInput
}

export type pedidosUpdateManyWithWhereWithoutEmpresasInput = {
  where: pedidosScalarWhereInput
  data: pedidosUpdateManyMutationInput
}

export type pedidosScalarWhereInput = {
  AND?: XOR<pedidosScalarWhereInput, Enumerable<pedidosScalarWhereInput>>
  OR?: XOR<pedidosScalarWhereInput, Enumerable<pedidosScalarWhereInput>>
  NOT?: XOR<pedidosScalarWhereInput, Enumerable<pedidosScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEmpresa?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  DtInicialFolgas?: DateTimeNullableFilter | Date | string | null
  DtFinalFolgas?: DateTimeNullableFilter | Date | string | null
  DtInicialFaltas?: DateTimeNullableFilter | Date | string | null
  DtFinalFaltas?: DateTimeNullableFilter | Date | string | null
  Status?: StringNullableFilter | string | null
}

export type pedidosUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: pedidosWhereUniqueInput
  update: pedidosUpdateWithoutEmpresasInput
  create: pedidosCreateWithoutEmpresasInput
}

export type tiposocorrenciasUpdateWithWhereUniqueWithoutEmpresasInput = {
  where: tiposocorrenciasWhereUniqueInput
  data: tiposocorrenciasUpdateWithoutEmpresasInput
}

export type tiposocorrenciasUpdateManyWithWhereWithoutEmpresasInput = {
  where: tiposocorrenciasScalarWhereInput
  data: tiposocorrenciasUpdateManyMutationInput
}

export type tiposocorrenciasScalarWhereInput = {
  AND?: XOR<tiposocorrenciasScalarWhereInput, Enumerable<tiposocorrenciasScalarWhereInput>>
  OR?: XOR<tiposocorrenciasScalarWhereInput, Enumerable<tiposocorrenciasScalarWhereInput>>
  NOT?: XOR<tiposocorrenciasScalarWhereInput, Enumerable<tiposocorrenciasScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  NmOcorrencia?: StringNullableFilter | string | null
  DescBeneficio?: BoolNullableFilter | boolean | null
  IdEmpresa?: IntNullableFilter | number | null
  Descricao?: StringNullableFilter | string | null
}

export type tiposocorrenciasUpsertWithWhereUniqueWithoutEmpresasInput = {
  where: tiposocorrenciasWhereUniqueInput
  update: tiposocorrenciasUpdateWithoutEmpresasInput
  create: tiposocorrenciasCreateWithoutEmpresasInput
}

export type empresasCreateWithoutOperadorasInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithoutoperadorasInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutOperadorasInput
}

export type detalhepedidos_oldCreateWithoutOperadorasInput = {
  NmColaborador?: XOR<string, null>
  NrCartao?: XOR<string, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  QtdVale?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
  dados?: dadosCreateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasCreateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosCreateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldCreateOrConnectWithoutoperadorasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  create: detalhepedidos_oldCreateWithoutOperadorasInput
}

export type passagensCreateWithoutOperadorasInput = {
  CPF?: XOR<string, null>
  NrCartao?: XOR<string, null>
  Valor?: XOR<number, null>
  QtdDia?: XOR<number, null>
  Situacao?: XOR<string, null>
}

export type passagensCreateOrConnectWithoutoperadorasInput = {
  where: passagensWhereUniqueInput
  create: passagensCreateWithoutOperadorasInput
}

export type empresasUpdateWithoutOperadorasInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutOperadorasInput = {
  update: empresasUpdateWithoutOperadorasInput
  create: empresasCreateWithoutOperadorasInput
}

export type detalhepedidos_oldUpdateWithWhereUniqueWithoutOperadorasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  data: detalhepedidos_oldUpdateWithoutOperadorasInput
}

export type detalhepedidos_oldUpdateManyWithWhereWithoutOperadorasInput = {
  where: detalhepedidos_oldScalarWhereInput
  data: detalhepedidos_oldUpdateManyMutationInput
}

export type detalhepedidos_oldScalarWhereInput = {
  AND?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  OR?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  NOT?: XOR<detalhepedidos_oldScalarWhereInput, Enumerable<detalhepedidos_oldScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdPedido?: IntNullableFilter | number | null
  NmColaborador?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  IdOperadora?: IntNullableFilter | number | null
  NmOperadora?: StringNullableFilter | string | null
  ValorDia?: FloatNullableFilter | number | null
  QtdFolgas?: IntNullableFilter | number | null
  QtdDiasUteis?: IntNullableFilter | number | null
  Valor?: FloatNullableFilter | number | null
  IdEscalas?: IntNullableFilter | number | null
  QtdVale?: IntNullableFilter | number | null
  MemoriaCalculo?: StringNullableFilter | string | null
}

export type detalhepedidos_oldUpsertWithWhereUniqueWithoutOperadorasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  update: detalhepedidos_oldUpdateWithoutOperadorasInput
  create: detalhepedidos_oldCreateWithoutOperadorasInput
}

export type passagensUpdateWithWhereUniqueWithoutOperadorasInput = {
  where: passagensWhereUniqueInput
  data: passagensUpdateWithoutOperadorasInput
}

export type passagensUpdateManyWithWhereWithoutOperadorasInput = {
  where: passagensScalarWhereInput
  data: passagensUpdateManyMutationInput
}

export type passagensScalarWhereInput = {
  AND?: XOR<passagensScalarWhereInput, Enumerable<passagensScalarWhereInput>>
  OR?: XOR<passagensScalarWhereInput, Enumerable<passagensScalarWhereInput>>
  NOT?: XOR<passagensScalarWhereInput, Enumerable<passagensScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  Valor?: FloatNullableFilter | number | null
  IdOperadora?: IntNullableFilter | number | null
  QtdDia?: IntNullableFilter | number | null
  Situacao?: StringNullableFilter | string | null
}

export type passagensUpsertWithWhereUniqueWithoutOperadorasInput = {
  where: passagensWhereUniqueInput
  update: passagensUpdateWithoutOperadorasInput
  create: passagensCreateWithoutOperadorasInput
}

export type centrodecustosCreateWithoutDadosInput = {
  NmCentroDeCusto?: XOR<string, null>
  Situacao?: XOR<string, null>
  empresas?: empresasCreateOneWithoutCentrodecustosInput
}

export type centrodecustosCreateOrConnectWithoutdadosInput = {
  where: centrodecustosWhereUniqueInput
  create: centrodecustosCreateWithoutDadosInput
}

export type empresasCreateWithoutDadosInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithoutdadosInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutDadosInput
}

export type escalasCreateWithoutDadosInput = {
  NmEscala?: XOR<string, null>
  Folgas?: XOR<string, null>
  empresas?: empresasCreateOneWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaCreateManyWithoutEscalasInput
}

export type escalasCreateOrConnectWithoutdadosInput = {
  where: escalasWhereUniqueInput
  create: escalasCreateWithoutDadosInput
}

export type detalhepedidos_oldCreateWithoutDadosInput = {
  NmColaborador?: XOR<string, null>
  NrCartao?: XOR<string, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  QtdVale?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
  escalas?: escalasCreateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasCreateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosCreateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldCreateOrConnectWithoutdadosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  create: detalhepedidos_oldCreateWithoutDadosInput
}

export type meurhCreateWithoutDadosInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: XOR<Date | string, null>
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Status?: XOR<string, null>
  meurhhistorico?: meurhhistoricoCreateManyWithoutMeurhInput
}

export type meurhCreateOrConnectWithoutdadosInput = {
  where: meurhWhereUniqueInput
  create: meurhCreateWithoutDadosInput
}

export type meurhrespostasCreateWithoutDadosInput = {
  IdMeuRh?: XOR<number, null>
  DtResposta?: XOR<Date | string, null>
  Msg?: XOR<string, null>
}

export type meurhrespostasCreateOrConnectWithoutdadosInput = {
  where: meurhrespostasWhereUniqueInput
  create: meurhrespostasCreateWithoutDadosInput
}

export type solicitacoesCreateWithoutDadosInput = {
  Protocolo?: XOR<string, null>
  TipoSolicitacao?: XOR<string, null>
  OrigemSolicitacao?: XOR<string, null>
  NrCartao?: XOR<string, null>
  DtSolicitacao?: Date | string
  DtFinalizacao?: XOR<Date | string, null>
  Status?: XOR<string, null>
}

export type solicitacoesCreateOrConnectWithoutdadosInput = {
  where: solicitacoesWhereUniqueInput
  create: solicitacoesCreateWithoutDadosInput
}

export type suporteCreateWithoutDadosInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: Date | string
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Avaliacao?: XOR<number, null>
  Status?: XOR<string, null>
  suportehistorico?: suportehistoricoCreateManyWithoutSuporteInput
}

export type suporteCreateOrConnectWithoutdadosInput = {
  where: suporteWhereUniqueInput
  create: suporteCreateWithoutDadosInput
}

export type centrodecustosUpdateWithoutDadosInput = {
  NmCentroDeCusto?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutCentrodecustosInput
}

export type centrodecustosUpsertWithoutDadosInput = {
  update: centrodecustosUpdateWithoutDadosInput
  create: centrodecustosCreateWithoutDadosInput
}

export type empresasUpdateWithoutDadosInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutDadosInput = {
  update: empresasUpdateWithoutDadosInput
  create: empresasCreateWithoutDadosInput
}

export type escalasUpdateWithoutDadosInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaUpdateManyWithoutEscalasInput
}

export type escalasUpsertWithoutDadosInput = {
  update: escalasUpdateWithoutDadosInput
  create: escalasCreateWithoutDadosInput
}

export type detalhepedidos_oldUpdateWithWhereUniqueWithoutDadosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  data: detalhepedidos_oldUpdateWithoutDadosInput
}

export type detalhepedidos_oldUpdateManyWithWhereWithoutDadosInput = {
  where: detalhepedidos_oldScalarWhereInput
  data: detalhepedidos_oldUpdateManyMutationInput
}

export type detalhepedidos_oldUpsertWithWhereUniqueWithoutDadosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  update: detalhepedidos_oldUpdateWithoutDadosInput
  create: detalhepedidos_oldCreateWithoutDadosInput
}

export type meurhUpdateWithWhereUniqueWithoutDadosInput = {
  where: meurhWhereUniqueInput
  data: meurhUpdateWithoutDadosInput
}

export type meurhUpdateManyWithWhereWithoutDadosInput = {
  where: meurhScalarWhereInput
  data: meurhUpdateManyMutationInput
}

export type meurhScalarWhereInput = {
  AND?: XOR<meurhScalarWhereInput, Enumerable<meurhScalarWhereInput>>
  OR?: XOR<meurhScalarWhereInput, Enumerable<meurhScalarWhereInput>>
  NOT?: XOR<meurhScalarWhereInput, Enumerable<meurhScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  DtTicketAbertura?: DateTimeNullableFilter | Date | string | null
  DtTicketFechamento?: DateTimeNullableFilter | Date | string | null
  Assunto?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  Status?: StringNullableFilter | string | null
}

export type meurhUpsertWithWhereUniqueWithoutDadosInput = {
  where: meurhWhereUniqueInput
  update: meurhUpdateWithoutDadosInput
  create: meurhCreateWithoutDadosInput
}

export type meurhrespostasUpdateWithWhereUniqueWithoutDadosInput = {
  where: meurhrespostasWhereUniqueInput
  data: meurhrespostasUpdateWithoutDadosInput
}

export type meurhrespostasUpdateManyWithWhereWithoutDadosInput = {
  where: meurhrespostasScalarWhereInput
  data: meurhrespostasUpdateManyMutationInput
}

export type meurhrespostasScalarWhereInput = {
  AND?: XOR<meurhrespostasScalarWhereInput, Enumerable<meurhrespostasScalarWhereInput>>
  OR?: XOR<meurhrespostasScalarWhereInput, Enumerable<meurhrespostasScalarWhereInput>>
  NOT?: XOR<meurhrespostasScalarWhereInput, Enumerable<meurhrespostasScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdMeuRh?: IntNullableFilter | number | null
  DtResposta?: DateTimeNullableFilter | Date | string | null
  CPF?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
}

export type meurhrespostasUpsertWithWhereUniqueWithoutDadosInput = {
  where: meurhrespostasWhereUniqueInput
  update: meurhrespostasUpdateWithoutDadosInput
  create: meurhrespostasCreateWithoutDadosInput
}

export type solicitacoesUpdateWithWhereUniqueWithoutDadosInput = {
  where: solicitacoesWhereUniqueInput
  data: solicitacoesUpdateWithoutDadosInput
}

export type solicitacoesUpdateManyWithWhereWithoutDadosInput = {
  where: solicitacoesScalarWhereInput
  data: solicitacoesUpdateManyMutationInput
}

export type solicitacoesScalarWhereInput = {
  AND?: XOR<solicitacoesScalarWhereInput, Enumerable<solicitacoesScalarWhereInput>>
  OR?: XOR<solicitacoesScalarWhereInput, Enumerable<solicitacoesScalarWhereInput>>
  NOT?: XOR<solicitacoesScalarWhereInput, Enumerable<solicitacoesScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  TipoSolicitacao?: StringNullableFilter | string | null
  OrigemSolicitacao?: StringNullableFilter | string | null
  NrCartao?: StringNullableFilter | string | null
  DtSolicitacao?: XOR<DateTimeFilter, Date | string>
  DtFinalizacao?: DateTimeNullableFilter | Date | string | null
  Status?: StringNullableFilter | string | null
}

export type solicitacoesUpsertWithWhereUniqueWithoutDadosInput = {
  where: solicitacoesWhereUniqueInput
  update: solicitacoesUpdateWithoutDadosInput
  create: solicitacoesCreateWithoutDadosInput
}

export type suporteUpdateWithWhereUniqueWithoutDadosInput = {
  where: suporteWhereUniqueInput
  data: suporteUpdateWithoutDadosInput
}

export type suporteUpdateManyWithWhereWithoutDadosInput = {
  where: suporteScalarWhereInput
  data: suporteUpdateManyMutationInput
}

export type suporteScalarWhereInput = {
  AND?: XOR<suporteScalarWhereInput, Enumerable<suporteScalarWhereInput>>
  OR?: XOR<suporteScalarWhereInput, Enumerable<suporteScalarWhereInput>>
  NOT?: XOR<suporteScalarWhereInput, Enumerable<suporteScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  Protocolo?: StringNullableFilter | string | null
  CPF?: StringNullableFilter | string | null
  DtTicketAbertura?: XOR<DateTimeFilter, Date | string>
  DtTicketFechamento?: DateTimeNullableFilter | Date | string | null
  Assunto?: StringNullableFilter | string | null
  Msg?: StringNullableFilter | string | null
  Avaliacao?: IntNullableFilter | number | null
  Status?: StringNullableFilter | string | null
}

export type suporteUpsertWithWhereUniqueWithoutDadosInput = {
  where: suporteWhereUniqueInput
  update: suporteUpdateWithoutDadosInput
  create: suporteCreateWithoutDadosInput
}

export type operadorasCreateWithoutPassagensInput = {
  NmOperadora?: XOR<string, null>
  UF?: XOR<string, null>
  empresas?: empresasCreateOneWithoutOperadorasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutOperadorasInput
}

export type operadorasCreateOrConnectWithoutpassagensInput = {
  where: operadorasWhereUniqueInput
  create: operadorasCreateWithoutPassagensInput
}

export type operadorasUpdateWithoutPassagensInput = {
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  UF?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutOperadorasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutOperadorasInput
}

export type operadorasUpsertWithoutPassagensInput = {
  update: operadorasUpdateWithoutPassagensInput
  create: operadorasCreateWithoutPassagensInput
}

export type empresasCreateWithoutEscalasInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithoutescalasInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutEscalasInput
}

export type dadosCreateWithoutEscalasInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutescalasInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutEscalasInput
}

export type detalhepedidos_oldCreateWithoutEscalasInput = {
  NmColaborador?: XOR<string, null>
  NrCartao?: XOR<string, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  QtdVale?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
  dados?: dadosCreateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasCreateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosCreateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldCreateOrConnectWithoutescalasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  create: detalhepedidos_oldCreateWithoutEscalasInput
}

export type escalascompetenciaCreateWithoutEscalasInput = {
  Competencia?: XOR<string, null>
  QtdUteis?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
}

export type escalascompetenciaCreateOrConnectWithoutescalasInput = {
  where: escalascompetenciaWhereUniqueInput
  create: escalascompetenciaCreateWithoutEscalasInput
}

export type empresasUpdateWithoutEscalasInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutEscalasInput = {
  update: empresasUpdateWithoutEscalasInput
  create: empresasCreateWithoutEscalasInput
}

export type dadosUpdateWithWhereUniqueWithoutEscalasInput = {
  where: dadosWhereUniqueInput
  data: dadosUpdateWithoutEscalasInput
}

export type dadosUpdateManyWithWhereWithoutEscalasInput = {
  where: dadosScalarWhereInput
  data: dadosUpdateManyMutationInput
}

export type dadosUpsertWithWhereUniqueWithoutEscalasInput = {
  where: dadosWhereUniqueInput
  update: dadosUpdateWithoutEscalasInput
  create: dadosCreateWithoutEscalasInput
}

export type detalhepedidos_oldUpdateWithWhereUniqueWithoutEscalasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  data: detalhepedidos_oldUpdateWithoutEscalasInput
}

export type detalhepedidos_oldUpdateManyWithWhereWithoutEscalasInput = {
  where: detalhepedidos_oldScalarWhereInput
  data: detalhepedidos_oldUpdateManyMutationInput
}

export type detalhepedidos_oldUpsertWithWhereUniqueWithoutEscalasInput = {
  where: detalhepedidos_oldWhereUniqueInput
  update: detalhepedidos_oldUpdateWithoutEscalasInput
  create: detalhepedidos_oldCreateWithoutEscalasInput
}

export type escalascompetenciaUpdateWithWhereUniqueWithoutEscalasInput = {
  where: escalascompetenciaWhereUniqueInput
  data: escalascompetenciaUpdateWithoutEscalasInput
}

export type escalascompetenciaUpdateManyWithWhereWithoutEscalasInput = {
  where: escalascompetenciaScalarWhereInput
  data: escalascompetenciaUpdateManyMutationInput
}

export type escalascompetenciaScalarWhereInput = {
  AND?: XOR<escalascompetenciaScalarWhereInput, Enumerable<escalascompetenciaScalarWhereInput>>
  OR?: XOR<escalascompetenciaScalarWhereInput, Enumerable<escalascompetenciaScalarWhereInput>>
  NOT?: XOR<escalascompetenciaScalarWhereInput, Enumerable<escalascompetenciaScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdEscalas?: IntNullableFilter | number | null
  Competencia?: StringNullableFilter | string | null
  QtdUteis?: IntNullableFilter | number | null
  QtdFolgas?: IntNullableFilter | number | null
}

export type escalascompetenciaUpsertWithWhereUniqueWithoutEscalasInput = {
  where: escalascompetenciaWhereUniqueInput
  update: escalascompetenciaUpdateWithoutEscalasInput
  create: escalascompetenciaCreateWithoutEscalasInput
}

export type dadosCreateWithoutMeurhInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutmeurhInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutMeurhInput
}

export type meurhhistoricoCreateWithoutMeurhInput = {
  StatusAtual?: XOR<string, null>
  StatusNovo?: XOR<string, null>
  DtAlteracao?: XOR<Date | string, null>
}

export type meurhhistoricoCreateOrConnectWithoutmeurhInput = {
  where: meurhhistoricoWhereUniqueInput
  create: meurhhistoricoCreateWithoutMeurhInput
}

export type dadosUpdateWithoutMeurhInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type dadosUpsertWithoutMeurhInput = {
  update: dadosUpdateWithoutMeurhInput
  create: dadosCreateWithoutMeurhInput
}

export type meurhhistoricoUpdateWithWhereUniqueWithoutMeurhInput = {
  where: meurhhistoricoWhereUniqueInput
  data: meurhhistoricoUpdateWithoutMeurhInput
}

export type meurhhistoricoUpdateManyWithWhereWithoutMeurhInput = {
  where: meurhhistoricoScalarWhereInput
  data: meurhhistoricoUpdateManyMutationInput
}

export type meurhhistoricoScalarWhereInput = {
  AND?: XOR<meurhhistoricoScalarWhereInput, Enumerable<meurhhistoricoScalarWhereInput>>
  OR?: XOR<meurhhistoricoScalarWhereInput, Enumerable<meurhhistoricoScalarWhereInput>>
  NOT?: XOR<meurhhistoricoScalarWhereInput, Enumerable<meurhhistoricoScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdMeuRh?: IntNullableFilter | number | null
  StatusAtual?: StringNullableFilter | string | null
  StatusNovo?: StringNullableFilter | string | null
  DtAlteracao?: DateTimeNullableFilter | Date | string | null
}

export type meurhhistoricoUpsertWithWhereUniqueWithoutMeurhInput = {
  where: meurhhistoricoWhereUniqueInput
  update: meurhhistoricoUpdateWithoutMeurhInput
  create: meurhhistoricoCreateWithoutMeurhInput
}

export type tiposocorrenciasCreateWithoutOcorrenciasInput = {
  NmOcorrencia?: XOR<string, null>
  DescBeneficio?: XOR<boolean, null>
  Descricao?: XOR<string, null>
  empresas?: empresasCreateOneWithoutTiposocorrenciasInput
}

export type tiposocorrenciasCreateOrConnectWithoutocorrenciasInput = {
  where: tiposocorrenciasWhereUniqueInput
  create: tiposocorrenciasCreateWithoutOcorrenciasInput
}

export type tiposocorrenciasUpdateWithoutOcorrenciasInput = {
  NmOcorrencia?: string | NullableStringFieldUpdateOperationsInput | null
  DescBeneficio?: boolean | NullableBoolFieldUpdateOperationsInput | null
  Descricao?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutTiposocorrenciasInput
}

export type tiposocorrenciasUpsertWithoutOcorrenciasInput = {
  update: tiposocorrenciasUpdateWithoutOcorrenciasInput
  create: tiposocorrenciasCreateWithoutOcorrenciasInput
}

export type empresasCreateWithoutTiposocorrenciasInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithouttiposocorrenciasInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutTiposocorrenciasInput
}

export type ocorrenciasCreateWithoutTiposocorrenciasInput = {
  CPF?: XOR<string, null>
  DtOcorrencia?: XOR<Date | string, null>
}

export type ocorrenciasCreateOrConnectWithouttiposocorrenciasInput = {
  where: ocorrenciasWhereUniqueInput
  create: ocorrenciasCreateWithoutTiposocorrenciasInput
}

export type empresasUpdateWithoutTiposocorrenciasInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutTiposocorrenciasInput = {
  update: empresasUpdateWithoutTiposocorrenciasInput
  create: empresasCreateWithoutTiposocorrenciasInput
}

export type ocorrenciasUpdateWithWhereUniqueWithoutTiposocorrenciasInput = {
  where: ocorrenciasWhereUniqueInput
  data: ocorrenciasUpdateWithoutTiposocorrenciasInput
}

export type ocorrenciasUpdateManyWithWhereWithoutTiposocorrenciasInput = {
  where: ocorrenciasScalarWhereInput
  data: ocorrenciasUpdateManyMutationInput
}

export type ocorrenciasScalarWhereInput = {
  AND?: XOR<ocorrenciasScalarWhereInput, Enumerable<ocorrenciasScalarWhereInput>>
  OR?: XOR<ocorrenciasScalarWhereInput, Enumerable<ocorrenciasScalarWhereInput>>
  NOT?: XOR<ocorrenciasScalarWhereInput, Enumerable<ocorrenciasScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  CPF?: StringNullableFilter | string | null
  IdTipoOcorrencia?: IntNullableFilter | number | null
  DtOcorrencia?: DateTimeNullableFilter | Date | string | null
}

export type ocorrenciasUpsertWithWhereUniqueWithoutTiposocorrenciasInput = {
  where: ocorrenciasWhereUniqueInput
  update: ocorrenciasUpdateWithoutTiposocorrenciasInput
  create: ocorrenciasCreateWithoutTiposocorrenciasInput
}

export type escalasCreateWithoutEscalascompetenciaInput = {
  NmEscala?: XOR<string, null>
  Folgas?: XOR<string, null>
  empresas?: empresasCreateOneWithoutEscalasInput
  dados?: dadosCreateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutEscalasInput
}

export type escalasCreateOrConnectWithoutescalascompetenciaInput = {
  where: escalasWhereUniqueInput
  create: escalasCreateWithoutEscalascompetenciaInput
}

export type escalasUpdateWithoutEscalascompetenciaInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutEscalasInput
  dados?: dadosUpdateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutEscalasInput
}

export type escalasUpsertWithoutEscalascompetenciaInput = {
  update: escalasUpdateWithoutEscalascompetenciaInput
  create: escalasCreateWithoutEscalascompetenciaInput
}

export type meurhCreateWithoutMeurhhistoricoInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: XOR<Date | string, null>
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Status?: XOR<string, null>
  dados?: dadosCreateOneWithoutMeurhInput
}

export type meurhCreateOrConnectWithoutmeurhhistoricoInput = {
  where: meurhWhereUniqueInput
  create: meurhCreateWithoutMeurhhistoricoInput
}

export type meurhUpdateWithoutMeurhhistoricoInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutMeurhInput
}

export type meurhUpsertWithoutMeurhhistoricoInput = {
  update: meurhUpdateWithoutMeurhhistoricoInput
  create: meurhCreateWithoutMeurhhistoricoInput
}

export type dadosCreateWithoutSuporteInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutsuporteInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutSuporteInput
}

export type suportehistoricoCreateWithoutSuporteInput = {
  StatusAtual?: XOR<string, null>
  StatusNovo?: XOR<string, null>
  DtAlteracao?: XOR<Date | string, null>
  Msg?: XOR<string, null>
}

export type suportehistoricoCreateOrConnectWithoutsuporteInput = {
  where: suportehistoricoWhereUniqueInput
  create: suportehistoricoCreateWithoutSuporteInput
}

export type dadosUpdateWithoutSuporteInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
}

export type dadosUpsertWithoutSuporteInput = {
  update: dadosUpdateWithoutSuporteInput
  create: dadosCreateWithoutSuporteInput
}

export type suportehistoricoUpdateWithWhereUniqueWithoutSuporteInput = {
  where: suportehistoricoWhereUniqueInput
  data: suportehistoricoUpdateWithoutSuporteInput
}

export type suportehistoricoUpdateManyWithWhereWithoutSuporteInput = {
  where: suportehistoricoScalarWhereInput
  data: suportehistoricoUpdateManyMutationInput
}

export type suportehistoricoScalarWhereInput = {
  AND?: XOR<suportehistoricoScalarWhereInput, Enumerable<suportehistoricoScalarWhereInput>>
  OR?: XOR<suportehistoricoScalarWhereInput, Enumerable<suportehistoricoScalarWhereInput>>
  NOT?: XOR<suportehistoricoScalarWhereInput, Enumerable<suportehistoricoScalarWhereInput>>
  Id?: XOR<IntFilter, number>
  IdSuporte?: IntNullableFilter | number | null
  StatusAtual?: StringNullableFilter | string | null
  StatusNovo?: StringNullableFilter | string | null
  DtAlteracao?: DateTimeNullableFilter | Date | string | null
  Msg?: StringNullableFilter | string | null
}

export type suportehistoricoUpsertWithWhereUniqueWithoutSuporteInput = {
  where: suportehistoricoWhereUniqueInput
  update: suportehistoricoUpdateWithoutSuporteInput
  create: suportehistoricoCreateWithoutSuporteInput
}

export type suporteCreateWithoutSuportehistoricoInput = {
  Protocolo?: XOR<string, null>
  DtTicketAbertura?: Date | string
  DtTicketFechamento?: XOR<Date | string, null>
  Assunto?: XOR<string, null>
  Msg?: XOR<string, null>
  Avaliacao?: XOR<number, null>
  Status?: XOR<string, null>
  dados?: dadosCreateOneWithoutSuporteInput
}

export type suporteCreateOrConnectWithoutsuportehistoricoInput = {
  where: suporteWhereUniqueInput
  create: suporteCreateWithoutSuportehistoricoInput
}

export type suporteUpdateWithoutSuportehistoricoInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Avaliacao?: number | NullableIntFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutSuporteInput
}

export type suporteUpsertWithoutSuportehistoricoInput = {
  update: suporteUpdateWithoutSuportehistoricoInput
  create: suporteCreateWithoutSuportehistoricoInput
}

export type dadosCreateWithoutMeurhrespostasInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutmeurhrespostasInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutMeurhrespostasInput
}

export type dadosUpdateWithoutMeurhrespostasInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type dadosUpsertWithoutMeurhrespostasInput = {
  update: dadosUpdateWithoutMeurhrespostasInput
  create: dadosCreateWithoutMeurhrespostasInput
}

export type empresasCreateWithoutPedidosInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  economia?: economiaCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithoutpedidosInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutPedidosInput
}

export type detalhepedidos_oldCreateWithoutPedidosInput = {
  NmColaborador?: XOR<string, null>
  NrCartao?: XOR<string, null>
  NmOperadora?: XOR<string, null>
  ValorDia?: XOR<number, null>
  QtdFolgas?: XOR<number, null>
  QtdDiasUteis?: XOR<number, null>
  Valor?: XOR<number, null>
  QtdVale?: XOR<number, null>
  MemoriaCalculo?: XOR<string, null>
  dados?: dadosCreateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasCreateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasCreateOneWithoutDetalhepedidos_oldInput
}

export type detalhepedidos_oldCreateOrConnectWithoutpedidosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  create: detalhepedidos_oldCreateWithoutPedidosInput
}

export type empresasUpdateWithoutPedidosInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  economia?: economiaUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutPedidosInput = {
  update: empresasUpdateWithoutPedidosInput
  create: empresasCreateWithoutPedidosInput
}

export type detalhepedidos_oldUpdateWithWhereUniqueWithoutPedidosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  data: detalhepedidos_oldUpdateWithoutPedidosInput
}

export type detalhepedidos_oldUpdateManyWithWhereWithoutPedidosInput = {
  where: detalhepedidos_oldScalarWhereInput
  data: detalhepedidos_oldUpdateManyMutationInput
}

export type detalhepedidos_oldUpsertWithWhereUniqueWithoutPedidosInput = {
  where: detalhepedidos_oldWhereUniqueInput
  update: detalhepedidos_oldUpdateWithoutPedidosInput
  create: detalhepedidos_oldCreateWithoutPedidosInput
}

export type dadosCreateWithoutDetalhepedidos_oldInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  solicitacoes?: solicitacoesCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutdetalhepedidos_oldInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutDetalhepedidos_oldInput
}

export type escalasCreateWithoutDetalhepedidos_oldInput = {
  NmEscala?: XOR<string, null>
  Folgas?: XOR<string, null>
  empresas?: empresasCreateOneWithoutEscalasInput
  dados?: dadosCreateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaCreateManyWithoutEscalasInput
}

export type escalasCreateOrConnectWithoutdetalhepedidos_oldInput = {
  where: escalasWhereUniqueInput
  create: escalasCreateWithoutDetalhepedidos_oldInput
}

export type operadorasCreateWithoutDetalhepedidos_oldInput = {
  NmOperadora?: XOR<string, null>
  UF?: XOR<string, null>
  empresas?: empresasCreateOneWithoutOperadorasInput
  passagens?: passagensCreateManyWithoutOperadorasInput
}

export type operadorasCreateOrConnectWithoutdetalhepedidos_oldInput = {
  where: operadorasWhereUniqueInput
  create: operadorasCreateWithoutDetalhepedidos_oldInput
}

export type pedidosCreateWithoutDetalhepedidos_oldInput = {
  Competencia?: XOR<string, null>
  DtInicialFolgas?: XOR<Date | string, null>
  DtFinalFolgas?: XOR<Date | string, null>
  DtInicialFaltas?: XOR<Date | string, null>
  DtFinalFaltas?: XOR<Date | string, null>
  Status?: XOR<string, null>
  empresas?: empresasCreateOneWithoutPedidosInput
}

export type pedidosCreateOrConnectWithoutdetalhepedidos_oldInput = {
  where: pedidosWhereUniqueInput
  create: pedidosCreateWithoutDetalhepedidos_oldInput
}

export type dadosUpdateWithoutDetalhepedidos_oldInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type dadosUpsertWithoutDetalhepedidos_oldInput = {
  update: dadosUpdateWithoutDetalhepedidos_oldInput
  create: dadosCreateWithoutDetalhepedidos_oldInput
}

export type escalasUpdateWithoutDetalhepedidos_oldInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutEscalasInput
  dados?: dadosUpdateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaUpdateManyWithoutEscalasInput
}

export type escalasUpsertWithoutDetalhepedidos_oldInput = {
  update: escalasUpdateWithoutDetalhepedidos_oldInput
  create: escalasCreateWithoutDetalhepedidos_oldInput
}

export type operadorasUpdateWithoutDetalhepedidos_oldInput = {
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  UF?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutOperadorasInput
  passagens?: passagensUpdateManyWithoutOperadorasInput
}

export type operadorasUpsertWithoutDetalhepedidos_oldInput = {
  update: operadorasUpdateWithoutDetalhepedidos_oldInput
  create: operadorasCreateWithoutDetalhepedidos_oldInput
}

export type pedidosUpdateWithoutDetalhepedidos_oldInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  DtInicialFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtInicialFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutPedidosInput
}

export type pedidosUpsertWithoutDetalhepedidos_oldInput = {
  update: pedidosUpdateWithoutDetalhepedidos_oldInput
  create: pedidosCreateWithoutDetalhepedidos_oldInput
}

export type empresasCreateWithoutEconomiaInput = {
  CNPJ?: XOR<string, null>
  NmEmpresa?: XOR<string, null>
  NmFantasia?: XOR<string, null>
  Endereco?: XOR<string, null>
  CEP?: XOR<string, null>
  Situacao?: XOR<string, null>
  Tipo?: XOR<string, null>
  centrodecustos?: centrodecustosCreateManyWithoutEmpresasInput
  dados?: dadosCreateManyWithoutEmpresasInput
  escalas?: escalasCreateManyWithoutEmpresasInput
  operadoras?: operadorasCreateManyWithoutEmpresasInput
  pedidos?: pedidosCreateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasCreateManyWithoutEmpresasInput
}

export type empresasCreateOrConnectWithouteconomiaInput = {
  where: empresasWhereUniqueInput
  create: empresasCreateWithoutEconomiaInput
}

export type empresasUpdateWithoutEconomiaInput = {
  CNPJ?: string | NullableStringFieldUpdateOperationsInput | null
  NmEmpresa?: string | NullableStringFieldUpdateOperationsInput | null
  NmFantasia?: string | NullableStringFieldUpdateOperationsInput | null
  Endereco?: string | NullableStringFieldUpdateOperationsInput | null
  CEP?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  Tipo?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateManyWithoutEmpresasInput
  dados?: dadosUpdateManyWithoutEmpresasInput
  escalas?: escalasUpdateManyWithoutEmpresasInput
  operadoras?: operadorasUpdateManyWithoutEmpresasInput
  pedidos?: pedidosUpdateManyWithoutEmpresasInput
  tiposocorrencias?: tiposocorrenciasUpdateManyWithoutEmpresasInput
}

export type empresasUpsertWithoutEconomiaInput = {
  update: empresasUpdateWithoutEconomiaInput
  create: empresasCreateWithoutEconomiaInput
}

export type dadosCreateWithoutSolicitacoesInput = {
  NmColaborador?: XOR<string, null>
  CPF?: XOR<string, null>
  DtNascimento?: XOR<string, null>
  Matricula?: XOR<string, null>
  Situacao?: XOR<string, null>
  centrodecustos?: centrodecustosCreateOneWithoutDadosInput
  empresas?: empresasCreateOneWithoutDadosInput
  escalas?: escalasCreateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldCreateManyWithoutDadosInput
  meurh?: meurhCreateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasCreateManyWithoutDadosInput
  suporte?: suporteCreateManyWithoutDadosInput
}

export type dadosCreateOrConnectWithoutsolicitacoesInput = {
  where: dadosWhereUniqueInput
  create: dadosCreateWithoutSolicitacoesInput
}

export type dadosUpdateWithoutSolicitacoesInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type dadosUpsertWithoutSolicitacoesInput = {
  update: dadosUpdateWithoutSolicitacoesInput
  create: dadosCreateWithoutSolicitacoesInput
}

export type dadosUpdateWithoutCentrodecustosInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  empresas?: empresasUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type centrodecustosUpdateWithoutEmpresasInput = {
  NmCentroDeCusto?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateManyWithoutCentrodecustosInput
}

export type dadosUpdateWithoutEmpresasInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  escalas?: escalasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type economiaUpdateWithoutEmpresasInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
}

export type escalasUpdateWithoutEmpresasInput = {
  NmEscala?: string | NullableStringFieldUpdateOperationsInput | null
  Folgas?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateManyWithoutEscalasInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutEscalasInput
  escalascompetencia?: escalascompetenciaUpdateManyWithoutEscalasInput
}

export type operadorasUpdateWithoutEmpresasInput = {
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  UF?: string | NullableStringFieldUpdateOperationsInput | null
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutOperadorasInput
  passagens?: passagensUpdateManyWithoutOperadorasInput
}

export type pedidosUpdateWithoutEmpresasInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  DtInicialFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFolgas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtInicialFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtFinalFaltas?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutPedidosInput
}

export type tiposocorrenciasUpdateWithoutEmpresasInput = {
  NmOcorrencia?: string | NullableStringFieldUpdateOperationsInput | null
  DescBeneficio?: boolean | NullableBoolFieldUpdateOperationsInput | null
  Descricao?: string | NullableStringFieldUpdateOperationsInput | null
  ocorrencias?: ocorrenciasUpdateManyWithoutTiposocorrenciasInput
}

export type detalhepedidos_oldUpdateWithoutOperadorasInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasUpdateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosUpdateOneWithoutDetalhepedidos_oldInput
}

export type passagensUpdateWithoutOperadorasInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdDia?: number | NullableIntFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
}

export type detalhepedidos_oldUpdateWithoutDadosInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
  escalas?: escalasUpdateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasUpdateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosUpdateOneWithoutDetalhepedidos_oldInput
}

export type meurhUpdateWithoutDadosInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  meurhhistorico?: meurhhistoricoUpdateManyWithoutMeurhInput
}

export type meurhrespostasUpdateWithoutDadosInput = {
  IdMeuRh?: number | NullableIntFieldUpdateOperationsInput | null
  DtResposta?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
}

export type solicitacoesUpdateWithoutDadosInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  TipoSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  OrigemSolicitacao?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  DtSolicitacao?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtFinalizacao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
}

export type suporteUpdateWithoutDadosInput = {
  Protocolo?: string | NullableStringFieldUpdateOperationsInput | null
  DtTicketAbertura?: XOR<Date | string, DateTimeFieldUpdateOperationsInput>
  DtTicketFechamento?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Assunto?: string | NullableStringFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
  Avaliacao?: number | NullableIntFieldUpdateOperationsInput | null
  Status?: string | NullableStringFieldUpdateOperationsInput | null
  suportehistorico?: suportehistoricoUpdateManyWithoutSuporteInput
}

export type dadosUpdateWithoutEscalasInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtNascimento?: string | NullableStringFieldUpdateOperationsInput | null
  Matricula?: string | NullableStringFieldUpdateOperationsInput | null
  Situacao?: string | NullableStringFieldUpdateOperationsInput | null
  centrodecustos?: centrodecustosUpdateOneWithoutDadosInput
  empresas?: empresasUpdateOneWithoutDadosInput
  detalhepedidos_old?: detalhepedidos_oldUpdateManyWithoutDadosInput
  meurh?: meurhUpdateManyWithoutDadosInput
  meurhrespostas?: meurhrespostasUpdateManyWithoutDadosInput
  solicitacoes?: solicitacoesUpdateManyWithoutDadosInput
  suporte?: suporteUpdateManyWithoutDadosInput
}

export type detalhepedidos_oldUpdateWithoutEscalasInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasUpdateOneWithoutDetalhepedidos_oldInput
  pedidos?: pedidosUpdateOneWithoutDetalhepedidos_oldInput
}

export type escalascompetenciaUpdateWithoutEscalasInput = {
  Competencia?: string | NullableStringFieldUpdateOperationsInput | null
  QtdUteis?: number | NullableIntFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
}

export type meurhhistoricoUpdateWithoutMeurhInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type ocorrenciasUpdateWithoutTiposocorrenciasInput = {
  CPF?: string | NullableStringFieldUpdateOperationsInput | null
  DtOcorrencia?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type suportehistoricoUpdateWithoutSuporteInput = {
  StatusAtual?: string | NullableStringFieldUpdateOperationsInput | null
  StatusNovo?: string | NullableStringFieldUpdateOperationsInput | null
  DtAlteracao?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  Msg?: string | NullableStringFieldUpdateOperationsInput | null
}

export type detalhepedidos_oldUpdateWithoutPedidosInput = {
  NmColaborador?: string | NullableStringFieldUpdateOperationsInput | null
  NrCartao?: string | NullableStringFieldUpdateOperationsInput | null
  NmOperadora?: string | NullableStringFieldUpdateOperationsInput | null
  ValorDia?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdFolgas?: number | NullableIntFieldUpdateOperationsInput | null
  QtdDiasUteis?: number | NullableIntFieldUpdateOperationsInput | null
  Valor?: number | NullableFloatFieldUpdateOperationsInput | null
  QtdVale?: number | NullableIntFieldUpdateOperationsInput | null
  MemoriaCalculo?: string | NullableStringFieldUpdateOperationsInput | null
  dados?: dadosUpdateOneWithoutDetalhepedidos_oldInput
  escalas?: escalasUpdateOneWithoutDetalhepedidos_oldInput
  operadoras?: operadorasUpdateOneWithoutDetalhepedidos_oldInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
